
; ******** Source: src/hyppo/main.asm
     1                            ;; ------------------------------------------------------------------- 
     2                            ;;   MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                            ;;   Paul Gardner-Stephen, 2014-2019.
     4                            ;;   -------------------------------------------------------------------
     5                            ;;   Purpose:
     6                            ;;   1. Verify checksum of ROM area of slow RAM.
     7                            ;;   2. If checksum fails, load complete ROM from SD card.
     8                            ;;   3. Select default disk image for F011 emulation.
     9                          
    10                            ;;   The hyppo ROM is 16KB in length, and maps at $8000-$BFFF
    11                            ;;   in hypervisor mode.
    12                          
    13                            ;;   Hyppo modifies RAM from $0000-$07FFF (ZP, stack, 40-column
    14                            ;;   screen, 16-bit text mode) during normal boot.
    15                          
    16                            ;;   BG: is the below true still, I dont think so.
    17                            ;;   If Hyppo needs to load the ROM from SD card, then it may
    18                            ;;   modify the first 64KB of fast ram.
    19                          
    20                            ;;   We will use the convention of C=0 means failure, ie CLC/RTS,
    21                            ;;                             and C=1 means success, ie SEC/RTS.
    22                          
    23                          
    24                            ;;   This included file defines many of the alias used throughout
    25                            ;;   it also suggests some memory-map definitions
    26                            ;;   ---------------------------------------------------------------- 
    27                          

; ******** Source: constants.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                   os_version = $0102
     7                                   dos_version = $0102
     8                                   constant_partition_type_fat32_chs = $0b
     9                                   constant_partition_type_fat32_lba = $0c
    10                                   constant_partition_type_megea65_sys = $41
    11                          
    12                                  ;; DOS error codes
    13                                  ;;
    14                                   dos_errorcode_partition_not_interesting = $01
    15                                   dos_errorcode_bad_signature = $02
    16                                   dos_errorcode_is_small_fat = $03
    17                                   dos_errorcode_too_many_reserved_clusters = $04
    18                                   dos_errorcode_not_two_fats = $05
    19                                   dos_errorcode_too_few_clusters = $06
    20                                   dos_errorcode_read_timeout = $07
    21                                   dos_errorcode_partition_error = $08
    22                                   dos_errorcode_invalid_address = $10
    23                                   dos_errorcode_illegal_value = $11
    24                                   dos_errorcode_read_error = $20
    25                                   dos_errorcode_write_error = $21
    26                                   dos_errorcode_no_such_disk = $80
    27                                   dos_errorcode_name_too_long = $81
    28                                   dos_errorcode_not_implemented = $82
    29                                   dos_errorcode_file_too_long = $83
    30                                   dos_errorcode_too_many_open_files = $84
    31                                   dos_errorcode_invalid_cluster = $85
    32                                   dos_errorcode_is_a_directory = $86
    33                                   dos_errorcode_not_a_directory = $87
    34                                   dos_errorcode_file_not_found = $88
    35                                   dos_errorcode_invalid_file_descriptor = $89
    36                                   dos_errorcode_image_wrong_length = $8A
    37                                   dos_errorcode_image_fragmented = $8B
    38                                   dos_errorcode_no_space = $8C
    39                                   dos_errorcode_file_exists = $8D
    40                                   dos_errorcode_directory_full = $8E
    41                                   dos_errorcode_eof = $FF
    42                          
    43                                  ;; FAT directory entry constants
    44                                  ;;
    45                                  ;; these seem to be offsets into the STANDARD FAT32 header (DO NOT CHANGE)
    46                                  ;;
    47                                   fs_fat32_dirent_offset_attributes = 11
    48                                   fs_fat32_dirent_offset_shortname = 0
    49                                   fs_fat32_dirent_offset_create_tenthsofseconds = 13
    50                                   fs_fat32_dirent_offset_create_time = 14
    51                                   fs_fat32_dirent_offset_create_date = 16
    52                                   fs_fat32_dirent_offset_access_date = 18
    53                                   fs_fat32_dirent_offset_clusters_high = 20
    54                                   fs_fat32_dirent_offset_modify_time = 22
    55                                   fs_fat32_dirent_offset_modify_date = 24
    56                                   fs_fat32_dirent_offset_clusters_low = 26
    57                                   fs_fat32_dirent_offset_file_length = 28
    58                          
    59                                  ;; VFAT long file name entry constants
    60                                  ;;
    61                                  ;; These are the offsets of the various fields in a directory entry, when
    62                                  ;; used to store a long-file-name fragment.
    63                                  ;;
    64                                   fs_fat32_dirent_offset_lfn_part_number = 0
    65                                   fs_fat32_dirent_offset_lfn_type = 12
    66                                   fs_fat32_dirent_offset_lfn_checksum = 13
    67                                   fs_fat32_dirent_offset_lfn_part1_chars = 5
    68                                   fs_fat32_dirent_offset_lfn_part1_start = 1
    69                                   fs_fat32_dirent_offset_lfn_part2_chars = 6
    70                                   fs_fat32_dirent_offset_lfn_part2_start = 14
    71                                   fs_fat32_dirent_offset_lfn_part3_chars = 2
    72                                   fs_fat32_dirent_offset_lfn_part3_start = 28
    73                          
    74                                   fs_fat32_attribute_isreadonly = $01
    75                                   fs_fat32_attribute_ishidden = $02
    76                                   fs_fat32_attribute_issystem = $04
    77                                   fs_fat32_attribute_isvolumelabel = $08
    78                                   fs_fat32_attribute_isdirectory = $10
    79                                   fs_fat32_attribute_archiveset = $20
    80                          
    81                                  ;; Possible file modes
    82                                  ;;
    83                                   dos_filemode_directoryaccess = $80
    84                                   dos_filemode_end_of_directory = $81
    85                                   dos_filemode_readonly = 0
    86                                   dos_filemode_readwrite = 1
    87                          
    88                                  ;; 256-byte fixed size records for REL emulaton
    89                                  ;;
    90                                   dos_filemode_relative = 2
    91                          
    92                                  ;; Each disk entry consists of;
    93                                  ;;
    94                                  ;; Offset $00 - starting sector (4 bytes)
    95                                   fs_start_sector = $00
    96                          
    97                                  ;; Offset $04 - sector count (4 bytes)
    98                                   fs_sector_count = $04
    99                          
   100                                  ;; Offset $08 - Filesystem type & media source ($0x = FAT32, $xF = SD card, others reserved for now)
   101                                   fs_type_and_source = $08
   102                          
   103                                  ;; Remaining bytes are filesystem dependent:
   104                                  ;; For FAT32:
   105                                  ;;
   106                                  ;; Offset $09 - length of fat (4 bytes) (FAT starts at fs_fat32_system_sectors)
   107                                   fs_fat32_length_of_fat = $09
   108                          
   109                                  ;; Offset $0D - system sectors (2 bytes)
   110                                   fs_fat32_system_sectors = $0D
   111                          
   112                                  ;; Offset $0F - reserved clusters (1 byte)
   113                                   fs_fat32_reserved_clusters = $0F
   114                          
   115                                  ;; Offset $10 - root dir cluster (2 bytes)
   116                                   fs_fat32_root_dir_cluster = $10
   117                          
   118                                  ;; Offset $12 - cluster count (4 bytes)
   119                                   fs_fat32_cluster_count = $12
   120                          
   121                                  ;; Offset $16 - sectors per cluster
   122                                   fs_fat32_sectors_per_cluster = $16
   123                          
   124                                  ;; Offset $17 - copies of FAT
   125                                   fs_fat32_fat_copies = $17
   126                          
   127                                  ;; Offset $18 - first sector of cluster zero (4 bytes)
   128                                   fs_fat32_cluster0_sector = $18
   129                          
   130                                  ;; Offset $1C - Four spare bytes.
   131                          
   132                                   freeze_prep_none = 0
   133                                   freeze_prep_palette0 = 2
   134                                   freeze_prep_palette1 = 4
   135                                   freeze_prep_palette2 = 6
   136                                   freeze_prep_palette3 = 8
   137                                   freeze_prep_stash_sd_buffer_and_regs = 10
   138                                   freeze_prep_thumbnail = 12
   139                                   freeze_prep_viciv = 14
   140                           	 freeze_prep_hyperregs = 16
   141                          
   142                                   d81_image_max_namelen = 32
   143                                   d81_image_flag_mounted = 1
   144                                   d81_image_flag_write_en = 4
   145                          
   146                                   syspart_error_readerror = $01
   147                                   syspart_error_badslotnum = $02
   148                                   syspart_error_badmagic = $42
   149                                   syspart_error_nosyspart = $ff

; ******** Source: src/hyppo/main.asm

; ******** Source: macros.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          
     7                          // Convenient macro for checkpoints. Uncomment the body to activate it
     8                          !macro Checkpoint .text {
     9                                  ;; jsr checkpoint
    10                                  ;; .byte 0
    11                                  ;; !ascii(.text)
    12                                  ;; .byte 0
    13                          }
    14                          
    15                          

; ******** Source: src/hyppo/main.asm

; ******** Source: machine.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          !addr reset_vector = $fffc
     7                          !addr irq_vector = $fffe
     8                          !addr nmi_vector = $fffa
     9                          
    10                                  ;; UART IO block (contains many other peripherals)
    11                          !addr uart65_irq_flag = $d606
    12                          !addr ascii_key_in = $d610
    13                          !addr buckykey_status = $d611
    14                          !addr mouse_detect_ctrl = $d61b
    15                          
    16                                  ;; Hypervisor regisger block $d640-$d67f
    17                          !addr hypervisor_a = $d640
    18                          !addr hypervisor_x = $d641
    19                          !addr hypervisor_y = $d642
    20                          !addr hypervisor_z = $d643
    21                          !addr hypervisor_b = $d644
    22                          !addr hypervisor_spl = $d645
    23                          !addr hypervisor_sph = $d646
    24                          !addr hypervisor_flags = $d647
    25                          !addr hypervisor_pcl = $d648
    26                          !addr hypervisor_pch = $d649
    27                          !addr hypervisor_maplolo = $d64a
    28                          !addr hypervisor_maplohi = $d64b
    29                          !addr hypervisor_maphilo = $d64c
    30                          !addr hypervisor_maphihi = $d64d
    31                          !addr hypervisor_maplomb = $d64e
    32                          !addr hypervisor_maphimb = $d64f
    33                          !addr hypervisor_cpuport00 = $d650
    34                          !addr hypervisor_cpuport01 = $d651
    35                          !addr hypervisor_iomode = $d652
    36                          !addr hypervisor_dmagic_srcmb = $d653
    37                          !addr hypervisor_dmagic_dstmb = $d654
    38                          !addr hypervisor_dmagic_list0 = $d655
    39                          !addr hypervisor_dmagic_list1 = $d656
    40                          !addr hypervisor_dmagic_list2 = $d657
    41                          !addr hypervisor_dmagic_list3 = $d658
    42                          !addr hypervisor_hardware_virtualisation = $d659
    43                          
    44                                  ;; d65a
    45                                  ;; d65b
    46                                  ;; d65c
    47                          
    48                          !addr hypervisor_vm_currentpage_lo = $d65d
    49                          !addr hypervisor_vm_currentpage_mid = $d65e
    50                          !addr hypervisor_vm_currentpage_hi = $d65f
    51                          
    52                          !addr hypervisor_vm_pagetable = $d660
    53                          !addr hypervisor_vm_pagetable0_logicalpage_lo = $d660
    54                          !addr hypervisor_vm_pagetable0_logicalpage_hi = $d661
    55                          !addr hypervisor_vm_pagetable0_physicalpage_lo = $d662
    56                          !addr hypervisor_vm_pagetable0_physicalpage_hi = $d663
    57                          !addr hypervisor_vm_pagetable1_logicalpage_lo = $d664
    58                          !addr hypervisor_vm_pagetable1_logicalpage_hi = $d665
    59                          !addr hypervisor_vm_pagetable1_physicalpage_lo = $d666
    60                          !addr hypervisor_vm_pagetable1_physicalpage_hi = $d667
    61                          !addr hypervisor_vm_pagetable2_logicalpage_lo = $d668
    62                          !addr hypervisor_vm_pagetable2_logicalpage_hi = $d669
    63                          !addr hypervisor_vm_pagetable2_physicalpage_lo = $d66a
    64                          !addr hypervisor_vm_pagetable2_physicalpage_hi = $d66b
    65                          !addr hypervisor_vm_pagetable3_logicalpage_lo = $d66c
    66                          !addr hypervisor_vm_pagetable3_logicalpage_hi = $d66d
    67                          !addr hypervisor_vm_pagetable3_physicalpage_lo = $d66e
    68                          !addr hypervisor_vm_pagetable3_physicalpage_hi = $d66f
    69                          
    70                          !addr hypervisor_georam_base_mb = $d670
    71                          !addr hypervsior_georam_block_mask = $d671
    72                          
    73                                  ;; d672 110 010
    74                          !addr hypervisor_secure_mode_flags = $d672
    75                          
    76                                  ;; d673
    77                                  ;; d674
    78                                  ;; d675
    79                                  ;; d676
    80                                  ;; d677
    81                                  ;; d678
    82                                  ;; d679
    83                                  ;; d67a
    84                                  ;; d67b
    85                          
    86                          !addr hypervisor_write_char_to_serial_monitor = $d67c
    87                          
    88                          !addr hypervisor_feature_enables = $d67d
    89                          !addr hypervisor_hickedup_flag = $d67e
    90                          !addr hypervisor_cartridge_flags = $d67e
    91                          !addr hypervisor_enterexit_trigger = $d67f
    92                          
    93                                  ;; Where sector buffer maps (over $DE00-$DFFF IO expansion space)
    94                          !addr sd_sectorbuffer = $DE00
    95                          !addr sd_ctrl = $d680
    96                          !addr sd_address_byte0 = $D681
    97                          !addr sd_address_byte1 = $D682
    98                          !addr sd_address_byte2 = $D683
    99                          !addr sd_address_byte3 = $D684
   100                          !addr sd_buffer_ctrl = $d689
   101                          !addr sd_f011_en = $d68b
   102                          !addr sd_fdc_select = $d6a1
   103                          !addr fdc_mfm_speed = $d6a2
   104                          !addr f011_flag_stomp  = $d6af
   105                          
   106                          !addr fpga_switches_low = $d6dc
   107                          !addr fpga_switches_high = $d6dd
   108                          
   109                                  ;; $D6Ex - Ethernet controller
   110                          !addr mac_addr_0 = $d6e9
   111                          !addr mac_addr_1 = $d6ea
   112                          !addr mac_addr_2 = $d6eb
   113                          !addr mac_addr_3 = $d6ec
   114                          !addr mac_addr_4 = $d6ed
   115                          !addr mac_addr_5 = $d6ee
   116                          
   117                                  ;; $D6Fx - mostly audio interfaces
   118                          !addr audiomix_addr = $d6f4
   119                          !addr audiomix_data = $d6f5
   120                          !addr audioamp_ctl = $d6fe
   121                          
   122                                  ;; Hardware 25(d) x 18(e) multiplier
   123                          !addr mult48_d0 = $d770
   124                          !addr mult48_d1 = $d771
   125                          !addr mult48_d2 = $d772
   126                          !addr mult48_d3 = $d773
   127                          !addr mult48_e0 = $d774
   128                          !addr mult48_e1 = $d775
   129                          !addr mult48_e2 = $d776
   130                          !addr mult48_e3 = $d777
   131                          !addr mult48_result0 = $d778
   132                          !addr mult48_result1 = $d779
   133                          !addr mult48_result2 = $d77a
   134                          !addr mult48_result3 = $d77b
   135                          !addr mult48_result4 = $d77c
   136                          !addr mult48_result5 = $d77d
   137                          !addr mult48_result6 = $d77e
   138                          !addr mult48_result7 = $d77f
   139                          
   140                          !addr viciv_magic = $d02f

; ******** Source: src/hyppo/main.asm
    31                          
    32                          !addr TrapEntryPoints_Start        = $8000
    33                          !addr RelocatedCPUVectors_Start    = $81f8
    34                          !addr Traps_Start                  = $8200
    35                          !addr DOSDiskTable_Start           = $bb00
    36                          !addr SysPartStructure_Start       = $bbc0
    37                          !addr DOSWorkArea_Start            = $bc00
    38                          !addr ProcessDescriptors_Start     = $bd00
    39                          !addr HyppoStack_Start             = $be00
    40                          !addr HyppoZP_Start                = $bf00
    41                          !addr Hyppo_End                    = $bfff
    42                          
    43                          ;; .file [name="../../bin/HICKUP.M65", type="bin", segments="TrapEntryPoints,RelocatedCPUVectors,Traps,DOSDiskTable,SysPartStructure,DOSWorkArea,ProcessDescriptors,HyppoStack,HyppoZP"] 
    44                          	!to "bin/HICKUP.M65", plain
    45                          
    46                          ;; .segmentdef TrapEntryPoints        [min=TrapEntryPoints_Start,     max=RelocatedCPUVectors_Start-1                         ]
    47                          ;; .segmentdef RelocatedCPUVectors    [min=RelocatedCPUVectors_Start, max=Traps_Start-1                                       ]
    48                          ;; .segmentdef Traps                  [min=Traps_Start,               max=DOSDiskTable_Start-1                                ]
    49                          ;; .segmentdef DOSDiskTable           [min=DOSDiskTable_Start,        max=SysPartStructure_Start-1,                           ]
    50                          ;; .segmentdef SysPartStructure       [min=SysPartStructure_Start,    max=DOSWorkArea_Start-1                                 ]
    51                          ;; .segmentdef DOSWorkArea            [min=DOSWorkArea_Start,         max=ProcessDescriptors_Start-1                          ]
    52                          ;; .segmentdef ProcessDescriptors     [min=ProcessDescriptors_Start,  max=HyppoStack_Start-1                                  ]
    53                          ;; .segmentdef HyppoStack             [min=HyppoStack_Start,          max=HyppoZP_Start-1,            fill, fillByte=$3e      ]
    54                          ;; .segmentdef HyppoZP                [min=HyppoZP_Start,             max=Hyppo_End,                  fill, fillByte=$3f      ]
    55                          ;; .segmentdef Data                   [min=Data_Start,                max=$ffff                                               ]
    56                          
    57                          ;;         .segment TrapEntryPoints
    58                                  * = TrapEntryPoints_Start
    59                          
    60                          ;; /*  -------------------------------------------------------------------
    61                          ;;     CPU Hypervisor Trap entry points.
    62                          ;;     64 x 4 byte entries for user-land traps.
    63                          ;;     some more x 4 byte entries for system traps (reset, page fault etc)
    64                          ;;     ---------------------------------------------------------------- */
    65                          
    66                          trap_entry_points:
    67                          
    68                                  ;; Traps $00-$07 (user callable)
    69                                  ;;
    70  8000 4c6f8b                     jmp dos_and_process_trap                ;; Trap #$00 (unsure what to call it)
    71  8003 ea                         eom                                     ;; refer: hyppo_dos.asm
    72  8004 4ccb9c                     jmp memory_trap                         ;; Trap #$01
    73  8007 ea                         eom                                     ;; refer: hyppo_mem.asm
    74  8008 4cbe85                     jmp syspart_trap                        ;; Trap #$02
    75  800b ea                         eom                                     ;; refer: hyppo_syspart.asm
    76  800c 4cb8ad                     jmp serialwrite                         ;; Trap #$03
    77  800f ea                         eom                                     ;; refer serialwrite in this file	
    78  8010 4c0082                     jmp emulatortrap                        ;; Trap #$04	
    79  8013 ea                         eom                                     ;; Reserved for Xemu to use
    80  8014 4c0082                     jmp nosuchtrap
    81  8017 ea                         eom
    82  8018 4c0082                     jmp nosuchtrap
    83  801b ea                         eom
    84  801c 4c0082                     jmp nosuchtrap
    85  801f ea                         eom
    86                          
    87                                  ;; Traps $08-$0F (user callable)
    88                                  ;;
    89  8020 4c0082                     jmp nosuchtrap
    90  8023 ea                         eom
    91  8024 4c0082                     jmp nosuchtrap
    92  8027 ea                         eom
    93  8028 4c0082                     jmp nosuchtrap
    94  802b ea                         eom
    95  802c 4c0082                     jmp nosuchtrap
    96  802f ea                         eom
    97  8030 4c0082                     jmp nosuchtrap
    98  8033 ea                         eom
    99  8034 4c0082                     jmp nosuchtrap
   100  8037 ea                         eom
   101  8038 4c0082                     jmp nosuchtrap
   102  803b ea                         eom
   103  803c 4c0082                     jmp nosuchtrap
   104  803f ea                         eom
   105                          
   106                                  ;; Traps $10-$17 (user callable)
   107                                  ;;
   108  8040 4c0082                     jmp nosuchtrap
   109  8043 ea                         eom
   110  8044 4cd49e                     jmp securemode_trap
   111  8047 ea                         eom
   112  8048 4ce19e                     jmp leave_securemode_trap
   113  804b ea                         eom
   114  804c 4c0082                     jmp nosuchtrap
   115  804f ea                         eom
   116  8050 4c0082                     jmp nosuchtrap
   117  8053 ea                         eom
   118  8054 4c0082                     jmp nosuchtrap
   119  8057 ea                         eom
   120  8058 4c0082                     jmp nosuchtrap
   121  805b ea                         eom
   122  805c 4c0082                     jmp nosuchtrap
   123  805f ea                         eom
   124                          
   125                                  ;; Traps $18-$1F (user callable)
   126                                  ;;
   127  8060 4c0082                     jmp nosuchtrap
   128  8063 ea                         eom
   129  8064 4c0082                     jmp nosuchtrap
   130  8067 ea                         eom
   131  8068 4c0082                     jmp nosuchtrap
   132  806b ea                         eom
   133  806c 4c0082                     jmp nosuchtrap
   134  806f ea                         eom
   135  8070 4c0082                     jmp nosuchtrap
   136  8073 ea                         eom
   137  8074 4c0082                     jmp nosuchtrap
   138  8077 ea                         eom
   139  8078 4c0082                     jmp nosuchtrap
   140  807b ea                         eom
   141  807c 4c0082                     jmp nosuchtrap
   142  807f ea                         eom
   143                          
   144                                  ;; Traps $20-$27 (user callable)
   145                                  ;;
   146  8080 4c0082                     jmp nosuchtrap
   147  8083 ea                         eom
   148  8084 4c0082                     jmp nosuchtrap
   149  8087 ea                         eom
   150  8088 4c0082                     jmp nosuchtrap
   151  808b ea                         eom
   152  808c 4c0082                     jmp nosuchtrap
   153  808f ea                         eom
   154  8090 4c0082                     jmp nosuchtrap
   155  8093 ea                         eom
   156  8094 4c0082                     jmp nosuchtrap
   157  8097 ea                         eom
   158  8098 4c0082                     jmp nosuchtrap
   159  809b ea                         eom
   160  809c 4c0082                     jmp nosuchtrap
   161  809f ea                         eom
   162                          
   163                                  ;; Traps $28-$2F (user callable)
   164                                  ;;
   165  80a0 4c0082                     jmp nosuchtrap
   166  80a3 ea                         eom
   167  80a4 4c0082                     jmp nosuchtrap
   168  80a7 ea                         eom
   169  80a8 4c0082                     jmp nosuchtrap
   170  80ab ea                         eom
   171  80ac 4c0082                     jmp nosuchtrap
   172  80af ea                         eom
   173  80b0 4c0082                     jmp nosuchtrap
   174  80b3 ea                         eom
   175  80b4 4c0082                     jmp nosuchtrap
   176  80b7 ea                         eom
   177  80b8 4c0082                     jmp nosuchtrap
   178  80bb ea                         eom
   179  80bc 4c0082                     jmp nosuchtrap
   180  80bf ea                         eom
   181                          
   182                                  ;; Traps $30-$37
   183                                  ;;
   184  80c0 4c0082                     jmp nosuchtrap
   185  80c3 ea                         eom
   186  80c4 4c0082                     jmp nosuchtrap
   187  80c7 ea                         eom
   188                          
   189  80c8 4cc09e                     jmp protected_hardware_config           ;; Trap #$32 (Protected Hardware Configuration)
   190  80cb ea                         eom                                     ;; refer: hyppo_task
   191                          
   192                          
   193  80cc 4c0082                     jmp nosuchtrap
   194  80cf ea                         eom
   195  80d0 4c0082                     jmp nosuchtrap
   196  80d3 ea                         eom
   197  80d4 4c0082                     jmp nosuchtrap
   198  80d7 ea                         eom
   199  80d8 4c0082                     jmp nosuchtrap
   200  80db ea                         eom
   201  80dc 4c0082                     jmp nosuchtrap
   202  80df ea                         eom
   203                          
   204                                  ;; Traps $38-$3F (user callable)
   205                                  ;;
   206  80e0 4c0082                     jmp nosuchtrap
   207  80e3 ea                         eom
   208  80e4 4c0082                     jmp nosuchtrap
   209  80e7 ea                         eom
   210  80e8 4c0082                     jmp nosuchtrap
   211  80eb ea                         eom
   212  80ec 4c0082                     jmp nosuchtrap
   213  80ef ea                         eom
   214  80f0 4c0082                     jmp nosuchtrap
   215  80f3 ea                         eom
   216  80f4 4c0082                     jmp nosuchtrap
   217  80f7 ea                         eom
   218  80f8 4c0082                     jmp nosuchtrap
   219  80fb ea                         eom
   220                          	;; Writing to $D67F shall trap to freezer, as though user had triggered it.
   221  80fc 4c379e                     jmp restore_press_trap
   222  80ff ea                         eom
   223                          
   224                                  ;; Traps $40-$4F (reset, page fault and other system-generated traps)
   225  8100 4cc3a2                     jmp reset_entry                         ;; Trap #$40 (power on / reset)
   226  8103 ea                         eom                                     ;; refer: below in this file
   227                          
   228  8104 4c739c                     jmp page_fault                          ;; Trap #$41 (page fault)
   229  8107 ea                         eom                                     ;; refer: hyppo_mem
   230                          
   231  8108 4c379e                     jmp restore_press_trap                  ;; Trap #$42 (press RESTORE for 0.5 - 1.99 seconds)
   232  810b ea                         eom                                     ;; refer: hyppo_task "1000010" x"42"
   233                          
   234  810c 4cc99e                     jmp matrix_mode_toggle                  ;; Trap #$43 (C= + TAB combination)
   235  810f ea                         eom                                     ;; refer: hyppo_task
   236                          
   237  8110 4c2ba0                     jmp f011_virtual_read                   ;; Trap #$44 (virtualised F011 sector read)
   238  8113 ea                         eom
   239                          
   240  8114 4c6ea0                     jmp f011_virtual_write                  ;; Trap #$45 (virtualised F011 sector write)
   241  8117 ea                         eom
   242                          
   243  8118 4c379e                     jmp unstable_illegal_opcode_trap        ;; Trap #$46 (6502 unstable illegal opcode)
   244  811b ea                         eom                                     
   245  811c 4c379e                     jmp kill_opcode_trap                    ;; Trap #$47 (6502 KIL instruction)
   246  811f ea                         eom
   247  8120 4c0082                     jmp nosuchtrap
   248  8123 ea                         eom
   249  8124 4c0082                     jmp nosuchtrap
   250  8127 ea                         eom
   251  8128 4c0082                     jmp nosuchtrap
   252  812b ea                         eom
   253  812c 4c0082                     jmp nosuchtrap
   254  812f ea                         eom
   255  8130 4c0082                     jmp nosuchtrap
   256  8133 ea                         eom
   257  8134 4c0082                     jmp nosuchtrap
   258  8137 ea                         eom
   259  8138 4c0082                     jmp nosuchtrap
   260  813b ea                         eom
   261  813c 4c0082                     jmp nosuchtrap
   262  813f ea                         eom
   263                          
   264                                  ;; Leave room for relocated cpu vectors below
   265                                  ;;
   266                                  ;; .segment RelocatedCPUVectors
   267                                  * = RelocatedCPUVectors_Start
   268                          
   269                                  ;; Then we have relocated CPU vectors at $81F8-$81FF
   270                                  ;; (which are 2-byte vectors for interrupts, not 4-byte
   271                                  ;; trap addresses).
   272                                  ;; These are used to catch interrupts in hypervisor mode
   273                                  ;; (although the need for them may have since been removed)
   274  81f8 c3a2                       !16 reset_entry    ;; unused vector
   275  81fa 60ab                       !16 hypervisor_nmi ;; NMI
   276  81fc c3a2                       !16 reset_entry    ;; RESET
   277  81fe 60ab                       !16 hypervisor_irq ;; IRQ
   278                          
   279                          	
   280                                  ;; .segment Traps
   281                                  * = Traps_Start
   282                          
   283                          ;; /*  -------------------------------------------------------------------
   284                          ;;     Hypervisor traps
   285                          ;;     ---------------------------------------------------------------- */
   286                          
   287                          ;; /*  -------------------------------------------------------------------
   288                          ;;     Illegal trap / trap sub-function handlers
   289                          
   290                          ;;     Traps are triggered by writing to $D640-$D67F
   291                          ;;     and trap to $8000+((address & $3F)*4) in the hypervisor
   292                          
   293                          ;;     Routine for unimplemented/reserved traps
   294                          ;;     (Consider replacing with trap to hypervisor error screen with option
   295                          ;;     to return?)
   296                          ;;     ---------------------------------------------------------------- */
   297                          emulatortrap:
   298                          	;; FALL-THROUGH -- return failure on real hardware
   299                          	;; Xemu will intercept it itself
   300                          nosuchtrap:
   301                          
   302                                  ;; Clear C flag for caller to indicate failure
   303                                  ;;
   304  8200 ad47d6                     lda hypervisor_flags
   305  8203 29fe                       and #$FE   ;; C flag is bit 0
   306  8205 8d47d6                     sta hypervisor_flags
   307                          
   308                                  ;; set A to $FF
   309                                  ;;
   310  8208 a9ff                       lda #$ff
   311  820a 8d40d6                     sta hypervisor_a
   312                          
   313                                  ;; return from hypervisor
   314                                  ;;
   315  820d 8d7fd6                     sta hypervisor_enterexit_trigger
   316                          
   317                          ;;         ========================
   318                          
   319                          return_from_trap_with_success:
   320                          
   321                                  ;; Return from trap with C flag clear to indicate success
   322                          
   323  8210 20cf9f                     jsr sd_unmap_sectorbuffer
   324                          
   325                                  ;; set C flag for caller to indicate success
   326                                  ;;
   327  8213 ad47d6                     lda hypervisor_flags
   328  8216 0901                       ora #$01   ;; C flag is bit 0
   329  8218 8d47d6                     sta hypervisor_flags
   330                          
   331                                  +Checkpoint "return_from_trap_with_success"
   332                          
   333                          	;; DO NOT Clear A on return
   334                                  ;; (else traps can't return anything in A register)
   335                          	
   336                                  ;; return from hypervisor
   337  821b 8d7fd6                     sta hypervisor_enterexit_trigger
   338                          
   339                          ;;         ========================
   340                          
   341                          return_from_trap_with_failure:
   342                          
   343  821e 20cf9f                     jsr sd_unmap_sectorbuffer
   344                          
   345                                  ;; report error in A
   346                                  ;;
   347  8221 8d40d6                     sta hypervisor_a
   348  8224 ad47d6                     lda hypervisor_flags
   349  8227 29fe                       and #$fe   ;; C flag is bit 0 (ie clear bit-0)
   350  8229 8d47d6                     sta hypervisor_flags
   351                          
   352                                  +Checkpoint "return_from_trap_with_failure"
   353                          
   354                                  ;; return from hypervisor
   355  822c 8d7fd6                     sta hypervisor_enterexit_trigger
   356                          
   357                          ;;         ========================
   358                          
   359                          invalid_subfunction:
   360                          
   361  822f 4c0082                     jmp nosuchtrap
   362                          
   363                          ;;         ========================
   364                          
   365                          ;; /*  -------------------------------------------------------------------
   366                          ;;     System Partition functions
   367                          ;;     ---------------------------------------------------------------- */
   368                          

; ******** Source: syspart.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          
     5                          ;;    MEGA65 System Partition functions
     6                          
     7                          ;;     The system partition (type = $41 = 65) holds several major data
     8                          ;;     areas:
     9                          
    10                          ;;     1. Header, that identifies the version and structure of the system
    11                          ;;        partition.
    12                          
    13                          ;;     2. Frozen programs for task switching.
    14                          ;;        (Some of which may be reserved by the operating system, e.g., for
    15                          ;;         alarms and other special purposes.)
    16                          
    17                          ;;     3. Installed services that can be requested via the Hypervisor.
    18                          ;;        These are internally just frozen programs with a valid service
    19                          ;;        description header.
    20                          
    21                          ;;     HEADER - First sector of partition
    22                          
    23                          ;;     $000-$00A "MEGA65SYS00" - Magic string and version indication
    24                          ;;     $010-$017 Start and size (in sectors) of frozen program area
    25                          ;;     $018-$01b Size of each frozen program slot
    26                          ;;     $01c-$01d Number of frozen program slots
    27                          ;;     $01e-$01f Number of sectors used for frozen program directory
    28                          ;;     $020-$027 Start and size (in sectors) or installed services
    29                          ;;     $028-$02b Size of each installed service slot
    30                          ;;     $02c-$02d Number of service slots
    31                          ;;     $02e-$02f Number of sectors used for slot directory
    32                          ;;     $030-$1ff RESERVED
    33                          
    34                          ;;     Basically we have two main areas in the system partition for frozen
    35                          ;;     programs, and for each we have a directory that allows for quick
    36                          ;;     scanning of the lists. Thee goal is to reduce the number of random
    37                          ;;     seeks (which still have a cost on SD cards, because commencing a
    38                          ;;     read is much slower than continuing one), and also the amount of
    39                          ;;     data required. To this end the directory entries consist of a 64
    40                          ;;     byte name field and a 64 byte reserved field, so that each is 128
    41                          ;;     bytes in total, allowing 4 per 512 byte sector.
    42                          
    43                          ;;     If the first byte of a directory is $00, then the entry is assumed
    44                          ;;     to be free.
    45                          ;;     ---------------------------------------------------------------- */
    46                          
    47                          onboarding_dmalist:	
    48                                  ;; MEGA65 Enhanced DMA options
    49  8232 0a                         !8 $0A      ;; Request format is F018A
    50  8233 8000                       !8 $80,$00  ;; Copy from $00xxxxx
    51  8235 8100                       !8 $81,$00  ;; Copy to $00xxxxx
    52                          
    53                          	;; Copy program down
    54  8237 00                         !8 $00 ;; no more options
    55                          	;; F018A DMA list
    56  8238 00                         !8 $00 ;; copy + not chained request
    57  8239 ff77                       !16 $77FF ;; size of copy 
    58  823b 0000                       !16 $0000 ;; starting addr 
    59  823d 04                         !8 $04   ;; of bank $5
    60  823e ff07                       !16 $07FF ;; destination address is $0801 - 2
    61  8240 00                         !8 $00   ;; of bank $0
    62  8241 0000                       !16 $0000 ;; modulo (unused)
    63                          
    64                          
    65                          	
    66                          launch_onboarding:
    67                          
    68                          	;; DMA copy the onboarding utility into place
    69  8243 a9ff                       lda #$ff
    70  8245 8d02d7                     sta $d702
    71                                  ;; lda #$ff
    72  8248 8d04d7                     sta $d704  ;; dma list is in top MB of address space
    73  824b a982                       lda #>onboarding_dmalist
    74  824d 8d01d7                     sta $d701
    75                                  ;; Trigger enhanced DMA
    76  8250 a932                       lda #<onboarding_dmalist
    77  8252 8d05d7                     sta $d705	
    78                          	
    79                          	;; Run util from in hypervisor context, similarly to how we run the flash menu
    80                          	;; this means the whole thing must be less than ~29KB in size, to not run over
    81                          	;; $8000-$BFFF where the hypervisor is mapped
    82  8255 4c81ac             	jmp run_util_in_hypervisor_context
    83                          	
    84                          syspart_open:
    85                                  ;; Open a system partition.
    86                                  ;; At this point, only syspart_start_sector and
    87                                  ;; syspart_size_in_sectors have been initialised.
    88                          
    89                                  ;; Read First sector of system partition
    90  8258 a203                       ldx #$03
    91  825a bdc0bb             spo1:   lda syspart_start_sector,x
    92  825d 9d81d6                     sta $d681,x
    93  8260 ca                         dex
    94  8261 10f7                       bpl spo1
    95                          
    96  8263 a901                       lda #syspart_error_readerror
    97  8265 8dfbbc                     sta syspart_error_code
    98  8268 20d89f                     jsr sd_readsector
    99  826b 907f                       bcc syspart_openerror
   100                          
   101                                  ;; Got First sector of system partition.
   102                          
   103                                  ;; Check magic string
   104  826d a942                       lda #syspart_error_badmagic
   105  826f 8dfbbc                     sta syspart_error_code
   106  8272 a20a                       ldx #10
   107  8274 bd00de             spo2:	lda $de00,x
   108  8277 dd3385                     cmp syspart_magic,x
   109  827a d070                       bne syspart_openerror
   110  827c ca                         dex
   111  827d 10f5                       bpl spo2
   112                          
   113  827f a900                       lda #$00
   114  8281 8dfbbc                     sta syspart_error_code
   115                          
   116                                  ;; Copy bytes from offset $10 - $2F into syspart_structure
   117                                  ;; XXX It is assumed that these fields are aligned with each other
   118  8284 a210                       ldx #$10
   119  8286 bd00de             spo3:	lda $de00,x
   120  8289 9dc0bb                     sta syspart_structure,x
   121  828c e8                         inx
   122  828d e030                       cpx #$30
   123  828f d0f5                       bne spo3
   124                          
   125                                  ;; Display info about # of freeze and service slots
   126  8291 a276                       ldx #<msg_syspart_info
   127  8293 a085                       ldy #>msg_syspart_info
   128  8295 20c8a8                     jsr printmessage
   129  8298 a000                       ldy #$00
   130  829a abddbb                     ldz syspart_freeze_slot_count+1
   131  829d 2041a9                     jsr printhex
   132  82a0 abdcbb                     ldz syspart_freeze_slot_count+0
   133  82a3 2041a9                     jsr printhex
   134  82a6 abedbb                     ldz syspart_service_slot_count+1
   135  82a9 2041a9                     jsr printhex
   136  82ac abecbb                     ldz syspart_service_slot_count+0
   137  82af 2041a9                     jsr printhex
   138                          
   139                                  ;; Show size of freeze slots
   140  82b2 abdbbb                     ldz syspart_freeze_slot_size_in_sectors+3 
   141  82b5 2041a9                     jsr printhex
   142  82b8 abdabb                     ldz syspart_freeze_slot_size_in_sectors+2
   143  82bb 2041a9                     jsr printhex
   144  82be abd9bb                     ldz syspart_freeze_slot_size_in_sectors+1
   145  82c1 2041a9                     jsr printhex
   146  82c4 abd8bb                     ldz syspart_freeze_slot_size_in_sectors+0
   147  82c7 2041a9                     jsr printhex
   148                          
   149  82ca a901                       lda #$01
   150  82cc 8dfcbc                     sta syspart_present
   151                          
   152  82cf a262                       ldx #<msg_syspart_ok
   153  82d1 a085                       ldy #>msg_syspart_ok
   154  82d3 20c8a8                     jsr printmessage
   155                          
   156  82d6 20f283                     jsr syspart_configsector_read
   157  82d9 ad0ede             	lda $de0e
   158  82dc 1021               	bpl do_launch_onboarding
   159                          no_onboarding:	
   160  82de 200284                     jsr syspart_configsector_apply
   161  82e1 b007                       bcs spo4
   162                          
   163  82e3 a29a                       ldx #<msg_syspart_config_invalid
   164  82e5 a085                       ldy #>msg_syspart_config_invalid
   165  82e7 20c8a8                     jsr printmessage
   166                          
   167  82ea 38                 spo4:	sec
   168  82eb 60                         rts
   169                          	
   170                          syspart_openerror:
   171                          
   172                                  ;; Report error opening system partition
   173  82ec a23e                       ldx #<msg_syspart_open_error
   174  82ee a085                       ldy #>msg_syspart_open_error
   175  82f0 20c8a8                     jsr printmessage
   176  82f3 a000                       ldy #$00
   177  82f5 abfbbc                     ldz syspart_error_code
   178  82f8 2041a9                     jsr printhex
   179  82fb a300                       ldz #$00
   180                          
   181  82fd 18                         clc
   182  82fe 60                         rts
   183                          
   184                          do_launch_onboarding:
   185                          	;; Only try onboarding on first boot
   186  82ff ad10a3             	lda first_boot_flag_instruction
   187  8302 c94c               	cmp #$4c
   188  8304 f0d8               	beq no_onboarding
   189  8306 4c4382             	jmp launch_onboarding
   190                          	
   191                                  ;; XXX These should return success/failure indication
   192                          syspart_configsector_read_trap:
   193  8309 20f283                     jsr syspart_configsector_read
   194  830c 8d7fd6                     sta hypervisor_enterexit_trigger
   195                          
   196                          syspart_configsector_write_trap:
   197  830f 20f883                     jsr syspart_configsector_write
   198  8312 8d7fd6                     sta hypervisor_enterexit_trigger
   199                          
   200                          syspart_configsector_set_trap:
   201  8315 20e583                     jsr syspart_configsector_set
   202  8318 8d7fd6                     sta hypervisor_enterexit_trigger
   203                          
   204                          syspart_configsector_apply_trap:
   205  831b 200284                     jsr syspart_configsector_apply
   206  831e 8d7fd6                     sta hypervisor_enterexit_trigger
   207                          
   208                          syspart_unfreeze_from_slot_trap:
   209  8321 ae41d6                     ldx hypervisor_x
   210  8324 205283                     jsr syspart_locate_freezeslot
   211  8327 206786                     jsr unfreeze_load_from_sdcard_immediate
   212                          	;;  Make sure we resume a frozen program on the same raster line as
   213                          	;; it entered the freezer.  This might need a bit of tuning to get
   214                          	;; perfect, but it should already be accurate to within one raster line.
   215                          
   216                          	
   217  832a a9ff               	lda #$ff
   218                          @unfreezesyncwait:
   219  832c cd12d0             	cmp $d012
   220  832f d0fb               	bne @unfreezesyncwait
   221                          	;; Clear any pending raster interrupt, to avoid problems.
   222  8331 ce19d0             	dec $d019 
   223  8334 8d7fd6                     sta hypervisor_enterexit_trigger
   224                          
   225                          syspart_get_slot_count_trap:
   226  8337 aedcbb                     ldx syspart_freeze_slot_count+0
   227  833a 8e41d6                     stx hypervisor_x
   228  833d acddbb                     ldy syspart_freeze_slot_count+1
   229  8340 8c42d6                     sty hypervisor_y
   230  8343 4c1082                     jmp return_from_trap_with_success
   231                          
   232                          syspart_locate_freezeslot_trap:
   233  8346 ae41d6                     ldx hypervisor_x
   234  8349 ac42d6                     ldy hypervisor_y
   235  834c 205283                     jsr syspart_locate_freezeslot
   236  834f 8d7fd6                     sta hypervisor_enterexit_trigger
   237                          
   238                          syspart_locate_freezeslot:
   239                                  ;; Get the first sector of a given freeze slot
   240                                  ;; X = low byte of slot #
   241                                  ;; Y = high byte of slot #
   242                          
   243  8352 da                         phx
   244  8353 5a                         phy
   245                          
   246                                  ;; Check that we have a system partition
   247  8354 adfcbc                     lda syspart_present
   248  8357 d007                       bne splf1
   249  8359 a9ff                       lda #syspart_error_nosyspart
   250  835b 8dfbbc                     sta syspart_error_code
   251  835e 18                         clc
   252  835f 60                         rts
   253                          splf1:
   254                                  ;; Check that freeze slot number is not invalid
   255  8360 ccddbb                     cpy syspart_freeze_slot_count+1
   256  8363 f002                       beq sc1
   257  8365 900e                       bcc slotnumok
   258  8367 ecdcbb             sc1:	cpx syspart_freeze_slot_count+0
   259  836a f002                       beq slotbad
   260  836c 9007                       bcc slotnumok
   261                          slotbad:
   262                                  ;; Report error status for out of bounds slot number
   263  836e a902                       lda #syspart_error_badslotnum
   264  8370 8dfbbc                     sta syspart_error_code
   265  8373 18                         clc
   266  8374 60                         rts
   267                          
   268                          slotnumok:
   269                          
   270  8375 20a783                     jsr syspart_locate_freezeslot_0
   271                                  ;; Now add freeze slot size x (YYXX) bytes
   272                                  ;; Use hardware multiplier to work out slot address
   273                          
   274                                  ;; Set multiplicant inputs to multiplier
   275                          
   276                                  ;; XXX - Works only with SD HC cards!
   277                          
   278                                  ;; SDHC, so unit is sectors, and so is just a case of copying the bytes
   279                                  ;; Start by shifting down by 1 byte = /256
   280  8378 a203                       ldx #$03
   281  837a bdd8bb             splf4b:	lda syspart_freeze_slot_size_in_sectors,x
   282  837d 9d70d7                     sta mult48_d0,x
   283  8380 ca                         dex
   284  8381 10f7                       bpl splf4b
   285                          
   286                          @multiplierSet:
   287                          
   288  8383 fa                         plx
   289  8384 8e74d7                     stx mult48_e0
   290  8387 7a                         ply
   291  8388 8c75d7                     sty mult48_e1
   292  838b a900                       lda #$00
   293  838d 8d76d7                     sta mult48_e2
   294  8390 8d77d7                     sta mult48_e3
   295                          
   296                                  ;; Read out answer, and add it to slot 0 address
   297  8393 a200                       ldx #0
   298  8395 a003                       ldy #3
   299  8397 18                         clc
   300  8398 bd78d7             splf3:	lda mult48_result0,x
   301  839b 7d81d6                     adc $d681,x
   302  839e 9d81d6                     sta $d681,x
   303  83a1 e8                         inx
   304  83a2 88                         dey
   305  83a3 10f3                       bpl splf3
   306                          
   307  83a5 38                         sec
   308  83a6 60                         rts
   309                          
   310                          syspart_locate_freezeslot_0:
   311                                  ;; Freeze slot #0 starts at:
   312                                  ;;   syspart_start_sector + syspart_freeze_area_start
   313                                  ;; + syspart_freeze_directory_sector_count
   314  83a7 adc0bb                     lda syspart_start_sector+0
   315  83aa 18                         clc
   316  83ab 6dd0bb                     adc syspart_freeze_area_start+0
   317  83ae 8d81d6                     sta $d681
   318  83b1 a201                       ldx #1
   319  83b3 bdc0bb             splf2:	lda syspart_start_sector,x
   320  83b6 7dd0bb                     adc syspart_freeze_area_start,x
   321  83b9 9d81d6                     sta $d681,x
   322  83bc e8                         inx
   323  83bd e004                       cpx #4
   324  83bf d0f2                       bne splf2
   325  83c1 ad81d6                     lda $d681
   326  83c4 18                         clc
   327  83c5 6ddebb                     adc syspart_freeze_directory_sector_count+0
   328  83c8 8d81d6                     sta $d681
   329  83cb ad82d6                     lda $d682
   330  83ce 6ddfbb                     adc syspart_freeze_directory_sector_count+1
   331  83d1 8d82d6                     sta $d682
   332  83d4 ad83d6                     lda $d683
   333  83d7 6900                       adc #0
   334  83d9 8d83d6                     sta $d683
   335  83dc ad84d6                     lda $d684
   336  83df 6900                       adc #0
   337  83e1 8d84d6                     sta $d684
   338                          
   339  83e4 60                         rts
   340                          
   341                          
   342                          syspart_configsector_set:
   343                          	;; So, the config sector USED to live in the system partition.
   344                          	;; But that causes a few problems:
   345                          	;; 1. You need a system partition, just to be able to pick PAL or NTSC on start.
   346                          	;; 2. The utility menu now, for good reason, appears before trying to probe any
   347                          	;;    SD cards. This means that the configure programme couldn't work out the
   348                          	;;    correct sector to work on.
   349                          	;; As a result, we now just officially have the config sector live in sector 1.
   350  83e5 a203                       ldx #3
   351  83e7 a900               	lda #0
   352                          spcr1:	;; lda syspart_start_sector,x
   353  83e9 9d81d6                     sta $d681,x
   354  83ec ca                         dex
   355  83ed 10fa                       bpl spcr1
   356  83ef 4c18a0                     jmp sd_inc_sectornumber
   357                          
   358                          syspart_configsector_read:
   359  83f2 20e583                     jsr syspart_configsector_set
   360  83f5 4cd89f                     jmp sd_readsector
   361                          
   362                          syspart_configsector_write:
   363  83f8 20e583                     jsr syspart_configsector_set
   364  83fb 20499f             	jsr write_non_mbr_sector
   365  83fe 38                         sec
   366  83ff 60                         rts
   367                          
   368                          syspart_config_invalid:
   369  8400 18                         clc
   370  8401 60                         rts
   371                          	
   372                          syspart_configsector_apply:
   373                                  ;; Check version
   374  8402 ad00de                     lda $de00
   375  8405 c901                       cmp #$01
   376  8407 d0f7                       bne syspart_config_invalid
   377  8409 ad01de                     lda $de01
   378  840c c901                       cmp #$01
   379  840e d0f0                       bne syspart_config_invalid
   380                          
   381                                  ;; Set DMAgic revision
   382  8410 ad20de                     lda $de20
   383  8413 8d03d7                     sta $d703
   384                          
   385                          	;; Set $D054 options
   386                          	;; (eg scanline emulation ($20) and horizontal blur filter ($08))
   387  8416 a928               	lda #$28
   388  8418 1c54d0             	trb $d054
   389  841b 2d21de             	and $de21
   390  841e 0c54d0             	tsb $d054
   391                          
   392                                  ;; Set PAL/NTSC mode (keeping $D058 value)
   393  8421 ae58d0                     ldx $d058
   394  8424 ad6fd0                     lda $d06f
   395  8427 293f                       and #$3f
   396  8429 8d6fd0                     sta $d06f
   397  842c ad02de                     lda $de02
   398  842f 29c0                       and #$c0
   399  8431 0d6fd0                     ora $d06f
   400  8434 8d6fd0                     sta $d06f
   401                          	;; And also write it into the instruction that sets the display mode on reset
   402  8437 8deca6             	sta pal_ntsc_minus_1+1
   403  843a 8e58d0                     stx $d058
   404                          	
   405                                  ;; Set audio and related options
   406  843d ad0dde             	lda $de0d
   407  8440 8d1ad6             	sta $d61a
   408                          
   409                          	;; Trigger onboarding menu or not
   410                          	;; (activated elsewhere)
   411                          	// $de0e bit 7
   412                          	
   413                          	;; Super SFX cartridge emulation
   414  8443 ad0cde             	lda $de0c
   415  8446 a300               	ldz #$00
   416  8448 a907               	lda #$07
   417  844a 8d13bf             	sta zptempv32+3
   418  844d a2fe               	ldx #$fe
   419  844f 8e12bf             	stx zptempv32+2
   420  8452 e8                 	inx
   421  8453 8e11bf             	stx zptempv32+1
   422  8456 8e10bf             	stx zptempv32+0
   423  8459 ea9210             	sta [<zptempv32],z	
   424                          
   425                          	;; Audio amplifier control
   426  845c ad03de                     lda $de03
   427  845f 2901                       and #$01
   428  8461 8dfed6                     sta audioamp_ctl
   429                          
   430                          	;; Stereo flags
   431  8464 ad03de                     lda $de03
   432  8467 2940                       and #$40
   433  8469 f006                       beq is_stereo
   434  846b 20dfa0                     jsr audio_set_mono
   435  846e 4c8184                     jmp done_audio
   436                          is_stereo:
   437  8471 ad03de                     lda $de03
   438  8474 2920                       and #$20
   439  8476 d006                       bne is_mirrored
   440  8478 205aa1                     jsr audio_set_stereo
   441  847b 4c8184                     jmp done_audio
   442                          is_mirrored:
   443  847e 2064a1                     jsr audio_set_stereomirrored
   444                          done_audio:
   445                          
   446                                  ;; Set F011 to use 3.5 drive or disk images
   447  8481 ad04de                     lda $de04
   448  8484 8da1d6                     sta sd_fdc_select
   449                          
   450                                  ;; Enable/disable Amiga mouse support (emulates 1351 mouse)
   451  8487 ad05de                     lda $de05
   452  848a 8d1bd6                     sta mouse_detect_ctrl
   453                          
   454                          	;; Enable/disable experimental long filename support
   455  848d a94c               	lda #$4c 		; Disable LFN support by default
   456  848f 8d9994             	sta disable_lfn_byte
   457  8492 ad0fde             	lda $de0f
   458  8495 1005               	bpl @nolfn
   459                          	;; Diable jump that disables LFN support 
   460  8497 a92c               	lda #$2c 		; BIT $xxxx opcode
   461  8499 8d9994             	sta disable_lfn_byte
   462                          @nolfn:
   463                                  ;; Copy MAC address
   464  849c a205                       ldx #$05
   465                          maccopy:
   466  849e bd06de                     lda $de06, x
   467  84a1 9de9d6                     sta mac_addr_0, x
   468  84a4 ca                         dex
   469  84a5 10f7                       bpl maccopy
   470                          
   471                                  ;; Copy default disk image name
   472  84a7 ad10de                     lda $de10
   473  84aa f00b                       beq nodiskname
   474  84ac a20f                       ldx #$0f
   475                          disknamecopy:
   476  84ae bd10de                     lda	$de10, x
   477  84b1 9dd7b2                     sta	txt_MEGA65D81, x
   478  84b4 ca                         dex
   479  84b5 10f7                       bpl	disknamecopy
   480                          nodiskname:
   481  84b7 38                         sec
   482  84b8 60                         rts
   483                          
   484                          syspart_dmagic_autoset_trap:
   485  84b9 20bf84                     jsr syspart_dmagic_autoset
   486  84bc 8d7fd6                     sta hypervisor_enterexit_trigger
   487                          
   488                          syspart_dmagic_autoset:
   489                                  ;; Set DMAgic revision based on ROM version
   490                                  ;; $20017-$2001D = "V9xxxxx" version string.
   491                                  ;; If it is 900000 - 910522, then DMAgic revA, else revB
   492  84bf a916                       lda #$16
   493  84c1 8d10bf                     sta zptempv32
   494  84c4 a900                       lda #$00
   495  84c6 8d11bf                     sta zptempv32+1
   496  84c9 8d13bf                     sta zptempv32+3
   497  84cc a902                       lda #$02
   498  84ce 8d12bf                     sta zptempv32+2
   499  84d1 a300                       ldz #$00
   500  84d3 eab210                     lda [<zptempv32],z
   501  84d6 c956                       cmp #$56
   502  84d8 f001                       beq @hasC65ROMVersion
   503  84da 60                         rts
   504                          @hasC65ROMVersion:
   505                                  ;; Check first digit is 9
   506  84db 1b                         inz
   507  84dc eab210                     lda [<zptempv32],z
   508  84df c939                       cmp #$39
   509  84e1 d034                       bne @useDMAgicRevB
   510                                  ;; check if second digit is 0, if so, revA
   511  84e3 1b                         inz
   512  84e4 eab210                     lda [<zptempv32],z
   513  84e7 c930                       cmp #$30
   514  84e9 f03a                       beq @useDMAgicRevA
   515                                  ;; check if second digit != 1, if so, revB
   516  84eb c931                       cmp #$31
   517  84ed d028                       bne @useDMAgicRevB
   518                                  ;; check 3rd digit is 0, if not, revB
   519  84ef 1b                         inz
   520  84f0 eab210                     lda [<zptempv32],z
   521  84f3 c930                       cmp #$30
   522  84f5 d020                       bne @useDMAgicRevB
   523                                  ;; check 4th digit is >5, if so, revB
   524  84f7 1b                         inz
   525  84f8 eab210                     lda [<zptempv32],z
   526  84fb c936                       cmp #$36
   527  84fd b018                       bcs @useDMAgicRevB
   528                                  ;; check 4th digit is <5, if so, revA
   529  84ff c935                       cmp #$35
   530  8501 9022                       bcc @useDMAgicRevA
   531                                  ;; check 5th digit <=> 2
   532  8503 1b                         inz
   533  8504 eab210                     lda [<zptempv32],z
   534  8507 c932                       cmp #$32
   535  8509 901a                       bcc @useDMAgicRevA
   536  850b c933                       cmp #$33
   537  850d b008                       bcs @useDMAgicRevB
   538                                  ;; check 6th digit <3
   539  850f 1b                         inz
   540  8510 eab210                     lda [<zptempv32],z
   541  8513 c933                       cmp #$33
   542  8515 900e                       bcc @useDMAgicRevA
   543                          @useDMAgicRevB:
   544  8517 a300                       ldz #$00
   545  8519 a901                       lda #$01
   546  851b 0c03d7                     tsb $d703
   547                          
   548  851e a280                       ldx #<msg_dmagicb
   549  8520 a0b2                       ldy #>msg_dmagicb
   550  8522 4cc8a8                     jmp printmessage
   551                          
   552                          @useDMAgicRevA:
   553  8525 a300                       ldz #$00
   554  8527 a901                       lda #$01
   555  8529 1c03d7                     trb $d703
   556                          
   557  852c a26e                       ldx #<msg_dmagica
   558  852e a0b2                       ldy #>msg_dmagica
   559  8530 4cc8a8                     jmp printmessage
   560                          
   561                          
   562                                  ;; Magic string that identifies a MEGA65 system partition
   563                          syspart_magic:
   564  8533 4d45474136355359...        !text "MEGA65SYS00"
   565                          msg_syspart_open_error:
   566  853e 53595354454d2050...        !text "SYSTEM PARTITION ERROR: (ERRNO: $$)"
   567  8561 00                         !8 0
   568                          msg_syspart_ok:
   569  8562 53595354454d2050...        !text "SYSTEM PARTITION OK"
   570  8575 00                         !8 0
   571                          msg_syspart_info:
   572  8576 5359533a20242424...        !text "SYS: $$$$ FRZ + $$$$ SVC X $$$$$$$$"
   573  8599 00                         !8 0
   574                          msg_syspart_config_invalid:
   575  859a 5359535041525420...        !text "SYSPART CONFIG INVALID. PLEASE SET."
   576  85bd 00                         !8 0
   577                          	
   578                          syspart_trap:
   579  85be 78                         sei
   580  85bf d8                         cld
   581  85c0 29fe                       and #$fe
   582  85c2 aa                         tax
   583  85c3 7cc685                     jmp (syspart_trap_table,x)
   584                          
   585                          syspart_trap_table:
   586                                  ;; $00-$0E
   587  85c6 0983                       !16 syspart_configsector_read_trap
   588  85c8 0f83                       !16 syspart_configsector_write_trap
   589  85ca 1b83                       !16 syspart_configsector_apply_trap
   590  85cc 1583                       !16 syspart_configsector_set_trap
   591  85ce b984                       !16 syspart_dmagic_autoset_trap
   592  85d0 2f82                       !16 invalid_subfunction
   593  85d2 2f82                       !16 invalid_subfunction
   594  85d4 2f82                       !16 invalid_subfunction
   595                          
   596                                  ;; $10-$1E
   597  85d6 4683                       !16 syspart_locate_freezeslot_trap
   598  85d8 2183                       !16 syspart_unfreeze_from_slot_trap
   599  85da b78a                       !16 syspart_read_freeze_region_list_trap
   600  85dc 3783                       !16 syspart_get_slot_count_trap
   601  85de 2f82                       !16 invalid_subfunction
   602  85e0 2f82                       !16 invalid_subfunction
   603  85e2 2f82                       !16 invalid_subfunction
   604  85e4 2f82                       !16 invalid_subfunction
   605                          
   606                                  ;; $20-$2E
   607  85e6 2f82                       !16 invalid_subfunction
   608  85e8 2f82                       !16 invalid_subfunction
   609  85ea 2f82                       !16 invalid_subfunction
   610  85ec 2f82                       !16 invalid_subfunction
   611  85ee 2f82                       !16 invalid_subfunction
   612  85f0 2f82                       !16 invalid_subfunction
   613  85f2 2f82                       !16 invalid_subfunction
   614  85f4 2f82                       !16 invalid_subfunction
   615                          
   616                                  ;; $30-$3E
   617  85f6 2f82                       !16 invalid_subfunction
   618  85f8 2f82                       !16 invalid_subfunction
   619  85fa 2f82                       !16 invalid_subfunction
   620  85fc 2f82                       !16 invalid_subfunction
   621  85fe 2f82                       !16 invalid_subfunction
   622  8600 2f82                       !16 invalid_subfunction
   623  8602 2f82                       !16 invalid_subfunction
   624  8604 2f82                       !16 invalid_subfunction
   625                          
   626                                  ;; $40-$4E
   627  8606 2f82                       !16 invalid_subfunction
   628  8608 2f82                       !16 invalid_subfunction
   629  860a 2f82                       !16 invalid_subfunction
   630  860c 2f82                       !16 invalid_subfunction
   631  860e 2f82                       !16 invalid_subfunction
   632  8610 2f82                       !16 invalid_subfunction
   633  8612 2f82                       !16 invalid_subfunction
   634  8614 2f82                       !16 invalid_subfunction
   635                          
   636                                  ;; $50-$5E
   637  8616 2f82                       !16 invalid_subfunction
   638  8618 2f82                       !16 invalid_subfunction
   639  861a 2f82                       !16 invalid_subfunction
   640  861c 2f82                       !16 invalid_subfunction
   641  861e 2f82                       !16 invalid_subfunction
   642  8620 2f82                       !16 invalid_subfunction
   643  8622 2f82                       !16 invalid_subfunction
   644  8624 2f82                       !16 invalid_subfunction
   645                          
   646                                  ;; $60-$6E
   647  8626 2f82                       !16 invalid_subfunction
   648  8628 2f82                       !16 invalid_subfunction
   649  862a 2f82                       !16 invalid_subfunction
   650  862c 2f82                       !16 invalid_subfunction
   651  862e 2f82                       !16 invalid_subfunction
   652  8630 2f82                       !16 invalid_subfunction
   653  8632 2f82                       !16 invalid_subfunction
   654  8634 2f82                       !16 invalid_subfunction
   655                          
   656                                  ;; $70-$7E
   657  8636 2f82                       !16 invalid_subfunction
   658  8638 2f82                       !16 invalid_subfunction
   659  863a 2f82                       !16 invalid_subfunction
   660  863c 2f82                       !16 invalid_subfunction
   661  863e 2f82                       !16 invalid_subfunction
   662  8640 2f82                       !16 invalid_subfunction
   663  8642 2f82                       !16 invalid_subfunction
   664  8644 2f82                       !16 invalid_subfunction

; ******** Source: src/hyppo/main.asm
   369                          	
   370                          
   371                          ;; /*  -------------------------------------------------------------------
   372                          ;;     Freeze/Unfreeze functions
   373                          ;;     ---------------------------------------------------------------- */

; ******** Source: freeze.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          freeze_to_slot:
     7                                  ;; Freeze current running process to the specified slot
     8                          
     9                                  ;; Slot in XXYY
    10                          
    11  8646 205283                     jsr syspart_locate_freezeslot
    12  8649 b001                       bcs freeze_save_to_sdcard_immediate
    13  864b 60                         rts
    14                          
    15                          freeze_save_to_sdcard_immediate:
    16                          
    17                                  ;; Save the current process to the SD card. $D681-4 are expected to
    18                                  ;; already be pointing to the first sector of the freeze slot
    19                          
    20                                  ;; Stash SD card registers to scratch area
    21                                  ;; (also stashed $D070 which gets mushed by palette saving)
    22  864c 20498a                     jsr copy_sdcard_regs_to_scratch
    23                          
    24                                  ;; Save current SD card sector buffer contents
    25  864f 200487                     jsr freeze_write_first_sector_and_wait
    26                          
    27                                  ;; Save each region in the list
    28  8652 a200                       ldx #$00
    29                          freeze_next_region:
    30  8654 207187                     jsr freeze_save_region
    31  8657 8a                         txa
    32  8658 18                         clc
    33  8659 6908                       adc #$08
    34  865b aa                         tax
    35  865c bdda8a                     lda freeze_mem_list+7,x
    36  865f c9ff                       cmp #$ff
    37  8661 d0f1                       bne freeze_next_region
    38                          
    39  8663 206087                     jsr freeze_end_multi_block_write
    40                          
    41  8666 60                         rts
    42                          
    43                          unfreeze_load_from_sdcard_immediate:
    44                          
    45                                  ;; Restore a frozen process from the SD card. $D681-4 are expecxted to
    46                                  ;; already be pointing to the first sector of the freeze slot
    47                          
    48                                  ;; Skip the first sector of the frozen program which is the
    49                                  ;; contents of the SD card sector buffer prior to freezing.
    50                                  ;; (We will load it in as the very last thing)
    51  8667 2018a0                     jsr sd_inc_sectornumber
    52                          
    53                                  ;; Save each region in the list
    54  866a a200                       ldx #$00
    55                          
    56                          unfreeze_next_region:
    57                          
    58                                  ;; Require SHIFT press and release between every sector for debug
    59                          ;;         jsr wait_on_shift_key
    60                          
    61                                  ;; Not sure why this delay is necessary, but it is.
    62                                  ;; Maybe restoring SD card IO registers causes it to go busy for a while?
    63  866c 20639f                     jsr sd_wait_for_ready_reset_if_required
    64                          
    65  866f 206788                     jsr unfreeze_load_region
    66                          
    67                                  ;; Re-enable M65 IO in case we wrote over the key register during the region unfreeze
    68  8672 a947                       lda #$47
    69  8674 8d2fd0                     sta $d02f
    70  8677 a953                       lda #$53
    71  8679 8d2fd0                     sta $d02f
    72                          
    73  867c 8a                         txa
    74  867d 18                         clc
    75  867e 6908                       adc #$08
    76  8680 aa                         tax
    77  8681 bdda8a                     lda freeze_mem_list+7,x
    78  8684 c9ff                       cmp #$ff
    79  8686 d0e4                       bne unfreeze_next_region
    80                          
    81                                  ;; Fix mounted D81, in case it has moved on the SD card since program was frozen
    82                          
    83                                  ;; 1. Detach
    84  8688 206a99                     jsr dos_d81detach
    85                          
    86                                  ;; 2. Copy filename for image 0
    87  868b ae13bd                     ldx currenttask_d81_image0_namelen
    88  868e f027                       beq noD81Image0ToRemount
    89  8690 a200                       ldx #0
    90  8692 bd15bd             copy:   lda currenttask_d81_image0_name,x
    91  8695 9d67bc                     sta dos_requested_filename,x
    92  8698 e8                         inx
    93  8699 ec13bd                     cpx currenttask_d81_image0_namelen
    94  869c d0f4                       bne copy
    95  869e a900                       lda #0
    96  86a0 9d67bc                     sta dos_requested_filename,x
    97  86a3 8e66bc                     stx dos_requested_filename_len
    98                          
    99                                  ;; 3. Remember write-enable flag
   100  86a6 ad11bd                     lda currenttask_d81_image0_flags
   101  86a9 2904                       and #d81_image_flag_write_en
   102  86ab 48                         pha
   103                          
   104                                  ;; 4. Try to reattach it
   105  86ac 207b99                     jsr dos_d81attach0
   106                          
   107                                  ;; 5. Mark write enabled if required
   108  86af 68                         pla
   109  86b0 c900                       cmp #$00
   110  86b2 f003                       beq noD81Image0ToRemount
   111                          
   112                                  ;; 6. Re-enable write access on the disk image
   113  86b4 20a38f                     jsr dos_d81write_en
   114                          
   115                          noD81Image0ToRemount:
   116                          
   117                                  ;; 2. Copy filename for image 0
   118  86b7 ae14bd                     ldx currenttask_d81_image1_namelen
   119  86ba f027                       beq noD81Image1ToRemount
   120  86bc a200                       ldx #0
   121  86be bd35bd             copy1:  lda currenttask_d81_image1_name,x
   122  86c1 9d67bc                     sta dos_requested_filename,x
   123  86c4 e8                         inx
   124  86c5 ec14bd                     cpx currenttask_d81_image1_namelen
   125  86c8 d0f4                       bne copy1
   126  86ca a900                       lda #0
   127  86cc 9d67bc                     sta dos_requested_filename,x
   128  86cf 8e66bc                     stx dos_requested_filename_len
   129                          
   130                                  ;; 3. Remember write-enable flag
   131  86d2 ad12bd                     lda currenttask_d81_image1_flags
   132  86d5 2904                       and #d81_image_flag_write_en
   133  86d7 48                         pha
   134                          
   135                                  ;; 4. Try to reattach it
   136  86d8 20e199                     jsr dos_d81attach1
   137                          
   138                                  ;; 5. Mark write enabled if required
   139  86db 68                         pla
   140  86dc c900                       cmp #$00
   141  86de f003                       beq noD81Image1ToRemount
   142                          
   143                                  ;; 6. Re-enable write access on the disk image
   144  86e0 20a38f                     jsr dos_d81write_en
   145                          
   146                          noD81Image1ToRemount:
   147                          	
   148                                  ;; Turn SID volume registers back on, as those registers
   149                                  ;; cannot be frozen.
   150  86e3 a90f                       lda #$0f
   151  86e5 8d18d4                     sta $D418
   152  86e8 8d38d4             	sta $D438
   153  86eb 8d58d4                     sta $D458
   154  86ee 8d78d4             	sta $D478
   155                          
   156  86f1 60                         rts
   157                          
   158                          unfreeze_read_sector_and_wait:
   159                          
   160                          
   161                          ;;         jsr debug_show_sector
   162                          
   163                          @retryRead:
   164  86f2 20639f                     jsr sd_wait_for_ready_reset_if_required
   165                          
   166  86f5 a902                       lda #$02
   167  86f7 8d80d6                     sta $d680
   168                          
   169  86fa 205a9f                     jsr sd_wait_for_ready
   170  86fd 90f3                       bcc @retryRead
   171                          
   172                                  ;; Read succeeded, so advance sector number, and return
   173                                  ;; success
   174                          
   175                                  ;; Increment freeze slot sector number
   176  86ff 2018a0                     jsr sd_inc_sectornumber
   177                          
   178  8702 38                         sec
   179                          
   180  8703 60                         rts
   181                          
   182                          freeze_write_first_sector_and_wait:
   183                          
   184  8704 ee20d0                     inc $d020
   185                          
   186                                  ;; Require SHIFT press and release between every sector for debug
   187                          ;;         jsr wait_on_shift_key
   188                          
   189  8707 a900                       lda #$00
   190  8709 8d6f87                     sta freeze_write_tries+0
   191  870c 8d7087                     sta freeze_write_tries+1
   192                          
   193                          @retryWrite1:
   194                          
   195  870f 20639f                     jsr sd_wait_for_ready_reset_if_required
   196                          
   197                                  ;; Trigger the write of the first sector of a multi-sector write
   198  8712 20439f             	jsr sd_open_write_gate
   199  8715 a904                       lda #$04
   200  8717 8d80d6                     sta $d680
   201                          
   202  871a 205a9f                     jsr sd_wait_for_ready
   203  871d 4c2a87                     jmp @wroteOk1
   204                          
   205  8720 ee6f87                     inc freeze_write_tries+0
   206  8723 d0ea                       bne @retryWrite1
   207  8725 ee7087                     inc freeze_write_tries+1
   208  8728 d0e5                       bne @retryWrite1
   209                          
   210                          @wroteOk1:
   211  872a ce20d0                     dec $d020
   212                          
   213                                  ;; Increment freeze slot sector number
   214  872d 2018a0                     jsr sd_inc_sectornumber
   215                          
   216  8730 38                         sec
   217  8731 60                         rts
   218                          
   219                          freeze_write_sector_and_wait:
   220                          
   221  8732 ee20d0                     inc $d020
   222                          
   223                                  ;; Require SHIFT press and release between every sector for debug
   224                          ;;         jsr wait_on_shift_key
   225                          
   226  8735 a900                       lda #$00
   227  8737 8d6f87                     sta freeze_write_tries+0
   228  873a 8d7087                     sta freeze_write_tries+1
   229                          
   230                          @retryWrite:
   231                          
   232  873d 20639f                     jsr sd_wait_for_ready_reset_if_required
   233                          
   234                                  ;; Trigger the write (subsequent sector of multi-sector write)
   235  8740 20439f             	jsr sd_open_write_gate
   236  8743 a905                       lda #$05
   237  8745 8d80d6                     sta $d680
   238                          
   239  8748 205a9f                     jsr sd_wait_for_ready
   240  874b 4c5887                     jmp @wroteOk
   241                          
   242  874e ee6f87                     inc freeze_write_tries+0
   243  8751 d0ea                       bne @retryWrite
   244  8753 ee7087                     inc freeze_write_tries+1
   245  8756 d0e5                       bne @retryWrite
   246                          
   247                          @wroteOk:
   248  8758 ce20d0                     dec $d020
   249                          
   250                                  ;; Increment freeze slot sector number
   251  875b 2018a0                     jsr sd_inc_sectornumber
   252                          
   253  875e 38                         sec
   254  875f 60                         rts
   255                          
   256                          freeze_end_multi_block_write:
   257  8760 205a9f                     jsr sd_wait_for_ready
   258  8763 20439f             	jsr sd_open_write_gate
   259  8766 a906                       lda #$06
   260  8768 8d80d6                     sta $d680
   261  876b 205a9f                     jsr sd_wait_for_ready
   262  876e 60                         rts
   263                          
   264                          freeze_write_tries:
   265  876f 0000                       !16 $0
   266                          
   267                          freeze_save_region:
   268                                  ;; X = offset into freeze_mem_list
   269                          
   270                                  ;; Check if end of list, if so, do nothing and return
   271  8771 bdda8a                     lda freeze_mem_list+7,x
   272  8774 c9ff                       cmp #$ff
   273  8776 d001                       bne fsr1
   274  8778 60                         rts
   275                          fsr1:
   276                          
   277                                  ;; Call setup routine to make any special preparations
   278                                  ;; (eg copying data out of non-memory mapped areas, or collecting
   279                                  ;; various groups of data together)
   280  8779 da                         phx
   281  877a aa                         tax
   282  877b 202789                     jsr dispatch_freeze_prep
   283  877e fa                         plx
   284                          
   285                                  ;; Get address of region
   286  877f bdd38a                     lda freeze_mem_list+0,x
   287  8782 8d7c8a                     sta freeze_region_dmalist_source_start+0
   288  8785 bdd48a                     lda freeze_mem_list+1,x
   289  8788 8d7d8a                     sta freeze_region_dmalist_source_start+1
   290                          
   291                                  ;; Source address is 32-bit, and we need bits 20-27
   292                                  ;; for the source MB (upper 4 bits are ignored)
   293  878b bdd58a                     lda freeze_mem_list+2,x
   294  878e 4a                         lsr
   295  878f 4a                         lsr
   296  8790 4a                         lsr
   297  8791 4a                         lsr
   298  8792 8d758a                     sta freeze_region_dmalist_source_mb
   299  8795 bdd68a                     lda freeze_mem_list+3,x
   300  8798 0a                         asl
   301  8799 0a                         asl
   302  879a 0a                         asl
   303  879b 0a                         asl
   304  879c 0d758a                     ora freeze_region_dmalist_source_mb
   305  879f 8d758a                     sta freeze_region_dmalist_source_mb
   306                          
   307                                  ;; Bank is a bit fiddly: Lower nybl is bits
   308                                  ;; 16-19 of address.  Then we have to add the IO flag
   309                                  ;; The IO flag is used if the source MB value = $FF.
   310                                  ;; However, because we use 28-bit addresses for everything
   311                                  ;; the IO bit should be zero, as should the other special
   312                                  ;; bits.
   313                          
   314  87a2 bdd58a                     lda freeze_mem_list+2,X
   315  87a5 290f                       and #$0f
   316  87a7 8d7e8a                     sta freeze_region_dmalist_source_bank
   317                          
   318                                  ;; At this point, we have the DMA list source setup.
   319                          
   320                                  ;; Point the destination to the SD card direct job
   321                                  ;; sector buffer ($FFD6E00).
   322  87aa a900                       lda #$00
   323  87ac 8d7f8a                     sta freeze_region_dmalist_dest_start+0
   324  87af a96e                       lda #$6E
   325  87b1 8d808a                     sta freeze_region_dmalist_dest_start+1
   326  87b4 a90d                       lda #$0D
   327  87b6 8d818a                     sta freeze_region_dmalist_dest_bank
   328  87b9 a9ff                       lda #$ff
   329  87bb 8d778a                     sta freeze_region_dmalist_dest_mb
   330                          
   331                                  ;; Now DMA source and destination addresses have been set
   332                                  ;; We now need to step through the region $200 bytes at a
   333                                  ;; time, until there are no bytes left.
   334                                  ;; If the length is $0000 initially, then it means 64KB.
   335                                  ;; The tricky bit is for regions <$200 bytes long, as we need
   336                                  ;; to make sure we don't copy more than we should (it could
   337                                  ;; be from Hypervisor memory, for example, or to some
   338                                  ;; important IO registers, such as the Hypervisor enter/exit
   339                                  ;; trap).
   340                          
   341                                  ;; Get length of region
   342  87be bdd78a                     lda freeze_mem_list+4,x
   343  87c1 8d6b8b                     sta freeze_dma_length_remaining+0
   344  87c4 bdd88a                     lda freeze_mem_list+5,x
   345  87c7 8d6c8b                     sta freeze_dma_length_remaining+1
   346  87ca bdd98a                     lda freeze_mem_list+6,x
   347  87cd 297f                       and #$7f                              ;; mask out bottom 7 bits, since bit 7 indicates if a region should be skipped in unfreezing
   348  87cf 8d6d8b                     sta freeze_dma_length_remaining+2
   349                          
   350                          freeze_region_dma_loop:
   351                          
   352  87d2 204588                     jsr set_dma_length_based_on_freeze_dma_length_remaining
   353                          
   354                                  ;; Then make sure that there are still bytes to copy.
   355                                  ;; If not, then we are done with this block.
   356  87d5 0d6b8b                     ora freeze_dma_length_remaining+0
   357  87d8 0d6d8b                     ora freeze_dma_length_remaining+2
   358  87db f03c                       beq freeze_region_dma_done
   359                          
   360                          @freezeExecuteDMA:
   361                          
   362                                  ;; Execute DMA job
   363  87dd a9ff                       lda #$ff
   364  87df 8d02d7                     sta $d702
   365  87e2 8d04d7                     sta $d704
   366  87e5 a98a                       lda #>freeze_region_dmalist
   367  87e7 8d01d7                     sta $d701
   368  87ea a973                       lda #<freeze_region_dmalist
   369  87ec 8d05d7                     sta $d705
   370                          
   371                                  ;; Write SD-card direct sector buffer to freeze slot
   372                                  ;; Flash a different colour while actually writing sector
   373  87ef ee20d0                     inc $d020
   374                          
   375  87f2 203287                     jsr freeze_write_sector_and_wait
   376                          
   377  87f5 ce20d0                     dec $d020
   378                          
   379                                  ;; Check if remaining length is negative or zero. If so, stop
   380  87f8 201a88                     jsr is_freeze_dma_length_remaining_zero_or_negative
   381  87fb f01c                       beq freeze_region_dma_done
   382                          
   383                                  ;; DMA count is set, subtract from remaining length
   384  87fd 202988                     jsr subtract_freeze_dma_size_from_length_remaining
   385                          
   386  8800 201a88                     jsr is_freeze_dma_length_remaining_zero_or_negative
   387  8803 f014                       beq freeze_region_dma_done
   388                          
   389                                  ;; advance source address
   390  8805 ad7d8a                     lda freeze_region_dmalist_source_start+1
   391  8808 18                         clc
   392  8809 6902                       adc #$02
   393  880b 8d7d8a                     sta freeze_region_dmalist_source_start+1
   394  880e ad7e8a                     lda freeze_region_dmalist_source_bank
   395  8811 6900                       adc #$00
   396  8813 8d7e8a                     sta freeze_region_dmalist_source_bank
   397                          
   398  8816 4cd287                     jmp freeze_region_dma_loop
   399                          
   400                          freeze_region_dma_done:
   401  8819 60                         rts
   402                          
   403                          is_freeze_dma_length_remaining_zero_or_negative:
   404  881a ad6d8b                     lda freeze_dma_length_remaining+2
   405  881d 3007                       bmi @negativeSize
   406  881f 0d6c8b                     ora freeze_dma_length_remaining+1
   407  8822 0d6b8b                     ora freeze_dma_length_remaining+0
   408  8825 60                         rts
   409                          @negativeSize:
   410  8826 a900                       lda #$00
   411  8828 60                         rts
   412                          
   413                          subtract_freeze_dma_size_from_length_remaining:
   414  8829 38                         sec
   415  882a ad6b8b                     lda freeze_dma_length_remaining+0
   416  882d ed7a8a                     sbc freeze_region_dmalist_count+0
   417  8830 8d6b8b                     sta freeze_dma_length_remaining+0
   418  8833 ad6c8b                     lda freeze_dma_length_remaining+1
   419  8836 ed7b8a                     sbc freeze_region_dmalist_count+1
   420  8839 8d6c8b                     sta freeze_dma_length_remaining+1
   421  883c ad6d8b                     lda freeze_dma_length_remaining+2
   422  883f e900                       sbc #$00
   423  8841 8d6d8b                     sta freeze_dma_length_remaining+2
   424  8844 60                         rts
   425                          
   426                          set_dma_length_based_on_freeze_dma_length_remaining:
   427  8845 ad6c8b                     lda freeze_dma_length_remaining+1
   428  8848 29fe                       and #$fe
   429  884a 0d6d8b                     ora freeze_dma_length_remaining+2
   430  884d f00b                       beq @isPartialSector
   431                          
   432                                  ;; At least a whole sector remains
   433  884f a900                       lda #$00
   434  8851 8d7a8a                     sta freeze_region_dmalist_count+0
   435  8854 a902                       lda #$02
   436  8856 8d7b8a                     sta freeze_region_dmalist_count+1
   437  8859 60                         rts
   438                          
   439                          @isPartialSector:
   440                                  ;; Set DMA size to remaining bytes
   441  885a ad6b8b                     lda freeze_dma_length_remaining+0
   442  885d 8d7a8a                     sta freeze_region_dmalist_count+0
   443  8860 ad6c8b                     lda freeze_dma_length_remaining+1
   444  8863 8d7b8a                     sta freeze_region_dmalist_count+1
   445  8866 60                         rts
   446                          
   447                          unfreeze_load_region:
   448                                  ;; X = offset into freeze_mem_list
   449                          
   450                                  ;; Check if end of list, if so, do nothing and return
   451  8867 bdda8a                     lda freeze_mem_list+7,x
   452  886a c9ff                       cmp #$ff
   453  886c f004                       beq @dontUnfreeze
   454                                  ;; If it is the thumbnail, also don't unfreeze, as it doesn't make sense,
   455                                  ;; and the way we freeze the thumbnail means unfreezing would corrupt $1000-$1FFF
   456  886e c50c                       cmp freeze_prep_thumbnail
   457  8870 d001                       bne @doUnfreeze
   458                          @dontUnfreeze:
   459  8872 60                         rts
   460                          @doUnfreeze:
   461                          
   462                                  ;; Call setup routine to make any special preparations
   463                                  ;; (eg copying data out of non-memory mapped areas, or collecting
   464                                  ;; various groups of data together)
   465  8873 da                         phx
   466  8874 aa                         tax
   467  8875 202a89                     jsr dispatch_unfreeze_prep
   468  8878 fa                         plx
   469                          
   470                                  ;; Get address of region
   471  8879 bdd38a                     lda freeze_mem_list+0,x
   472  887c 8d7f8a                     sta freeze_region_dmalist_dest_start+0
   473  887f bdd48a                     lda freeze_mem_list+1,x
   474  8882 8d808a                     sta freeze_region_dmalist_dest_start+1
   475                          
   476                                  ;; Source address is 32-bit, and we need bits 20-27
   477                                  ;; for the source MB (upper 4 bits are ignored)
   478  8885 bdd58a                     lda freeze_mem_list+2,x
   479  8888 4a                         lsr
   480  8889 4a                         lsr
   481  888a 4a                         lsr
   482  888b 4a                         lsr
   483  888c 8d778a                     sta freeze_region_dmalist_dest_mb
   484  888f bdd68a                     lda freeze_mem_list+3,x
   485  8892 0a                         asl
   486  8893 0a                         asl
   487  8894 0a                         asl
   488  8895 0a                         asl
   489  8896 0d778a                     ora freeze_region_dmalist_dest_mb
   490  8899 8d778a                     sta freeze_region_dmalist_dest_mb
   491                          
   492                                  ;; Bank is a bit fiddly: Lower nybl is bits
   493                                  ;; 16-19 of address.  Then we have to add the IO flag
   494                                  ;; The IO flag is used if the source MB value = $FF.
   495                                  ;; However, because we use 28-bit addresses for everything
   496                                  ;; the IO bit should be zero, as should the other special
   497                                  ;; bits.
   498                          
   499  889c bdd58a                     lda freeze_mem_list+2,X
   500  889f 290f                       and #$0f
   501  88a1 8d818a                     sta freeze_region_dmalist_dest_bank
   502                          
   503                                  ;; At this point, we have the DMA list source setup.
   504                          
   505                                  ;; Point the source to the SD card direct job
   506                                  ;; sector buffer ($FFD6E00).
   507  88a4 a900                       lda #$00
   508  88a6 8d7c8a                     sta freeze_region_dmalist_source_start+0
   509  88a9 a96e                       lda #$6E
   510  88ab 8d7d8a                     sta freeze_region_dmalist_source_start+1
   511  88ae a90d                       lda #$0D
   512  88b0 8d7e8a                     sta freeze_region_dmalist_source_bank
   513  88b3 a9ff                       lda #$ff
   514  88b5 8d758a                     sta freeze_region_dmalist_source_mb
   515                          
   516                                  ;; Now DMA source and destination addresses have been set
   517                                  ;; We now need to step through the region $200 bytes at a
   518                                  ;; time, until there are no bytes left.
   519                                  ;; If the length is $0000 initially, then it means 64KB.
   520                                  ;; The tricky bit is for regions <$200 bytes long, as we need
   521                                  ;; to make sure we don't copy more than we should (it could
   522                                  ;; be from Hypervisor memory, for example, or to some
   523                                  ;; important IO registers, such as the Hypervisor enter/exit
   524                                  ;; trap).
   525                          
   526                                  ;; Get length of region
   527  88b8 bdd78a                     lda freeze_mem_list+4,x
   528  88bb 8d6b8b                     sta freeze_dma_length_remaining+0
   529  88be bdd88a                     lda freeze_mem_list+5,x
   530  88c1 8d6c8b                     sta freeze_dma_length_remaining+1
   531  88c4 bdd98a                     lda freeze_mem_list+6,x
   532  88c7 8d6e8b                     sta unfreeze_skip
   533  88ca 297f                       and #$7f                              ;; mask out bottom 7 bits, since bit 7 indicates if a region should be skipped in unfreezing
   534  88cc 8d6d8b                     sta freeze_dma_length_remaining+2
   535                          
   536                          unfreeze_region_dma_loop:
   537                          
   538                                  ;; Write SD-card direct sector buffer to freeze slot
   539                                  ;; Flash a different colour while actually writing sector
   540  88cf ee20d0                     inc $d020
   541                          
   542  88d2 20f286                     jsr unfreeze_read_sector_and_wait
   543                          
   544  88d5 ce20d0                     dec $d020
   545                          
   546  88d8 204588                     jsr set_dma_length_based_on_freeze_dma_length_remaining
   547                          
   548                                  ;; Then make sure that there are still bytes to copy.
   549                                  ;; If not, then we are done with this block.
   550  88db 0d6b8b                     ora freeze_dma_length_remaining+0
   551  88de 0d6d8b                     ora freeze_dma_length_remaining+2
   552  88e1 f038                       beq unfreeze_region_dma_done
   553                          
   554  88e3 2c6e8b                     bit unfreeze_skip
   555  88e6 3012                       bmi @skipDMA
   556                          
   557                          @unfreezeExecuteDMA:
   558                                  ;; Execute DMA job
   559  88e8 a9ff                       lda #$ff
   560  88ea 8d02d7                     sta $d702
   561  88ed 8d04d7                     sta $d704
   562  88f0 a98a                       lda #>freeze_region_dmalist
   563  88f2 8d01d7                     sta $d701
   564  88f5 a973                       lda #<freeze_region_dmalist
   565  88f7 8d05d7                     sta $d705
   566                          
   567                          @skipDMA:
   568                                  ;; Check if remaining length is negative or zero. If so, stop
   569  88fa 201a88                     jsr is_freeze_dma_length_remaining_zero_or_negative
   570  88fd f01c                       beq unfreeze_region_dma_done
   571                          
   572                                  ;; DMA count is set, subtract from remaining length
   573  88ff 202988                     jsr subtract_freeze_dma_size_from_length_remaining
   574                          
   575  8902 201a88                     jsr is_freeze_dma_length_remaining_zero_or_negative
   576  8905 f014                       beq unfreeze_region_dma_done
   577                          
   578                                  ;; advance destination address
   579  8907 ad808a                     lda freeze_region_dmalist_dest_start+1
   580  890a 18                         clc
   581  890b 6902                       adc #$02
   582  890d 8d808a                     sta freeze_region_dmalist_dest_start+1
   583  8910 ad818a                     lda freeze_region_dmalist_dest_bank
   584  8913 6900                       adc #$00
   585  8915 8d818a                     sta freeze_region_dmalist_dest_bank
   586                          
   587  8918 4ccf88                     jmp unfreeze_region_dma_loop
   588                          
   589                          unfreeze_region_dma_done:
   590                          
   591                                  ;; Call postfix routine for the region just loaded
   592  891b da                         phx
   593  891c 48                 	pha
   594                          	
   595  891d bdda8a                     lda freeze_mem_list+7,x
   596  8920 aa                         tax
   597  8921 202d89                     jsr dispatch_unfreeze_post
   598                          
   599  8924 68                 	pla
   600  8925 fa                         plx
   601                          	
   602                          
   603  8926 60                         rts
   604                          
   605                          
   606                          dispatch_freeze_prep:
   607                                  ;; X = Freeze prep ID byte
   608                                  ;; (all of which are even, so that we can use an indirect
   609                                  ;; X indexed jump table to efficiently do the dispatch)
   610                          
   611  8927 7cfa89                     jmp (freeze_prep_jump_table,x)
   612                          
   613                          dispatch_unfreeze_prep:
   614                                  ;; X = Freeze prep ID byte
   615                                  ;; (all of which are even, so that we can use an indirect
   616                                  ;; X indexed jump table to efficiently do the dispatch)
   617                          
   618  892a 7c0a8a                     jmp (unfreeze_prep_jump_table,x)
   619                          
   620                          dispatch_unfreeze_post:
   621                                  ;; X = Freeze prep ID byte
   622                                  ;; (all of which are even, so that we can use an indirect
   623                                  ;; X indexed jump table to efficiently do the dispatch)
   624                          
   625  892d 7c1c8a                     jmp (unfreeze_post_jump_table,x)
   626                          
   627                          do_unfreeze_post_restore_sd_buffer_and_regs:
   628                                  ;; Copy back the registers from $D680 - $D70F *excluding*
   629                                  ;; $D700 and $D705 (which would trigger a DMA)
   630                                  ;; $D680 (which could trigger an SD read or write)
   631                          
   632                                  ;; The data should have been put for us at $FFD6200-$FFD628F
   633                                  ;; The contents of the SD sector buffer for restoration should
   634                                  ;; be at $FFD6000-$FFD61FF
   635                          
   636  8930 a900                       lda #<$6200
   637  8932 8500                       sta <dos_scratch_vector+0
   638  8934 a962                       lda #>$6200
   639  8936 8501                       sta <dos_scratch_vector+1
   640  8938 a9fd                       lda #<$0FFD
   641  893a 8502                       sta <dos_scratch_vector+2
   642  893c a90f                       lda #>$0FFD
   643  893e 8503                       sta <dos_scratch_vector+3
   644                          
   645                                  ;; Copy $D680 - $D70F, which covers both regions of interest
   646  8940 a38f                       ldz #$8F
   647  8942 6b                 @zz2:   tza
   648  8943 aa                         tax
   649  8944 eab200                     lda [<dos_scratch_vector],z
   650  8947 e000                       cpx #$00  ;; $D680
   651  8949 f00b                       beq @dontWriteHotRegister
   652  894b e080                       cpx #$80  ;; $D700
   653  894d f007                       beq @dontWriteHotRegister
   654  894f e085                       cpx #$85  ;; $D705
   655  8951 f003                       beq @dontWriteHotRegister
   656                          
   657  8953 9d80d6                     sta $d680,x
   658                          
   659                          @dontWriteHotRegister:
   660  8956 ca                         dex
   661  8957 3b                         dez
   662  8958 c2ff                       cpz #$ff
   663  895a d0e6                       bne @zz2
   664  895c a300                       ldz #$00
   665                          
   666                          do_unfreeze_prep_restore_sd_buffer_and_regs:
   667                                  ;; But there is nothing we need to do in preparation to unfreezing
   668                                  ;; such a region, so just tie it to an RTS
   669  895e 60                         rts
   670                          
   671                          do_freeze_prep_thumbnail:
   672                                  ;; Read the 4KB hardware thumbnail from $D640 and write it to $1000-$1FFF
   673                                  ;; We can in principle use a fixed-source DMA to do this.
   674                          
   675                                  ;; set up our pointer for writing
   676  895f a900                       lda #<$1000
   677  8961 8500                       sta <dos_scratch_vector+0
   678  8963 a910                       lda #>$1000
   679  8965 8501                       sta <dos_scratch_vector+1
   680  8967 a000                       ldy #$00
   681  8969 a210                       ldx #$10
   682                          
   683                                  ;; Set pointer to $FFD2640 to access thumbnail generator.
   684                                  ;; This is because the thumbnail generator lives at $D640 which overlaps
   685                                  ;; with the hypervisor trap registers when in hypervisor mode.
   686                                  ;; We previously had the thumbnail generator mapped at $D63x, but that
   687                                  ;; was causing CS glitching that was messing up reading from the C65 UART
   688                                  ;; registers.  So now we have moved it to this magic space
   689  896b a940                       lda #<$2640
   690  896d 8d10bf                     sta zptempv32+0
   691  8970 a926                       lda #>$2640
   692  8972 8d11bf                     sta zptempv32+1
   693  8975 a9fd                       lda #<$0FFD
   694  8977 8d12bf                     sta zptempv32+2
   695  897a a90f                       lda #>$0FFD
   696  897c 8d13bf                     sta zptempv32+3
   697                          
   698                                  ;; First, make sure the read pointer is at the start of the thumbnail
   699  897f a300                       ldz #$00
   700                                  ;; Then advance pointer address to $D641
   701  8981 eab210                     lda [<zptempv32],z
   702  8984 a941                       lda #<$2641
   703  8986 8d10bf                     sta zptempv32+0
   704                          
   705                          @thumbfetchloop:
   706  8989 eab210                     lda [<zptempv32],z
   707  898c 9100                       sta (<dos_scratch_vector),y
   708  898e c8                         iny
   709  898f d0f8                       bne @thumbfetchloop
   710  8991 e601                       inc <dos_scratch_vector+1
   711  8993 ca                         dex
   712  8994 d0f3                       bne @thumbfetchloop
   713                          
   714  8996 60                         rts
   715                          
   716                          do_freeze_prep_stash_sd_buffer_and_regs:
   717                                  ;; Stash the SD and DMAgic registers we use to actually save
   718                                  ;; the machine state.
   719                                  ;; DMAgic registers have to get copied without using DMA, so
   720                                  ;; that we don't corrupt the registers.
   721  8997 a900                       lda #<$6200
   722  8999 8500                       sta <dos_scratch_vector+0
   723  899b a962                       lda #>$6200
   724  899d 8501                       sta <dos_scratch_vector+1
   725  899f a9fd                       lda #<$0ffd
   726  89a1 8502                       sta <dos_scratch_vector+2
   727  89a3 a90f                       lda #>$0ffd
   728  89a5 8503                       sta <dos_scratch_vector+3
   729                          
   730                                  ;; Copy $D680 - $D70F, which covers both regions of interest
   731  89a7 a38f                       ldz #$8f
   732  89a9 6b                 @zz:    tza
   733  89aa aa                         tax
   734  89ab bd80d6                     lda $d680,x
   735  89ae ea9200                     sta [<dos_scratch_vector],z
   736  89b1 ca                         dex
   737  89b2 3b                         dez
   738  89b3 c2ff                       cpz #$ff
   739  89b5 d0f2                       bne @zz
   740  89b7 a300                       ldz #$00
   741                          
   742                                  ;; Now DMA copy the SD sector buffer from $FFD6e00 to
   743                                  ;; $FFD6000.
   744                                  ;; XXX Replace this (And the above!) with a fixed DMA list. It will be shorter and faster
   745  89b9 a9ff                       lda #$ff
   746  89bb 8d758a                     sta freeze_region_dmalist_source_mb
   747  89be 8d778a                     sta freeze_region_dmalist_dest_mb
   748  89c1 a98d                       lda #$8d
   749  89c3 8d7e8a                     sta freeze_region_dmalist_source_bank
   750  89c6 8d818a                     sta freeze_region_dmalist_dest_bank
   751  89c9 a900                       lda #<$6e00
   752  89cb 8d7c8a                     sta freeze_region_dmalist_source_start+0
   753  89ce a96e                       lda #>$6e00
   754  89d0 8d7d8a                     sta freeze_region_dmalist_source_start+1
   755  89d3 a900                       lda #<$6000
   756  89d5 8d7f8a                     sta freeze_region_dmalist_dest_start+0
   757  89d8 a960                       lda #>$6000
   758  89da 8d808a                     sta freeze_region_dmalist_dest_start+1
   759  89dd a900                       lda #<$0200
   760  89df 8d7a8a                     sta freeze_region_dmalist_count+0
   761  89e2 a902                       lda #>$0200
   762  89e4 8d7b8a                     sta freeze_region_dmalist_count+1
   763                          
   764                                  ;; Execute DMA job
   765  89e7 a9ff                       lda #$ff
   766  89e9 8d02d7                     sta $d702
   767  89ec 8d04d7                     sta $d704
   768  89ef a98a                       lda #>freeze_region_dmalist
   769  89f1 8d01d7                     sta $d701
   770  89f4 a973                       lda #<freeze_region_dmalist
   771  89f6 8d05d7                     sta $d705
   772                          
   773                          do_freeze_prep_none:
   774  89f9 60                         rts
   775                          
   776                          ;; Jump table of routines to be called before saving specific regions
   777                          freeze_prep_jump_table:
   778  89fa f989                       !16 do_freeze_prep_none
   779  89fc 848a                       !16 do_freeze_prep_palette_select
   780  89fe 848a                       !16 do_freeze_prep_palette_select
   781  8a00 848a                       !16 do_freeze_prep_palette_select
   782  8a02 848a                       !16 do_freeze_prep_palette_select
   783  8a04 9789                       !16 do_freeze_prep_stash_sd_buffer_and_regs
   784  8a06 5f89                       !16 do_freeze_prep_thumbnail
   785  8a08 6c8a                       !16 do_freeze_prep_viciv
   786                          
   787                          ;; Jump table of routines to be called before restoring specific regions
   788                          ;; (the same region list is used for freeze and unfreeze, so the jump
   789                          ;; tables for unfreezing mirror those used during freezing. The only difference
   790                          ;; is we require two sets of jump tables for unfreezing, as sometimes we have
   791                          ;; to prepare the memory map before restoring, and sometimes we have to move
   792                          ;; the restored data to the correct place in memory after restoration.
   793                          unfreeze_prep_jump_table:
   794                                  ;; SD card buffer and regs get restored in post routine
   795  8a0a 2e8a                       !16 do_unfreeze_prep_none
   796  8a0c 848a                       !16 do_unfreeze_prep_palette_select
   797  8a0e 848a                       !16 do_unfreeze_prep_palette_select
   798  8a10 848a                       !16 do_unfreeze_prep_palette_select
   799  8a12 848a                       !16 do_unfreeze_prep_palette_select
   800                                  ;; SD card buffer and regs get restored in post routine
   801  8a14 2e8a                       !16 do_unfreeze_prep_none
   802                                  ;; thumbnail doesn't get restored at all
   803  8a16 2e8a                       !16 do_unfreeze_prep_none
   804                                  ;; VIC-IV regs need nothing special before unfreezing
   805  8a18 2e8a                       !16 do_unfreeze_prep_none
   806                          	;; No prior preparation required for handling hyperregs
   807  8a1a 2e8a               	!16 do_unfreeze_prep_none
   808                          
   809                          unfreeze_post_jump_table:
   810  8a1c 2f8a                       !16 do_unfreeze_post_scratch_to_sdcard_regs
   811  8a1e 2e8a                       !16 do_unfreeze_post_none
   812  8a20 2e8a                       !16 do_unfreeze_post_none
   813  8a22 2e8a                       !16 do_unfreeze_post_none
   814  8a24 2e8a                       !16 do_unfreeze_post_none
   815                                  ;; Don't actually restore the SD card registers until the very end.
   816                                  ;; For a start, it will result in totally the wrong SD sector address being there
   817                                  ;; when we go to read the next sector!
   818                          ;;         !16 do_unfreeze_post_restore_sd_buffer_and_regs
   819  8a26 2e8a                       !16 do_unfreeze_post_none
   820  8a28 2e8a                       !16 do_unfreeze_post_none
   821  8a2a 2e8a                       !16 do_unfreeze_post_none
   822                          	;; No prior preparation required for handling hyperregs
   823  8a2c 308a               	!16 do_unfreeze_post_hyperregs
   824                          
   825                          do_unfreeze_prep_none:
   826                          do_unfreeze_post_none:
   827                                  ;; This just needs to have an RTS, so we use one from the end of this
   828                                  ;; routine.
   829  8a2e 60                         rts
   830                          
   831                          do_unfreeze_post_scratch_to_sdcard_regs:
   832                                  ;; XXX - Not implemented
   833  8a2f 60                         rts
   834                          
   835                          do_unfreeze_post_hyperregs:	
   836                          	;; XXX For reasons unknown, the DMA restoration of the hypervisor registers
   837                          	;; messes up $D651.
   838                          	;; At the point that this fix-up routine is called, the SD card sector
   839                          	;; containing the data is available, and so we can simply fix the problem
   840                          	;; by copying $ffd6e11 to $ffd3651
   841                          	;; If problems later occur for other regs in this range, we can just
   842                          	;; make a 32-bit ZP indirect copy loop, since there is some claim that
   843                          	;; DMA writing to those registers is problematic.
   844                          
   845                                  ;; that we don't corrupt the registers.
   846  8a30 a911                       lda #<$6e11
   847  8a32 8500                       sta <dos_scratch_vector+0
   848  8a34 a96e                       lda #>$6e11
   849  8a36 8501                       sta <dos_scratch_vector+1
   850  8a38 a9fd                       lda #<$0ffd
   851  8a3a 8502                       sta <dos_scratch_vector+2
   852  8a3c a90f                       lda #>$0ffd
   853  8a3e 8503                       sta <dos_scratch_vector+3
   854                          
   855  8a40 a300                       ldz #$00
   856  8a42 eab200                     lda [<dos_scratch_vector],z
   857  8a45 8d51d6             	sta $d651
   858                          
   859  8a48 60                 	rts
   860                          
   861                          
   862                          	
   863                          	
   864                          copy_sdcard_regs_to_scratch:
   865                                  ;; Copy the main SD card access registers to a
   866                                  ;; scratch area, so that we can save them, and thus restore
   867                                  ;; them after unfreezing.
   868                                  ;; (This is done outside of the automatic loop, because
   869                                  ;; it has to be handled specially.)
   870  8a49 a20f                       ldx #$0f
   871  8a4b bd80d6             dfp1:   lda $d680,x
   872  8a4e 9d5b8a                     sta freeze_scratch_area,x
   873  8a51 ca                         dex
   874  8a52 10f7                       bpl dfp1
   875                                  ;; Also save $D070 (palette select register)
   876                                  ;; since it gets stomped while saving palettes
   877  8a54 ad70d0                     lda $d070
   878  8a57 8d6b8a                     sta freeze_d070
   879  8a5a 60                         rts
   880                          
   881                          freeze_scratch_area:
   882  8a5b 0000000000000000...        !8 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   883                          freeze_d070:
   884  8a6b 00                         !8 0
   885                          
   886                          do_freeze_prep_viciv:
   887                                  ;; Restore saved $D070 value to fix that $D070 will have been
   888                                  ;; stomped over by the palette saving routines
   889  8a6c ad6b8a                     lda freeze_d070
   890  8a6f 8d70d0                     sta $d070
   891  8a72 60                         rts
   892                          
   893                          freeze_region_dmalist:
   894  8a73 0a                         !8 $0A ;; F011A format DMA list
   895  8a74 80                         !8 $80 ;; Source MB option follows
   896                          freeze_region_dmalist_source_mb:
   897  8a75 00                         !8 $00
   898  8a76 81                         !8 $81 ;; Dest MB option follows
   899                          freeze_region_dmalist_dest_mb:
   900  8a77 00                         !8 $00
   901  8a78 00                         !8 $00 ;; end of enhanced DMA option list
   902                          
   903                                  ;; F011A format DMA list
   904  8a79 00                         !8 $00 ;; copy + last request in chain
   905                          freeze_region_dmalist_count:
   906  8a7a 0000                       !16 $0000 ;; size of copy
   907                          freeze_region_dmalist_source_start:
   908  8a7c 0000                       !16 $0000 ;; source address lower 16 bits
   909                          freeze_region_dmalist_source_bank:
   910  8a7e 00                         !8 $00   ;;
   911                          freeze_region_dmalist_dest_start:
   912  8a7f 0000                       !16 $0000
   913                          freeze_region_dmalist_dest_bank:
   914  8a81 00                         !8 $00
   915  8a82 0000                       !16 $0000 ;; modulo (unused)
   916                          
   917                          do_unfreeze_prep_palette_select:
   918                                  ;; We do the same memory map setup during freeze and unfreeze
   919                          do_freeze_prep_palette_select:
   920                                  ;; X = 6, 8, 10 or 12
   921                                  ;; Use this to pick which of the four palette banks
   922                                  ;; is visible at $D100-$D3FF
   923  8a84 8a                         txa
   924  8a85 18                         clc
   925  8a86 e902                       sbc #freeze_prep_palette0
   926  8a88 0a                         asl
   927  8a89 0a                         asl
   928  8a8a 0a                         asl
   929  8a8b 0a                         asl
   930  8a8c 0a                         asl
   931  8a8d 093f                       ora #$3f  ;; keep displaying the default palette
   932  8a8f 8d70d0                     sta $d070
   933  8a92 60                         rts
   934                          
   935                          wait_on_shift_key:
   936  8a93 ad11d6                     lda $d611
   937  8a96 f0fb                       beq wait_on_shift_key
   938  8a98 ad11d6             -       lda $d611
   939  8a9b d0fb                       bne -
   940  8a9d 60                         rts
   941                          
   942                          debug_show_sector:
   943                                  ;; XXX DEBUG
   944  8a9e ad81d6                     lda $d681
   945  8aa1 8d0008                     sta $0800
   946  8aa4 ad82d6                     lda $d682
   947  8aa7 8d0108                     sta $0801
   948  8aaa ad83d6                     lda $d683
   949  8aad 8d0208                     sta $0802
   950  8ab0 ad84d6                     lda $d684
   951  8ab3 8d0308                     sta $0803
   952  8ab6 60                         rts
   953                          
   954                          syspart_read_freeze_region_list_trap:
   955                                  ;; Copy freeze_mem_list out to user memory
   956  8ab7 ae41d6                     ldx hypervisor_x
   957  8aba 8600                       stx <dos_scratch_vector+0
   958  8abc ad42d6                     lda hypervisor_y
   959  8abf 297f                       and #$7f ;; don't allow writing over hypervisor or IO when copying it out
   960  8ac1 8501                       sta <dos_scratch_vector+1
   961  8ac3 a298                       ldx #freeze_mem_list_end-freeze_mem_list
   962  8ac5 a000                       ldy #$00
   963  8ac7 b9d38a             -       lda freeze_mem_list,y
   964  8aca 9100                       sta (<dos_scratch_vector),y
   965  8acc c8                         iny
   966  8acd ca                         dex
   967  8ace d0f7                       bne -
   968  8ad0 4c1082                     jmp return_from_trap_with_success
   969                          
   970                          freeze_mem_list:
   971                          	;; XXX - There must not be more than 32 of these, as the region list
   972                          	;; has to fit within a single page.
   973                          	
   974                                  ;; start address (4 bytes), length (3 bytes),
   975                                  ;; preparatory action required before reading/writing (1 byte)
   976                                  ;; Each segment will live in its own sector (or sectors if
   977                                  ;; >512 bytes) when frozen. So we should avoid excessive
   978                                  ;; numbers of blocks.
   979                          
   980                                  ;; core SDcard registers we need to be ready to start writing
   981                                  ;; sectors. We copy these out and in manually at the start
   982                                  ;; and end of the freeze and unfreeze routines, respectively.
   983                                  ;; So they are not done here.
   984                                  ;; (the +$FFF0000 is to rebase the pointer into the hypervisor memory area)
   985  8ad3 5b8aff0f                   !32 freeze_scratch_area+$fff0000
   986  8ad7 1000                       !16 $0010
   987  8ad9 00                         !8 0
   988  8ada 00                         !8 freeze_prep_none
   989                          
   990                                  ;; SDcard sector buffer + SD card registers
   991                                  ;; We have to save this before anything much else, because
   992                                  ;; we need it for freezing.  We stash $FFD6E00-FFF and
   993                                  ;; $FFD3680-70F at $FFD6000 before hand, so that we preserve
   994                                  ;; these registers before touching them.
   995                                  ;; (the DMAgic registers at $DDF370x have to get copied manually,
   996                                  ;; so that we don't mess up the DMA state.  Also, when restoring
   997                                  ;; we have to take some care putting them back exactly.)
   998                          
   999  8adb 0060fd0f                   !32 $ffd6000
  1000  8adf 9000                       !16 $0090
  1001  8ae1 00                         !8 0
  1002  8ae2 0a                         !8 freeze_prep_stash_sd_buffer_and_regs
  1003                          
  1004                                  ;; SDcard sector buffer (F011)
  1005  8ae3 006cfd0f                   !32 $ffd6c00
  1006  8ae7 0002                       !16 $0200
  1007  8ae9 00                         !8 0
  1008  8aea 00                         !8 freeze_prep_none
  1009                          
  1010                                  ;; Process decriptor
  1011  8aeb 00bdff0f                   !32 $fffbd00
  1012  8aef 0001                       !16 $0100
  1013  8af1 00                         !8 0
  1014  8af2 00                         !8 freeze_prep_none
  1015                          
  1016                                  ;; $D640-$D67E hypervisor state registers
  1017                                  ;; XXX - These can't be read by DMA, so we need to have a
  1018                                  ;; prep routine that copies them out first?
  1019  8af3 4036fd0f                   !32 $ffd3640
  1020  8af7 3f00                       !16 $003f
  1021  8af9 00                         !8 0
  1022  8afa 10                         !8 freeze_prep_hyperregs
  1023                          
  1024                                  ;; VIC-IV palette block 0
  1025  8afb 0031fd0f                   !32 $ffd3100
  1026  8aff 0003                       !16 $0300
  1027  8b01 00                         !8 0
  1028  8b02 02                         !8 freeze_prep_palette0
  1029                          
  1030                                  ;; VIC-IV palette block 1
  1031  8b03 0031fd0f                   !32 $ffd3100
  1032  8b07 0003                       !16 $0300
  1033  8b09 00                         !8 0
  1034  8b0a 04                         !8 freeze_prep_palette1
  1035                          
  1036                                  ;; VIC-IV palette block 2
  1037  8b0b 0031fd0f                   !32 $ffd3100
  1038  8b0f 0003                       !16 $0300
  1039  8b11 00                         !8 0
  1040  8b12 06                         !8 freeze_prep_palette2
  1041                          
  1042                                  ;; VIC-IV palette block 3
  1043  8b13 0031fd0f                   !32 $ffd3100
  1044  8b17 0003                       !16 $0300
  1045  8b19 00                         !8 0
  1046  8b1a 08                         !8 freeze_prep_palette3
  1047                          
  1048                                  ;; 32KB colour RAM
  1049  8b1b 0000f80f                   !32 $ff80000
  1050  8b1f 0080                       !16 $8000
  1051  8b21 00                         !8 $00
  1052  8b22 00                         !8 freeze_prep_none
  1053                          
  1054                                  ;; CIAs
  1055  8b23 003cfd0f                   !32 $ffd3c00
  1056  8b27 0002                       !16 $0200
  1057  8b29 00                         !8 0
  1058  8b2a 00                         !8 freeze_prep_none
  1059                          
  1060                                  ;; VIC-IV, F011 $D000-$D0FF
  1061                                  ;; This should be last since it is not a whole sector worth, and there is a bug
  1062                                  ;; that gets tickled sometimes if a region is not an integer number of sectors.
  1063  8b2b 0030fd0f                   !32 $ffd3000
  1064  8b2f 8000                       !16 $0080
  1065  8b31 00                         !8 0
  1066  8b32 0e                         !8 freeze_prep_viciv
  1067                          
  1068                                  ;; VIC-IV C128 2MHz enable emulation register
  1069  8b33 3000fd0f                   !32 $ffd0030
  1070  8b37 0100                       !16 $0001
  1071  8b39 00                         !8 0
  1072  8b3a 00                         !8 freeze_prep_none
  1073                          
  1074                                  ;; 384KB RAM (includes the 128KB "ROM" area)
  1075                                  ;; Must be saved before doing the thumbnail, which re-uses $1000-$1FFF to store the thumbnail image
  1076  8b3b 00000000                   !32 $0000000
  1077  8b3f 0000                       !16 $0000
  1078  8b41 06                         !8 6          ;; =6x64K blocks = 384KB
  1079  8b42 00                         !8 freeze_prep_none
  1080                          
  1081                                  ;; Process scratch space
  1082  8b43 00bd0000                   !32 currenttask_block
  1083  8b47 0001                       !16 $0100
  1084  8b49 00                         !8 0
  1085  8b4a 00                         !8 freeze_prep_none
  1086                          
  1087                                  ;; $D700-$D7FF CPU registers (excluding DMAgic registers, which we save/restore along with SD card registers)
  1088  8b4b 1037fd0f                   !32 $ffd3710
  1089  8b4f f000                       !16 $00F0
  1090  8b51 00                         !8 0
  1091  8b52 00                         !8 freeze_prep_none
  1092                          
  1093                                  ;; Internal 1541 4KB RAM + 16KB ROM
  1094                                  ;; XXX - Need to also save state of VIAs
  1095  8b53 00b0fd0f                   !32 $FFDB000
  1096  8b57 0050                       !16 $5000
  1097  8b59 00                         !8 0
  1098  8b5a 00                         !8 freeze_prep_none
  1099                          
  1100                                  ;; XXX - Thumbnail must be saved last, because something about freezing this causes
  1101                                  ;; the freezing of the remaining regions to fail.
  1102                                  ;; 4KB thumbnail of screen
  1103                                  ;; The prep routine copies this down to $1000-$1FFF, so we have to have saved the rest of RAM
  1104                                  ;; first
  1105  8b5b 00100000                   !32 $0001000
  1106  8b5f 0010                       !16 $1000
  1107  8b61 80                         !8 $80                              ;; bit 7 set in # banks tells unfreezer to ignore it.
  1108  8b62 0c                         !8 freeze_prep_thumbnail
  1109                          
  1110                                  ;; XXX - Other IO chips!
  1111                          
  1112                                  ;; End of list
  1113  8b63 ffffffff                   !32 $FFFFFFFF
  1114  8b67 ffff                       !16 $FFFF
  1115  8b69 ff                         !8 $FF
  1116  8b6a ff                         !8 $FF
  1117                          
  1118                          freeze_mem_list_end:
  1119                          
  1120                          freeze_dma_length_remaining:
  1121  8b6b 000000                     !8 0,0,0
  1122                          
  1123                                  ;; If bit 7 set, then don't DMA the region into place on unfreezing
  1124                          unfreeze_skip:
  1125  8b6e 00                         !8 0
  1126                          

; ******** Source: src/hyppo/main.asm
   375                          
   376                          ;; /*  -------------------------------------------------------------------
   377                          ;;     DOS, process control and related functions trap
   378                          ;;     ---------------------------------------------------------------- */

; ******** Source: dos.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                  ;; XXX - Track down why 2nd and subsequent LFN blocks are not used.
     7                          
     8                          dos_and_process_trap:
     9                          
    10                                  ;; XXX - Machine is being updated to automatically disable IRQs on trapping
    11                                  ;; to hypervisor, but for now, we need to do this explicitly.
    12                                  ;; Should be able to be removed after 20160103
    13                                  ;; BG: cannot confirm removal of the instruction below. Dated 20160902
    14  8b6f 78                         sei
    15                          
    16                                  ;; XXX - We have just added a fix for this in the CPU, to CLEAR DECIMAL MODE
    17                                  ;; on entry to the hypervisor. But I'm not taking any chances just now.
    18                                  ;;
    19  8b70 d8                         cld
    20                          
    21                                  ;; Sub-function is selected by A.
    22                                  ;; Bits 6-1 are the only ones used.
    23                                  ;; Mask out bit 0 so that indirect jmp's are valid.
    24                                  ;;
    25  8b71 297e                       and #$7E
    26  8b73 aa                         tax
    27  8b74 7c778b                     jmp (dos_and_process_trap_table,x)
    28                          
    29                          ;;         ========================
    30                          
    31                          dos_and_process_trap_table:
    32                          
    33                                  ;; $00 - $0E
    34                                  ;;
    35  8b77 3c8c                       !16 trap_dos_getversion
    36  8b79 538c                       !16 trap_dos_getdefaultdrive
    37  8b7b b18c                       !16 trap_dos_getcurrentdrive          ;; appears out-of-order (is far below)
    38  8b7d 5c8c                       !16 trap_dos_selectdrive
    39  8b7f bf8f                       !16 trap_dos_getdisksize              ;; not currently implememted
    40  8b81 bf8f                       !16 trap_dos_getcwd                   ;; not currently implememted
    41  8b83 1f8f                       !16 trap_dos_chdir                    
    42  8b85 bf8f                       !16 trap_dos_mkdir                    ;; not currently implememted
    43                          
    44                                  ;; $10 - $1E
    45                                  ;;
    46  8b87 bf8f                       !16 trap_dos_rmdir                    ;; not currently implememted
    47  8b89 cb8e                       !16 trap_dos_opendir
    48  8b8b df8e                       !16 trap_dos_readdir
    49  8b8d 0d8f                       !16 trap_dos_closedir
    50  8b8f 2d8f                       !16 trap_dos_openfile
    51  8b91 108f                       !16 trap_dos_readfile                 
    52  8b93 bf8f                       !16 trap_dos_writefile                ;; not currently implememted
    53  8b95 ba8c                       !16 trap_dos_mkfile                   ;; implementation started
    54                          
    55                                  ;; $20 - $2E
    56                                  ;;
    57  8b97 3b8f                       !16 trap_dos_closefile
    58  8b99 6a8c                       !16 trap_dos_closeall
    59  8b9b bf8f                       !16 trap_dos_seekfile                 ;; not currently implememted
    60  8b9d bf8f                       !16 trap_dos_rmfile                   ;; not currently implememted
    61  8b9f bf8f                       !16 trap_dos_fstat                    ;; not currently implememted
    62  8ba1 bf8f                       !16 trap_dos_rename                   ;; not currently implememted
    63  8ba3 bf8f                       !16 trap_dos_filedate                 ;; not currently implememted
    64  8ba5 928c                       !16 trap_dos_setname
    65                          
    66                                  ;; $30 - $3E
    67                                  ;;
    68  8ba7 5d8f                       !16 trap_dos_findfirst
    69  8ba9 698f                       !16 trap_dos_findnext
    70  8bab 578f                       !16 trap_dos_findfile
    71  8bad 738c                       !16 trap_dos_loadfile
    72  8baf 6f8f                       !16 trap_dos_geterrorcode
    73  8bb1 8c8c                       !16 trap_dos_setup_transfer_area
    74  8bb3 168f                       !16 trap_dos_cdrootdir
    75  8bb5 708c                       !16 trap_dos_loadfile_attic
    76                          
    77                                  ;; $40 - $4E
    78                                  ;;
    79  8bb7 788f                       !16 trap_dos_d81attach0
    80  8bb9 848f                       !16 trap_dos_d81detach
    81  8bbb 8a8f                       !16 trap_dos_d81write_en
    82  8bbd 7e8f                       !16 trap_dos_d81attach1
    83  8bbf 908f                       !16 trap_dos_get_proc_desc
    84  8bc1 2f82                       !16 invalid_subfunction
    85  8bc3 2f82                       !16 invalid_subfunction
    86  8bc5 2f82                       !16 invalid_subfunction
    87                          
    88                                  ;; $50 - $5E
    89                                  ;;
    90  8bc7 bf8f                       !16 trap_dos_gettasklist              ;; not currently implememted
    91  8bc9 bf8f                       !16 trap_dos_sendmessage              ;; not currently implememted
    92  8bcb bf8f                       !16 trap_dos_receivemessage           ;; not currently implememted
    93  8bcd bf8f                       !16 trap_dos_writeintotask            ;; not currently implememted
    94  8bcf bf8f                       !16 trap_dos_readoutoftask            ;; not currently implememted
    95  8bd1 2f82                       !16 invalid_subfunction
    96  8bd3 2f82                       !16 invalid_subfunction
    97  8bd5 2f82                       !16 invalid_subfunction
    98                          
    99                                  ;; $60 - $6E
   100                                  ;;
   101  8bd7 bf8f                       !16 trap_dos_terminateothertask       ;; not currently implememted
   102  8bd9 bf8f                       !16 trap_dos_create_task_native       ;; not currently implememted
   103  8bdb bf8f                       !16 trap_dos_load_into_task           ;; not currently implememted
   104  8bdd bf8f                       !16 trap_dos_create_task_c64          ;; not currently implememted
   105  8bdf bf8f                       !16 trap_dos_create_task_c65          ;; not currently implememted
   106  8be1 bf8f                       !16 trap_dos_exit_and_switch_to_task  ;; not currently implememted
   107  8be3 bf8f                       !16 trap_dos_switch_to_task           ;; not currently implememted
   108  8be5 bf8f                       !16 trap_dos_exit_task                ;; not currently implememted
   109                          
   110                                  ;; $70 - $7E
   111                                  ;;
   112  8be7 2e8c                       !16 trap_task_toggle_rom_writeprotect
   113  8be9 238c                       !16 trap_task_toggle_force_4502
   114  8beb fd8b                       !16 trap_task_get_mapping
   115  8bed 108c                       !16 trap_task_set_mapping
   116  8bef 2f82                       !16 invalid_subfunction
   117  8bf1 2f82                       !16 invalid_subfunction
   118  8bf3 f78b                       !16 trap_serial_monitor_write
   119  8bf5 c3a2                       !16 reset_entry
   120                          
   121                          trap_serial_monitor_write:
   122  8bf7 8c7cd6                     sty hypervisor_write_char_to_serial_monitor
   123  8bfa 4c1082                     jmp return_from_trap_with_success
   124                          
   125                          ;;         ========================
   126                          
   127                          trap_task_get_mapping:
   128  8bfd 2062ab             	jsr hypervisor_setup_copy_region
   129  8c00 900b               	bcc @bad
   130  8c02 a005               	ldy #5
   131                          @copyloop:
   132  8c04 b94ad6             	lda hypervisor_maplolo,y
   133  8c07 9106               	sta (<hypervisor_userspace_copy_vector),y
   134  8c09 88                 	dey
   135  8c0a 10f8               	bpl @copyloop
   136  8c0c 38                 	sec
   137                          @bad:
   138  8c0d 4c628c             	jmp return_from_trap_with_carry_flag
   139                          
   140                          trap_task_set_mapping:
   141  8c10 2062ab             	jsr hypervisor_setup_copy_region
   142  8c13 900b               	bcc @bad2
   143  8c15 a005               	ldy #5
   144                          @copyloop2:
   145  8c17 b106               	lda (<hypervisor_userspace_copy_vector),y
   146  8c19 994ad6             	sta hypervisor_maplolo,y
   147  8c1c 88                 	dey
   148  8c1d 10f8               	bpl @copyloop2
   149  8c1f 38                 	sec
   150                          @bad2:
   151  8c20 4c628c             	jmp return_from_trap_with_carry_flag
   152                          	
   153                          trap_task_toggle_force_4502:
   154  8c23 ad7dd6                     lda hypervisor_feature_enables
   155  8c26 4920                       eor #$20
   156  8c28 8d7dd6                     sta hypervisor_feature_enables
   157  8c2b 4c368c                     jmp returnFeatureState
   158                          
   159                          trap_task_toggle_rom_writeprotect:
   160  8c2e ad7dd6                     lda hypervisor_feature_enables
   161  8c31 4904                       eor #$04
   162  8c33 8d7dd6                     sta hypervisor_feature_enables
   163                          returnFeatureState:
   164                                  ;; Pass updated state back out to caller, so they know the result
   165  8c36 8d40d6                     sta hypervisor_a
   166  8c39 4c1082                     jmp return_from_trap_with_success
   167                          
   168                          trap_dos_getversion:
   169                          
   170                                  ;; Return OS and DOS version.
   171                                  ;; A/X = OS Version major/minor
   172                                  ;; Z/Y = DOS Version major/minor
   173                          
   174  8c3c a902                       lda #<os_version
   175  8c3e 8d41d6                     sta hypervisor_x
   176  8c41 a901                       lda #>os_version
   177  8c43 8d40d6                     sta hypervisor_a
   178  8c46 a902                       lda #<dos_version
   179  8c48 8d43d6                     sta hypervisor_z
   180  8c4b a901                       lda #>dos_version
   181  8c4d 8d42d6                     sta hypervisor_y
   182  8c50 4c1082                     jmp return_from_trap_with_success
   183                          
   184                          ;;         ========================
   185                          
   186                          trap_dos_getdefaultdrive:
   187                          
   188  8c53 ad02bc                     lda dos_default_disk
   189  8c56 8d40d6                     sta hypervisor_a
   190  8c59 4c1082                     jmp return_from_trap_with_success
   191                          
   192                          ;;         ========================
   193                          
   194                          trap_dos_selectdrive:
   195                          
   196  8c5c ae41d6                     ldx hypervisor_x
   197  8c5f 207392                     jsr dos_set_current_disk
   198                          
   199                          return_from_trap_with_carry_flag:
   200  8c62 b003                       bcs +
   201  8c64 4c1e82                     jmp return_from_trap_with_failure
   202  8c67 4c1082             +       jmp return_from_trap_with_success
   203                          
   204                          trap_dos_closeall:
   205                          
   206  8c6a 20c28f                     jsr dos_clear_filedescriptors
   207  8c6d 4c1082                     jmp return_from_trap_with_success
   208                          
   209                          ;;         ========================
   210                          
   211                          trap_dos_loadfile_attic:
   212  8c70 a908               	lda #$08  		; Set address to $8xxxxxx to access attic RAM
   213  8c72 2c                 	!8 $2c 		; BIT $xxxx to skip lda #$00 below
   214                          	;; FALL THROUGH
   215                          	
   216                          trap_dos_loadfile:
   217                          
   218                                  ;; Only allow loading into lower 16MB to avoid possibility of writing
   219                                  ;; over hypervisor
   220                                  ;;
   221  8c73 a900                       lda #$00
   222  8c75 851b                       sta <(dos_file_loadaddress+3)
   223                          
   224  8c77 ad41d6                     lda hypervisor_x
   225  8c7a 8518                       sta <dos_file_loadaddress
   226  8c7c ad42d6                     lda hypervisor_y
   227  8c7f 8519                       sta <(dos_file_loadaddress+1)
   228  8c81 ad43d6                     lda hypervisor_z
   229  8c84 851a                       sta <(dos_file_loadaddress+2)
   230                          
   231  8c86 204798                     jsr dos_readfileintomemory
   232  8c89 4c628c                     jmp return_from_trap_with_carry_flag
   233                          
   234                          ;;         ========================
   235                          
   236                          trap_dos_setup_transfer_area:
   237                          
   238  8c8c 2062ab                     jsr hypervisor_setup_copy_region
   239                          
   240  8c8f 4c628c                     jmp return_from_trap_with_carry_flag
   241                          
   242                          trap_dos_setname:
   243                          
   244                                  ;; read file name from any where in bottom 32KB of RAM, as mapped on entry
   245                                  ;; to the hypervisor (this prevents the user from setting the filename to some
   246                                  ;; piece of the hypervisor, and thus leaking hypervisor data to user-land if the
   247                                  ;; user were to later query the filename).
   248                          
   249                                  +Checkpoint "trap_dos_setname"
   250                          
   251  8c92 2062ab                     jsr hypervisor_setup_copy_region
   252  8c95 900c                       bcc tdsnfailure
   253                          
   254  8c97 a606                       ldx <hypervisor_userspace_copy_vector
   255  8c99 a407                       ldy <(1+hypervisor_userspace_copy_vector)
   256  8c9b 204a99                     jsr dos_setname
   257  8c9e 9003                       bcc tdsnfailure
   258                          
   259                                  ;; setname succeeded
   260                                  ;;
   261                          
   262  8ca0 4c1082                     jmp return_from_trap_with_success
   263                          
   264                          ;;         ========================
   265                          
   266                          tdsnfailure:
   267                                  ;; save the error code so a later trap_dos_geterrorcode will return it
   268  8ca3 8dfabc                     sta dos_error_code
   269  8ca6 4c1e82                     jmp return_from_trap_with_failure
   270                          
   271                          ;;         ========================
   272                          
   273                          
   274                          illegalvalue:
   275                          
   276                                  ;; BG: the below section seems never called from anywhere: suggest removal
   277                          
   278                          !if DEBUG_HYPPO {
   279                          ;;         tya
   280                          ;;         tax
   281                          ;;         jsr checkpoint_bytetohex
   282                          ;;         sty iv1+0
   283                          ;;         stx iv1+1
   284                          ;;
   285                          ;;         jsr checkpoint
   286                          ;;         .byte 0,"Filename contains $00 @ position $"
   287                          ;; iv1:        .byte "%%",0
   288                          }
   289                          
   290  8ca9 a911                       lda #dos_errorcode_illegal_value
   291  8cab 8dfabc                     sta dos_error_code
   292  8cae 4c1e82                     jmp return_from_trap_with_failure
   293                          
   294                          ;;         ========================
   295                          
   296                          trap_dos_getcurrentdrive:
   297                          
   298  8cb1 ad03bc                     lda dos_disk_current_disk
   299  8cb4 8d40d6                     sta hypervisor_a
   300  8cb7 4c1082                     jmp return_from_trap_with_success
   301                          
   302                          ;;         ========================
   303                          
   304                          trap_dos_mkfile:
   305                          
   306                          	;; XXX Filename must already be set.
   307                          	;; XXX Must be a file in the current directory only.
   308                          	;; XXX Can only create normal files, not directories
   309                          	;;     (change attribute after).
   310                          	;; XXX Only supports 8.3 names for now.
   311                          	;; XXX Filenames without extension might still cause problems.
   312                          	;; XXX Allocates 512KB at a time, i.e., a full FAT sector's
   313                          	;;     worth of clusters.
   314                          	;; XXX Allocates a contiguous block, so that D81s etc can
   315                          	;;     be created, and guaranteed contiguous on the storage,
   316                          	;;     so that they can be mounted.
   317                          	;; XXX Size of file specified in $ZZYYXX, i.e., limit of 16MB.
   318                          	;; XXX Doesn't handle full file systems (or ones without enough space
   319                          	;;     free properly. Should check candidate cluster number is not too
   320                          	;;     high, and abort if it is.
   321                          
   322                          	;; First, make sure the file doesn't already exist
   323  8cba 20b593             	jsr dos_findfile
   324  8cbd 9009               	bcc +
   325                          	;; File exists, so abort
   326  8cbf 18                 	clc
   327  8cc0 a98d               	lda #dos_errorcode_file_exists
   328  8cc2 8dfabc             	sta dos_error_code
   329  8cc5 4c1e82             	jmp return_from_trap_with_failure
   330                          +
   331                          
   332                          	;; We need 1 FAT sector per 512KB of data.
   333                          	;; I.e., shift ZZ right by three bits to get number
   334                          	;; of empty FAT sectors we need to indicate sufficient space.
   335  8cc8 ad43d6             	lda hypervisor_z
   336  8ccb 4a                 	lsr
   337  8ccc 4a                 	lsr
   338  8ccd 4a                 	lsr
   339  8cce 18                 	clc
   340  8ccf 6901               	adc #$01 
   341  8cd1 8d04bf             	sta dos_scratch_byte_1
   342                          
   343                          	;; Now go looking for empty FAT sectors
   344                          	;; Start at cluster 128, and add 128 each time to step through
   345                          	;; them.
   346                          	;; This skips the first sector of FAT, which always has some used
   347                          	;; bits, and ensures we can allocate on a whole sector basis.
   348  8cd4 a980               	lda #128
   349  8cd6 8510               	sta <(zptempv32+0)
   350  8cd8 a900               	lda #$00
   351  8cda 8511               	sta <(zptempv32+1)
   352  8cdc 8512               	sta <(zptempv32+2)
   353  8cde 8513               	sta <(zptempv32+3)
   354                          
   355                          	;; Initially 0 empty pages found
   356  8ce0 a900               	lda #0
   357  8ce2 8d05bf             	sta dos_scratch_byte_2
   358                          
   359  8ce5 20c39f             	jsr sd_map_sectorbuffer
   360                          
   361                          find_empty_fat_page_loop:
   362                          	
   363  8ce8 a203               	ldx #3
   364  8cea b510               -	lda <zptempv32,x
   365  8cec 9db3bc             	sta dos_current_cluster,x
   366  8cef ca                 	dex
   367  8cf0 10f8               	bpl -
   368                          
   369  8cf2 20ba8e             	jsr read_fat_sector_for_cluster
   370                          	
   371                          	;; Is the page empty
   372  8cf5 a200               	ldx #0
   373  8cf7 bd00de             -	lda sd_sectorbuffer,x
   374  8cfa d008               	bne +
   375  8cfc bd00df             	lda sd_sectorbuffer+$100,x
   376  8cff d003               	bne +
   377                          
   378  8d01 e8                 	inx
   379  8d02 d0f3               	bne -
   380                          +
   381                          	
   382                          	;; Z=1 if FAT sector all unallocated, Z=0 otherwise
   383  8d04 f008               	beq fat_sector_is_empty
   384                          
   385                          	;; Reset empty FAT sector counter
   386  8d06 a900               	lda #0
   387  8d08 8d05bf             	sta dos_scratch_byte_2
   388  8d0b 4c198d             	jmp +
   389                          	
   390                          fat_sector_is_empty:	
   391  8d0e ee05bf             	inc dos_scratch_byte_2
   392  8d11 ad05bf             	lda dos_scratch_byte_2
   393  8d14 cd04bf             	cmp dos_scratch_byte_1
   394  8d17 f01c               	beq found_enough_contiguous_free_space
   395                          +
   396                          	;; Need to find another
   397  8d19 a980               	lda #$80
   398  8d1b 18                 	clc
   399  8d1c 6510               	adc <(zptempv32+0)
   400  8d1e 8510               	sta <(zptempv32+0)
   401  8d20 a511               	lda <(zptempv32+1)
   402  8d22 6900               	adc #0
   403  8d24 8511               	sta <(zptempv32+1)
   404  8d26 a512               	lda <(zptempv32+2)
   405  8d28 6900               	adc #0
   406  8d2a 8512               	sta <(zptempv32+2)
   407  8d2c a513               	lda <(zptempv32+3)
   408  8d2e 6900               	adc #0
   409  8d30 8513               	sta <(zptempv32+3)
   410                          
   411                          	;; XXX Check that we haven't hit the end of the file system
   412                          	
   413  8d32 4ce88c             	jmp find_empty_fat_page_loop
   414                          
   415                          found_enough_contiguous_free_space:
   416                          
   417                          	;; Space begins dos_scratch_byte_2 FAT sectors before here,
   418                          	;; so rewind back to there by taking $80 away for each count.
   419  8d35 ce05bf             	dec dos_scratch_byte_2
   420                          	
   421  8d38 ad05bf             -	lda dos_scratch_byte_2
   422  8d3b f01f               	beq +
   423  8d3d a510               	lda <(zptempv32+0)
   424  8d3f 38                 	sec
   425  8d40 e980               	sbc #$80
   426  8d42 8510               	sta <(zptempv32+0)
   427  8d44 a511               	lda <(zptempv32+1)
   428  8d46 e900               	sbc #0
   429  8d48 8511               	sta <(zptempv32+1)
   430  8d4a a512               	lda <(zptempv32+2)
   431  8d4c e900               	sbc #0
   432  8d4e 8512               	sta <(zptempv32+2)
   433  8d50 a513               	lda <(zptempv32+3)
   434  8d52 e900               	sbc #0
   435  8d54 8513               	sta <(zptempv32+3)
   436  8d56 ce05bf             	dec dos_scratch_byte_2
   437  8d59 4c388d             	jmp -
   438                          +
   439                          	;; zptempv32 now contains the starting cluster for our file
   440                          
   441                          	;; Find directory entry slot
   442  8d5c 20778e             	jsr dos_find_free_dirent
   443  8d5f b001               	bcs +
   444                          	;; Couldn't find a free dirent, so return whatever error
   445                          	;; we have been indicated.
   446  8d61 60                 	rts
   447                          +
   448                          
   449                          	;; Show offset in directory sector for dirent
   450                          ;;	lda dos_scratch_vector+0
   451                          ;;	sta $0700
   452                          ;;	lda dos_scratch_vector+1
   453                          ;;	and #$01
   454                          ;;	sta $0701
   455                          ;;
   456                          ;;	;; Show directory sector
   457                          ;;	ldx #3
   458                          ;;!:	lda $d681,x
   459                          ;;	sta $0703,x
   460                          ;;	dex
   461                          ;;	bpl !-
   462                          ;;
   463                          ;;	;; Show first cluster we will use
   464                          ;;	ldx #3
   465                          ;;!:	lda zptempv32,x
   466                          ;;	sta $0708,x
   467                          ;;	dex
   468                          ;;	bpl !-
   469                          	
   470                          	;; XXX Populate dirent structure
   471                          	;; dirent: erase old contents
   472  8d62 a01f               	ldy #31
   473  8d64 a900               	lda #0
   474  8d66 9100               -	sta (<dos_scratch_vector),y
   475                          	;; Put spaces in filename field (first 11 bytes)
   476  8d68 c00b               	cpy #11
   477  8d6a d002               	bne foo1
   478  8d6c a920               	lda #$20
   479                          foo1:	
   480  8d6e 88                 	dey
   481  8d6f 10f5               	bpl -
   482                          	;; dirent: filename
   483                          	;; Split filename at dot
   484  8d71 a000               	ldy #0
   485  8d73 a200               	ldx #fs_fat32_dirent_offset_shortname
   486  8d75 bd67bc             -	lda dos_requested_filename,x
   487  8d78 c92e               	cmp #$2e
   488  8d7a d004               	bne not_dot
   489  8d7c a007               	ldy #8-1
   490  8d7e d006               	bne was_dot
   491                          not_dot:
   492                          	;; Don't write nul char if filename is short
   493  8d80 c900               	cmp #0
   494  8d82 f00a               	beq +
   495  8d84 9100               	sta (<dos_scratch_vector),y
   496                          was_dot:	
   497  8d86 f006               	beq +
   498  8d88 e8                 	inx
   499  8d89 c8                 	iny
   500  8d8a c00b               	cpy #11
   501  8d8c d0e7               	bne -
   502                          +
   503                          	
   504                          	;; dirent: attributes
   505  8d8e a00b               	ldy #fs_fat32_dirent_offset_attributes
   506  8d90 a920               	lda #$20 ;; Archive bit set
   507  8d92 9100               	sta (<dos_scratch_vector),y
   508                          	;; dirent: start cluster
   509  8d94 a01a               	ldy #fs_fat32_dirent_offset_clusters_low
   510  8d96 a510               	lda <(zptempv32+0)
   511  8d98 9100               	sta (<dos_scratch_vector),y
   512  8d9a c8                 	iny
   513  8d9b a511               	lda <(zptempv32+1)
   514  8d9d 9100               	sta (<dos_scratch_vector),y
   515  8d9f a014               	ldy #fs_fat32_dirent_offset_clusters_high
   516  8da1 a512               	lda <(zptempv32+2)
   517  8da3 9100               	sta (<dos_scratch_vector),y
   518  8da5 c8                 	iny
   519  8da6 a513               	lda <(zptempv32+3)
   520  8da8 9100               	sta (<dos_scratch_vector),y	
   521                          	;; dirent: file length
   522  8daa a01c               	ldy #fs_fat32_dirent_offset_file_length
   523  8dac ad41d6             	lda hypervisor_x
   524  8daf 9100               	sta (<dos_scratch_vector),y
   525  8db1 c8                 	iny
   526  8db2 ad42d6             	lda hypervisor_y
   527  8db5 9100               	sta (<dos_scratch_vector),y
   528  8db7 c8                 	iny
   529  8db8 ad43d6             	lda hypervisor_z
   530  8dbb 9100               	sta (<dos_scratch_vector),y
   531  8dbd c8                 	iny
   532  8dbe a900               	lda #0
   533  8dc0 9100               	sta (<dos_scratch_vector),y
   534                          
   535                          	;; Write sector back with updated dirent
   536  8dc2 20499f             	jsr write_non_mbr_sector
   537  8dc5 205a9f             	jsr sd_wait_for_ready
   538                          		
   539                          	;; Update both FATs to make the allocation
   540                          
   541                          	;; Work out how many sectors full of incrementing clusters
   542                          	;; we need.
   543  8dc8 ad04bf             	lda dos_scratch_byte_1
   544  8dcb 8d05bf             	sta dos_scratch_byte_2
   545                          mkfile_fat_write_loop:	
   546                          	;; Get the (currently empty) sector
   547  8dce a203               	ldx #3
   548  8dd0 b510               -	lda <zptempv32,x
   549  8dd2 9db3bc             	sta dos_current_cluster,x
   550  8dd5 ca                 	dex
   551  8dd6 10f8               	bpl -
   552  8dd8 20ba8e             	jsr read_fat_sector_for_cluster
   553                          
   554                          	;; Update cluster number and write it into the field
   555  8ddb a000               	ldy #0
   556                          -
   557                          	;; XXX Rework to use 32-bit pseudo register
   558  8ddd a510               	lda <(zptempv32+0)
   559  8ddf 18                 	clc
   560  8de0 6901               	adc #1
   561  8de2 8510               	sta <(zptempv32+0)
   562  8de4 9900de             	sta sd_sectorbuffer,y
   563  8de7 c8                 	iny
   564  8de8 a511               	lda <(zptempv32+1)
   565  8dea 6900               	adc #0
   566  8dec 8511               	sta <(zptempv32+1)
   567  8dee 9900de             	sta sd_sectorbuffer,y
   568  8df1 c8                 	iny
   569  8df2 a512               	lda <(zptempv32+2)
   570  8df4 6900               	adc #0
   571  8df6 8512               	sta <(zptempv32+2)
   572  8df8 9900de             	sta sd_sectorbuffer,y
   573  8dfb c8                 	iny
   574  8dfc a513               	lda <(zptempv32+3)
   575  8dfe 6900               	adc #0
   576  8e00 8513               	sta <(zptempv32+3)
   577  8e02 9900de             	sta sd_sectorbuffer,y
   578  8e05 c8                 	iny
   579  8e06 d0d5               	bne -
   580                          -
   581  8e08 a510               	lda <(zptempv32+0)
   582  8e0a 18                 	clc
   583  8e0b 6901               	adc #1
   584  8e0d 8510               	sta <(zptempv32+0)
   585  8e0f 9900df             	sta sd_sectorbuffer+$100,y
   586  8e12 c8                 	iny
   587  8e13 a511               	lda <(zptempv32+1)
   588  8e15 6900               	adc #0
   589  8e17 8511               	sta <(zptempv32+1)
   590  8e19 9900df             	sta sd_sectorbuffer+$100,y
   591  8e1c c8                 	iny
   592  8e1d a512               	lda <(zptempv32+2)
   593  8e1f 6900               	adc #0
   594  8e21 8512               	sta <(zptempv32+2)
   595  8e23 9900df             	sta sd_sectorbuffer+$100,y
   596  8e26 c8                 	iny
   597  8e27 a513               	lda <(zptempv32+3)
   598  8e29 6900               	adc #0
   599  8e2b 8513               	sta <(zptempv32+3)
   600  8e2d 9900df             	sta sd_sectorbuffer+$100,y
   601  8e30 c8                 	iny
   602  8e31 d0d5               	bne -
   603                          
   604                          	;; If the last FAT sector for this file, then
   605                          	;; the last cluster entry should be $0FFFFFF8 to mark
   606                          	;; end of file.
   607  8e33 ad05bf             	lda dos_scratch_byte_2
   608  8e36 c901               	cmp #1
   609  8e38 d012               	bne +
   610  8e3a a9f8               	lda #$F8
   611  8e3c 8dfcdf             	sta $dffc
   612  8e3f a9ff               	lda #$FF
   613  8e41 8dfddf             	sta $dffd
   614  8e44 8dfedf             	sta $dffe
   615  8e47 a90f               	lda #$0F
   616  8e49 8dffdf             	sta $dfff
   617                          +	
   618                          	;; Write FAT sector to FAT1
   619  8e4c 20499f             	jsr write_non_mbr_sector
   620  8e4f 205a9f             	jsr sd_wait_for_ready
   621                          
   622                          	;; Work out where it will be in the 2nd FAT
   623  8e52 ad04bc             	lda dos_disk_table_offset
   624  8e55 0909               	ora #fs_fat32_length_of_fat
   625  8e57 a8                 	tay
   626  8e58 a200               	ldx #0
   627  8e5a bd81d6             -	lda $d681,x
   628  8e5d 7900bb             	adc dos_disk_table,y
   629  8e60 c8                 	iny
   630  8e61 e8                 	inx
   631  8e62 e004               	cpx #4
   632  8e64 d0f4               	bne -
   633                          	
   634                          	;; Write FAT sector to FAT2
   635  8e66 20499f             	jsr write_non_mbr_sector
   636  8e69 205a9f             	jsr sd_wait_for_ready
   637                          	
   638                          	;; More FAT sectors to go?
   639  8e6c ce05bf             	dec dos_scratch_byte_2
   640  8e6f f003               	beq +
   641  8e71 4cce8d             	jmp mkfile_fat_write_loop
   642                          +		
   643                          
   644                          	;; All done: File has been created.
   645  8e74 4c1082             	jmp return_from_trap_with_success
   646                          
   647                          dos_find_free_dirent:
   648                          	;; Start by opening the directory.
   649  8e77 20e693             	jsr dos_opendir
   650                          	;; Then look for free directory entry slots.
   651  8e7a 20c39f             	jsr sd_map_sectorbuffer
   652                          
   653                          	;; FALL THROUGH
   654                          	
   655                          empty_dirent_search_loop:	
   656                          	
   657  8e7d 20e296             	jsr dos_file_read_current_sector
   658                          
   659                          	;; Look for free dirent in first half of each sector.
   660  8e80 a200               	ldx #0
   661  8e82 a9de               	lda #$de
   662  8e84 8501               	sta <(dos_scratch_vector+1)
   663  8e86 bd00de             -	lda sd_sectorbuffer,x
   664  8e89 c900               	cmp #$00 ;; vacant
   665  8e8b f029               	beq available_dirent_slot
   666  8e8d c9e5               	cmp #$e5 ;; deleted
   667  8e8f f025               	beq available_dirent_slot
   668  8e91 8a                 	txa
   669  8e92 6920               	adc #$20
   670  8e94 aa                 	tax
   671  8e95 d0ef               	bne -
   672  8e97 e601               	inc <(dos_scratch_vector+1)
   673  8e99 bd00de             -	lda sd_sectorbuffer,x
   674  8e9c c900               	cmp #$00 ;; vacant
   675  8e9e f016               	beq available_dirent_slot
   676  8ea0 c9e5               	cmp #$e5 ;; deleted
   677  8ea2 f012               	beq available_dirent_slot
   678  8ea4 8a                 	txa
   679  8ea5 6920               	adc #$20
   680  8ea7 aa                 	tax
   681  8ea8 d0ef               	bne -
   682                          
   683                          	;; No empty slots in this directory, so see if there any more sectors in
   684                          	;; this directory?
   685  8eaa 20ff96             	jsr dos_file_advance_to_next_sector
   686  8ead b0ce               	bcs empty_dirent_search_loop
   687                          
   688                          	;; Directory is full, so return error
   689                          	;; XXX Later we should allow extending the directory by adding another cluster.
   690  8eaf a98e               	lda #dos_errorcode_directory_full
   691  8eb1 8dfabc             	sta dos_error_code
   692  8eb4 18                 	clc
   693  8eb5 60                 	rts
   694                          	
   695                          available_dirent_slot:	
   696  8eb6 8600               	stx <(dos_scratch_vector+0)
   697                          	
   698  8eb8 38                 	sec
   699  8eb9 60                 	rts
   700                          
   701                          ;;         ========================
   702                          	
   703                          read_fat_sector_for_cluster:
   704  8eba 200298             	jsr dos_cluster_to_fat_sector
   705                          
   706                          	;; Now read the sector
   707  8ebd a203                       ldx #3
   708  8ebf bdb3bc             -       lda dos_current_cluster,x
   709  8ec2 9d81d6                     sta $d681,x
   710  8ec5 ca                         dex
   711  8ec6 10f7                       bpl -
   712  8ec8 4cd89f             	jmp sd_readsector
   713                          	
   714                          ;;         ========================
   715                          	
   716                          trap_dos_opendir:
   717                          
   718                                  ;; X = File descriptor
   719                                  ;; Y = Page of memory to write dirent into
   720                          
   721                                  ;; Open the current working directory for iteration.
   722                                  ;;
   723  8ecb 20e693                     jsr dos_opendir
   724  8ece b006                       bcs tdod1
   725                          
   726                                  ;; Something has gone wrong. Assume dos_opendir will
   727                                  ;; have set error code
   728                                  ;;
   729  8ed0 adfabc                     lda dos_error_code
   730  8ed3 4c1e82                     jmp return_from_trap_with_failure
   731                          
   732                          tdod1:
   733                                  ;; Directory opened ok.
   734                                  ;;
   735  8ed6 adf8bc                     lda dos_current_file_descriptor
   736  8ed9 8d40d6                     sta hypervisor_a
   737  8edc 4c1082                     jmp return_from_trap_with_success
   738                          
   739                          ;;         ========================
   740                          
   741                          trap_dos_readdir:
   742                          
   743                                  ;; Read next directory entry from file descriptor $XX
   744                                  ;; Return dirent structure to $YY00
   745                                  ;; in first 32KB of mapped address space
   746                          
   747                                  +Checkpoint "trap_dos_readdir"
   748                          
   749  8edf 20c39f                     jsr sd_map_sectorbuffer
   750                          
   751                                  ;; Get offset to current file descriptor
   752                                  ;; (we can't use X register, as has been clobbered in the jump
   753                                  ;; table dispatch code)
   754                                  ;;
   755  8ee2 ae41d6                     ldx hypervisor_x
   756  8ee5 8ef8bc                     stx dos_current_file_descriptor
   757                          
   758  8ee8 20bb96                     jsr dos_get_file_descriptor_offset
   759  8eeb 901a                       bcc tdrd1
   760  8eed 8df9bc                     sta dos_current_file_descriptor_offset
   761                          
   762  8ef0 201c94                     jsr dos_readdir
   763  8ef3 9012                       bcc tdrd1
   764                          
   765                                  ;; Read the directory entry, now copy it to userland
   766                                  ;;
   767  8ef5 2062ab                     jsr hypervisor_setup_copy_region
   768  8ef8 900d                       bcc tdrd1
   769                          
   770                                  ;; We can now copy the bytes of the dirent to user-space
   771                                  ;;
   772  8efa a056                       ldy #dos_dirent_structure_length-1
   773                          tdrd2:
   774                                  ;; This loop actually copies the whole dirent.
   775                                  ;; XXX dos_dirent_longfilename must be first in the dirent structure
   776  8efc b90fbc                     lda dos_dirent_longfilename,y
   777  8eff 9106                       sta (<hypervisor_userspace_copy_vector),y
   778  8f01 88                         dey
   779  8f02 10f8                       bpl tdrd2
   780                          
   781                                  +Checkpoint "trap_dos_readdir <success>"
   782                          
   783  8f04 4c1082                     jmp return_from_trap_with_success
   784                          
   785                          ;;         ========================
   786                          
   787                          tdrd1:
   788                                  +Checkpoint "trap_dos_readdir <failure>"
   789                          
   790  8f07 adfabc                     lda dos_error_code
   791  8f0a 4c1e82                     jmp return_from_trap_with_failure
   792                          
   793                          ;;         ========================
   794                          
   795                          trap_dos_closedir:
   796  8f0d 4c3b8f                     jmp trap_dos_closefile
   797                          
   798                          ;;         ========================
   799                          
   800                          trap_dos_readfile:
   801  8f10 20e298             	jsr dos_readfile	
   802  8f13 4c628c                     jmp return_from_trap_with_carry_flag
   803                          
   804                          
   805                          trap_dos_cdrootdir:
   806  8f16 ae41d6             	ldx hypervisor_x
   807  8f19 208d92             	jsr dos_cdroot
   808  8f1c 4c628c             	jmp return_from_trap_with_carry_flag
   809                          	
   810                          trap_dos_chdir:
   811                          
   812                                  ;; Opens file in current dirent structure
   813                                  ;; XXX - This means we must preserve the dirent struct when
   814                                  ;; context-switching to avoid a race-condition
   815                          
   816  8f1f 206f93                     jsr dos_chdir
   817  8f22 9003                       bcc tdcd1
   818                          
   819                                  +Checkpoint "trap_dos_chdir <success>"
   820                          
   821  8f24 4c1082                     jmp return_from_trap_with_success
   822                          
   823                          tdcd1:
   824                                  +Checkpoint "trap_dos_chdir <failure>"
   825                          
   826  8f27 adfabc                     lda dos_error_code
   827  8f2a 4c1e82                     jmp return_from_trap_with_failure
   828                          
   829                          ;;         ========================
   830                          
   831                          	
   832                          trap_dos_openfile:
   833                          
   834                                  ;; Opens file in current dirent structure
   835                                  ;; XXX - This means we must preserve the dirent struct when
   836                                  ;; context-switching to avoid a race-condition
   837                          
   838  8f2d 20a193                     jsr dos_openfile
   839  8f30 9003                       bcc tdof1
   840                          
   841                                  +Checkpoint "trap_dos_openfile <success>"
   842                          
   843  8f32 4c1082                     jmp return_from_trap_with_success
   844                          
   845                          tdof1:
   846                                  +Checkpoint "trap_dos_openfile <failure>"
   847                          
   848  8f35 adfabc                     lda dos_error_code
   849  8f38 4c1e82                     jmp return_from_trap_with_failure
   850                          
   851                          ;;         ========================
   852                          
   853                          trap_dos_closefile:
   854                          
   855  8f3b ae41d6                     ldx hypervisor_x
   856  8f3e 8ef8bc                     stx dos_current_file_descriptor
   857                          
   858  8f41 20bb96                     jsr dos_get_file_descriptor_offset
   859  8f44 900b                       bcc tdcf1
   860  8f46 8df9bc                     sta dos_current_file_descriptor_offset
   861  8f49 205b93                     jsr dos_closefile
   862  8f4c 9003                       bcc tdcf1
   863                          
   864                                  +Checkpoint "trap_dos_closefile <success>"
   865                          
   866  8f4e 4c1082                     jmp return_from_trap_with_success
   867                          tdcf1:
   868                                  +Checkpoint "trap_dos_closefile <failure>"
   869                          
   870  8f51 adfabc                     lda dos_error_code
   871  8f54 4c1e82                     jmp return_from_trap_with_failure
   872                          
   873                          ;;         ========================
   874                          
   875                          trap_dos_findfile:
   876                          
   877  8f57 20b593                     jsr dos_findfile
   878  8f5a 4c628c                     jmp return_from_trap_with_carry_flag
   879                          
   880                          ;;         ========================
   881                          
   882                          trap_dos_findfirst:
   883                          
   884  8f5d 20c293                     jsr dos_findfirst
   885  8f60 adf8bc                     lda dos_current_file_descriptor
   886  8f63 8d40d6                     sta hypervisor_a
   887  8f66 4c628c                     jmp return_from_trap_with_carry_flag
   888                          
   889                          ;;         ========================
   890                          
   891                          trap_dos_findnext:
   892                          
   893  8f69 20d293                     jsr dos_findnext
   894  8f6c 4c628c                     jmp return_from_trap_with_carry_flag
   895                          
   896                          ;;         ========================
   897                          
   898                          trap_dos_geterrorcode:
   899                          
   900  8f6f adfabc                     lda dos_error_code
   901  8f72 8d40d6                     sta hypervisor_a
   902                          
   903                          !if DEBUG_HYPPO {
   904                                  tax                                ;; convert .X to char-representation for display
   905                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
   906                                  sty tdgec1+0
   907                                  stx tdgec1+1
   908                          
   909                                  jsr checkpoint
   910                                  !8 0
   911                                  !text "dos_geterrorcode <=$"
   912                          tdgec1: !text "%%>"
   913                                  !8 0
   914                          }
   915                          
   916  8f75 4c1082                     jmp return_from_trap_with_success
   917                          
   918                          ;;         ========================
   919                          
   920                          trap_dos_d81attach0:
   921                          
   922                                  +Checkpoint "trap_dos_d81attach0"
   923                          
   924  8f78 207b99                     jsr dos_d81attach0
   925  8f7b 4c628c                     jmp return_from_trap_with_carry_flag
   926                          
   927                          ;;         ========================
   928                          
   929                          trap_dos_d81attach1:
   930                          
   931                                  +Checkpoint "trap_dos_d81attach1"
   932                          
   933  8f7e 20e199                     jsr dos_d81attach1
   934  8f81 4c628c                     jmp return_from_trap_with_carry_flag
   935                          
   936                          ;;         ========================
   937                          
   938                          trap_dos_d81detach:
   939                          
   940  8f84 206a99                     jsr dos_d81detach
   941                          
   942  8f87 4c1082                     jmp return_from_trap_with_success
   943                          
   944                          ;;         ========================
   945                          
   946                          trap_dos_d81write_en:
   947                          
   948  8f8a 20a38f                     jsr dos_d81write_en
   949  8f8d 4c628c                     jmp return_from_trap_with_carry_flag
   950                          
   951                          ;;         ========================
   952                          
   953                          trap_dos_get_proc_desc:
   954  8f90 2062ab                     jsr hypervisor_setup_copy_region
   955  8f93 900b                       bcc @bad
   956  8f95 a000                       ldy #0
   957                          @copyloop:
   958  8f97 b900bd                     lda currenttask_block,y
   959  8f9a 9106                       sta (<hypervisor_userspace_copy_vector),y
   960  8f9c c8                         iny
   961  8f9d d0f8                       bne @copyloop
   962  8f9f 38                         sec
   963                          @bad:
   964  8fa0 4c628c                     jmp return_from_trap_with_carry_flag
   965                          
   966                          dos_d81write_en:
   967  8fa3 ad8bd6                     lda $d68b
   968  8fa6 2903                       and #$03
   969  8fa8 c903                       cmp #$03
   970  8faa d00c                       bne td81we1
   971  8fac 0904                       ora #$04
   972  8fae 8d8bd6                     sta $d68b
   973                          
   974                                  ;; Mark disk image write-enabled in proces descriptor
   975  8fb1 ad11bd                     lda currenttask_d81_image0_flags
   976  8fb4 0904                       ora #d81_image_flag_write_en
   977                          
   978  8fb6 38                         sec
   979  8fb7 60                         rts
   980                          
   981                          td81we1:
   982                                  ;; No disk image mounted
   983                                  ;;
   984                          
   985                                  +Checkpoint "dos_d81writ_en-FAIL"
   986                          
   987  8fb8 a980                       lda #dos_errorcode_no_such_disk
   988  8fba 8dfabc                     sta dos_error_code
   989  8fbd 18                         clc
   990  8fbe 60                         rts
   991                          
   992                          ;;         ========================
   993                          
   994                          ;; BG: the following are placeholders for the future development
   995                          
   996                          trap_dos_getdisksize:
   997                          trap_dos_getcwd:
   998                          trap_dos_mkdir:
   999                          trap_dos_rmdir:
  1000                          trap_dos_writefile:
  1001                          trap_dos_seekfile:
  1002                          trap_dos_rmfile:
  1003                          trap_dos_fstat:
  1004                          trap_dos_rename:
  1005                          trap_dos_filedate:
  1006                          trap_dos_gettasklist:
  1007                          trap_dos_sendmessage:
  1008                          trap_dos_receivemessage:
  1009                          trap_dos_writeintotask:
  1010                          trap_dos_readoutoftask:
  1011                          trap_dos_terminateothertask:
  1012                          trap_dos_create_task_native:
  1013                          trap_dos_load_into_task:
  1014                          trap_dos_create_task_c64:
  1015                          trap_dos_create_task_c65:
  1016                          trap_dos_exit_and_switch_to_task:
  1017                          trap_dos_switch_to_task:
  1018                          trap_dos_exit_task:
  1019                          
  1020  8fbf 4c2f82                     jmp invalid_subfunction;;
  1021                          
  1022                          ;;         ========================
  1023                          
  1024                          ;; ======================================================================================
  1025                          ;; ======================================================================================
  1026                          ;; ======================================================================================
  1027                          
  1028                          ;; Clear all file descriptors.
  1029                          ;; This just consists of setting the drive number to $ff,
  1030                          ;; which indicates "no such drive"
  1031                          ;; Drive number field is first byte of file descriptor for convenience
  1032                          
  1033                          dos_clear_filedescriptors:
  1034                          
  1035                                  ;; XXX - This doesn't close the underlying file descriptors!
  1036                                  ;;
  1037  8fc2 a9ff                       lda #$ff
  1038  8fc4 8d80bd                     sta currenttask_filedescriptor0
  1039  8fc7 8da0bd                     sta currenttask_filedescriptor1
  1040  8fca 8dc0bd                     sta currenttask_filedescriptor2
  1041  8fcd 8de0bd                     sta currenttask_filedescriptor3
  1042                          
  1043                          	;; XXX - Doesn't flush any files open for write
  1044  8fd0 8db8bc                     sta dos_file_descriptors
  1045  8fd3 8dc8bc                     sta dos_file_descriptors+$10
  1046  8fd6 8dd8bc                     sta dos_file_descriptors+$20
  1047  8fd9 8de8bc                     sta dos_file_descriptors+$30
  1048                          	
  1049  8fdc 38                         sec
  1050  8fdd 60                         rts
  1051                          
  1052                          ;;         ========================
  1053                          
  1054                          ;; Read partition table from SD card.
  1055                          ;;
  1056                          ;; Add all FAT32 partitions to our list of known disks.
  1057                          ;;
  1058                          ;; This routine assumes that the SD card has been reset and is ready to
  1059                          ;; service requests.
  1060                          ;;
  1061                          ;; XXX - We don't support extended partition tables! Only the old-fashion
  1062                          ;; 4 DOS partitions.  We might get excited and add support for them later
  1063                          ;;
  1064                          dos_read_partitiontable:
  1065                          
  1066                                  ;; clear error code
  1067                                  ;;
  1068  8fde a900                       lda #0
  1069  8fe0 8dfabc                     sta dos_error_code
  1070                          
  1071                                  ;; Clear the list of known disks
  1072                                  ;;
  1073  8fe3 205190                     jsr dos_initialise_disklist
  1074                          
  1075  8fe6 203a90                     jsr dos_read_mbr
  1076  8fe9 903e                       bcc l_drpt_fail
  1077                          
  1078                                  ;; Make the sector buffer visible
  1079                                  ;;
  1080  8feb 20c39f                     jsr sd_map_sectorbuffer
  1081                          
  1082  8fee a902                       lda #dos_errorcode_bad_signature
  1083  8ff0 8dfabc                     sta dos_error_code
  1084                          
  1085                                  ;; check for $55, $AA MBR signature
  1086                                  ;;
  1087  8ff3 adfedf                     lda sd_sectorbuffer+$1FE
  1088  8ff6 c955                       cmp #$55
  1089  8ff8 d02f                       bne l_drpt_fail
  1090  8ffa adffdf                     lda sd_sectorbuffer+$1FF
  1091  8ffd c9aa                       cmp #$AA
  1092  8fff d028                       bne l_drpt_fail
  1093                          
  1094                                  ;; yes, $55AA MBR signature was found
  1095                          
  1096                                  +Checkpoint "Found $55, $AA at $1FE on MBR"
  1097                          
  1098                                  ;; Partitions start at offsets $1BE, $1CE, $1DE, $1EE
  1099                                  ;; so consider each in turn.  Opening the partition causes other sectors to
  1100                                  ;; be read, so we must re-read the MBR between each
  1101                          
  1102                                  ;; get pointer to second half of sector buffer so that we can access the
  1103                                  ;; partition entries as we see fit.
  1104                                  ;;
  1105                          
  1106  9001 a9be                       lda #<(sd_sectorbuffer+$1BE)
  1107  9003 8500                       sta <dos_scratch_vector
  1108  9005 a9df                       lda #>(sd_sectorbuffer+$1BE)
  1109  9007 8501                       sta <(dos_scratch_vector+1)
  1110                                  +Checkpoint "=== Checking Partition #1 at $01BE"
  1111  9009 205790                     jsr dos_consider_partition_entry
  1112                          
  1113  900c 203a90                     jsr dos_read_mbr
  1114  900f 9018                       bcc l_drpt_fail
  1115  9011 a9ce                       lda #<(sd_sectorbuffer+$1CE)
  1116  9013 8500                       sta <dos_scratch_vector
  1117                                  +Checkpoint "=== Checking Partition #2 at $01CE"
  1118  9015 205790                     jsr dos_consider_partition_entry
  1119                          
  1120  9018 203a90                     jsr dos_read_mbr
  1121  901b 900c                       bcc l_drpt_fail
  1122  901d a9de                       lda #<(sd_sectorbuffer+$1DE)
  1123  901f 8500                       sta <dos_scratch_vector
  1124                                  +Checkpoint "=== Checking Partition #3 at $01DE"
  1125  9021 205790                     jsr dos_consider_partition_entry
  1126                          
  1127  9024 203a90                     jsr dos_read_mbr
  1128  9027 b003                       bcs +
  1129                          l_drpt_fail:
  1130  9029 4cd590                     jmp drpt_fail
  1131  902c a9ee               +       lda #<(sd_sectorbuffer+$1EE)
  1132  902e 8500                       sta <dos_scratch_vector
  1133                                  +Checkpoint "=== Checking Partition #4 at $01EE"
  1134  9030 205790                     jsr dos_consider_partition_entry
  1135                          
  1136  9033 a900                       lda #0
  1137  9035 8dfabc                     sta dos_error_code
  1138  9038 38                         sec
  1139  9039 60                         rts
  1140                          
  1141                          ;;         ========================
  1142                          
  1143                          dos_read_mbr:
  1144                          
  1145                                  ;; Offset zero on disk
  1146                                  ;;
  1147                          
  1148  903a a900                       lda #0
  1149  903c 8d81d6                     sta sd_address_byte0
  1150  903f 8d82d6                     sta sd_address_byte1
  1151  9042 8d83d6                     sta sd_address_byte2
  1152  9045 8d84d6                     sta sd_address_byte3
  1153                          
  1154                                  +Checkpoint "Reading MBR @ 0x00000000"
  1155                          
  1156                                  ;; Read sector
  1157                                  ;;
  1158  9048 20d89f                     jsr sd_readsector
  1159  904b b003                       bcs +
  1160  904d 4cd590                     jmp drpt_fail
  1161  9050 60                 +       rts
  1162                          
  1163                          ;;         ========================
  1164                          
  1165                          dos_initialise_disklist:
  1166                          
  1167  9051 a900                       lda #0
  1168  9053 8d01bc                     sta dos_disk_count
  1169  9056 60                         rts
  1170                          
  1171                          ;;         ========================
  1172                          
  1173                          dos_consider_partition_entry:
  1174                          	
  1175  9057 a900                       lda #$00
  1176  9059 8dfabc                     sta dos_error_code
  1177                          
  1178                                  ;; Offset within partition table entry of partition type
  1179                                  ;;
  1180                                  ;; BG: make this a hash-define
  1181                                  ;;
  1182  905c a004                       ldy #$04
  1183                          
  1184                                  ;; Get partition type byte
  1185                                  ;;
  1186  905e b100                       lda (<dos_scratch_vector),y
  1187                          
  1188                                  ;; We like FAT32 partitions, whether LBA or CHS addressed, although we actually
  1189                                  ;; use LBA addressing.  XXX - Can this cause problems for CHS partitions?
  1190                                  ;; (SD cards which must really use LBA, can still show up with CHS partitions!
  1191                                  ;;  this is really annoying.)
  1192                                  ;;
  1193  9060 c90c                       cmp #constant_partition_type_fat32_lba        ;; compare with 0x0C
  1194  9062 f02c                       beq partitionisinteresting_lba
  1195                          
  1196  9064 c90b                       cmp #constant_partition_type_fat32_chs        ;; compare with 0x0B
  1197  9066 f02b                       beq partitionisinteresting_chs
  1198                          
  1199  9068 c941                       cmp #constant_partition_type_megea65_sys ;; compare with 0x41
  1200  906a f008                       beq partitionisinteresting_mega65sys
  1201                          
  1202  906c a901                       lda #dos_errorcode_partition_not_interesting
  1203  906e 8dfabc                     sta dos_error_code
  1204  9071 4cd390                     jmp partitionisnotinteresting
  1205                          
  1206                          ;;         ========================
  1207                          
  1208                          partitionisinteresting_mega65sys:
  1209                          
  1210                                  +Checkpoint "MEGA65 System Partition (type=0x41)"
  1211                          
  1212                                  ;; Only one system partition
  1213  9074 adfcbc                     lda syspart_present
  1214  9077 f003                       beq +
  1215  9079 4cd590                     jmp partitionerror
  1216                          +
  1217                                  ;; Store start and length of System partition
  1218                                  ;; (These are the first two fields of the syspart structure
  1219                                  ;;  to facilitate a simple copy here)
  1220  907c a008                       ldy #$08
  1221  907e a200                       ldx #$00
  1222                          
  1223  9080 b100               spc1:   lda (<dos_scratch_vector),y
  1224  9082 9dc0bb                     sta syspart_structure,x
  1225  9085 e8                         inx
  1226  9086 c8                         iny
  1227  9087 c010                       cpy #$10
  1228  9089 d0f5                       bne spc1
  1229                          
  1230  908b 205882                     jsr syspart_open
  1231  908e 38                         sec
  1232  908f 60                         rts
  1233                          
  1234                          partitionisinteresting_lba:
  1235                          
  1236                                  +Checkpoint "Partn has fat32_lba (type=0x0c)"
  1237                          
  1238  9090 4c9690                     jmp partitionisinteresting
  1239                          
  1240                          partitionisinteresting_chs:
  1241                          
  1242                                  +Checkpoint "WARN:Partn has fat32_chs (type=0x0b)"
  1243                          
  1244  9093 4c9690                     jmp partitionisinteresting
  1245                          
  1246                          ;;         ========================
  1247                          
  1248                          partitionisinteresting:
  1249                          
  1250                                  ;; Make sure we have a spare disk slot
  1251  9096 ad01bc                     lda dos_disk_count
  1252  9099 c906                       cmp #dos_max_disks
  1253  909b d003                       bne +
  1254  909d 4cd590                     jmp partitionerror
  1255                          +
  1256                                  ;; Partition is FAT32 (either 0B or 0C), so add it to the list
  1257                          
  1258                                  ;; Disk structures in dos_disk_table are 32 bytes long, so shift count left
  1259                                  ;; 5 times to get offset in dos disk list table
  1260                                  ;;
  1261                                  ;; initially, dos_disk_count=00 so shifting results in =00
  1262                                  ;;
  1263  90a0 ad01bc                     lda dos_disk_count
  1264  90a3 0a                         asl
  1265  90a4 0a                         asl
  1266  90a5 0a                         asl
  1267  90a6 0a                         asl
  1268  90a7 0a                         asl
  1269  90a8 aa                         tax
  1270                          
  1271                                  ;; Copy relevant fields into place
  1272                                  ;; These are start of partition and length of partition (both in sectors)
  1273                                  ;; XXX - This requires that our dos_disk_table has these two fields together
  1274                                  ;; at the start of the structure.
  1275                                  ;;
  1276  90a9 a008                       ldy #$08        ;; partition_lba_begin (4 bytes)
  1277                          
  1278  90ab b100               dcpe1:  lda (<dos_scratch_vector),y
  1279  90ad 9d00bb                     sta dos_disk_table,x
  1280  90b0 e8                         inx
  1281  90b1 c8                         iny
  1282  90b2 c010                       cpy #$10        ;; partition_num_sectors (4 bytes)
  1283  90b4 d0f5                       bne dcpe1
  1284                          
  1285                                  ;; Examine the internals of the partition to get the remaining fields.
  1286                                  ;; At this point we no longer use the contents of the MBR
  1287                                  ;;
  1288                          
  1289  90b6 20d790                     jsr dos_disk_openpartition
  1290  90b9 901a                       bcc partitionerror
  1291                          
  1292                          !if DEBUG_HYPPO {
  1293                                  jsr dump_disk_table
  1294                          }
  1295                          
  1296                                  ;; Check if partition is bootable (or the only partition)
  1297                                  ;; If so, make the partition the default disk
  1298                                  ;;
  1299                                  ;; BG, we should examine all four partitions before setting the default disk
  1300                                  ;;
  1301  90bb ad01bc                     lda dos_disk_count
  1302  90be f006                       beq makethispartitionthedefault
  1303  90c0 a000                       ldy #$00
  1304  90c2 b100                       lda (<dos_scratch_vector),y
  1305  90c4 1008                       bpl dontmakethispartitionthedefault
  1306                          
  1307                          
  1308                          makethispartitionthedefault:
  1309  90c6 ad01bc                     lda dos_disk_count
  1310  90c9 8d02bc                     sta dos_default_disk
  1311                          
  1312                          !if DEBUG_HYPPO {
  1313                                  ;; print out this message to Checkpoint
  1314                                  ;;
  1315                          
  1316                                  tax                                ;; convert .X to char-representation for display
  1317                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  1318                                  sty mtptd
  1319                                  stx mtptd+1
  1320                          
  1321                                  jsr checkpoint
  1322                                  !8 0
  1323                                  !text "dos_default_disk = "
  1324                          mtptd:  !text "xx"
  1325                                  !8 0
  1326                          
  1327                          ;; jsr dump_disk_table
  1328                          }
  1329                          
  1330                                  ;; return OK
  1331                                  ;;
  1332  90cc 38                         sec
  1333  90cd 60                         rts
  1334                          
  1335                          ;;         ========================
  1336                          
  1337                          dontmakethispartitionthedefault:
  1338                          
  1339  90ce ae01bc                     ldx dos_disk_count
  1340                          
  1341                          !if DEBUG_HYPPO {
  1342                                  ;; print out this message to Checkpoint
  1343                                  ;;
  1344                          
  1345                                                                  ;; convert .X to char-representation for display
  1346                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  1347                                  stx mtptd2
  1348                          
  1349                                  jsr checkpoint
  1350                                  !8 0
  1351                                  !text "Part#"
  1352                          mtptd2: !text "x NOT set to the default_disk"
  1353                                  !8 0
  1354                          
  1355                          ;; jsr dump_disk_table
  1356                          }
  1357                          
  1358                                  ;; return OK
  1359                                  ;;
  1360                          
  1361  90d1 38                         sec
  1362  90d2 60                         rts
  1363                          
  1364                          ;;         ========================
  1365                          
  1366                          partitionisnotinteresting:
  1367                          
  1368                                  ;; return OK
  1369                                  ;;
  1370                          
  1371                                  +Checkpoint "Partition not interesting"
  1372                          
  1373  90d3 38                         sec
  1374  90d4 60                         rts
  1375                          
  1376                          ;;         ========================
  1377                          
  1378                          drpt_fail:
  1379                          
  1380                                  ;; error code will already be set
  1381                          
  1382                          partitionerror:
  1383                          
  1384                                  ;; return ERROR
  1385                          
  1386                          !if DEBUG_HYPPO {
  1387                                  ldx dos_error_code                ;; convert .X to char-representation for display
  1388                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  1389                                  sty perr
  1390                                  stx perr+1
  1391                          
  1392                                  jsr checkpoint
  1393                                  !8 0
  1394                                  !text "partitionerror="
  1395                          perr:   !text "xx"
  1396                                  !8 0
  1397                          }
  1398                          
  1399  90d5 18                         clc
  1400  90d6 60                         rts
  1401                          
  1402                          dos_disk_openpartition:
  1403                          
  1404                                  +Checkpoint "dos_disk_openpartition: (examine Vol ID)"
  1405                          
  1406                                  ;; A contains the disk number we are trying to open.
  1407                                  ;;
  1408  90d7 a900                       lda #$00
  1409  90d9 8dfabc                     sta dos_error_code
  1410                          
  1411                                  ;; Load first sector of file system and parse.
  1412                                  ;; This is the Volume ID pointed to by the PartitionTable in the MBR
  1413                          
  1414                                  ;; Get offset of disk entry in our disk table structure
  1415                                  ;;
  1416  90dc ad01bc                     lda dos_disk_count
  1417  90df 0a                         asl
  1418  90e0 0a                         asl
  1419  90e1 0a                         asl
  1420  90e2 0a                         asl
  1421  90e3 0a                         asl
  1422  90e4 8d04bc                     sta dos_disk_table_offset
  1423                          
  1424                                  ;; Now pull the start sector from the structure and get ready to request
  1425                                  ;; that structure from the SD card.
  1426                                  ;;
  1427  90e7 0900                       ora #fs_start_sector        ;; OR with 00 does nothing, but this is the standard
  1428  90e9 a8                         tay
  1429  90ea a200                       ldx #$00
  1430                          
  1431  90ec b900bb             ddop1:  lda dos_disk_table,y
  1432  90ef 9d81d6                     sta sd_address_byte0,x
  1433  90f2 c8                         iny
  1434  90f3 e8                         inx
  1435  90f4 e004                       cpx #$04
  1436  90f6 d0f4                       bne ddop1
  1437                          
  1438                          !if DEBUG_HYPPO {
  1439                          jsr dumpsectoraddress        ;; debugging
  1440                          }
  1441                          
  1442  90f8 20d89f                     jsr sd_readsector
  1443  90fb 90d8                       bcc partitionerror
  1444                          
  1445                                  ;; We now have the sector, so parse.
  1446                          
  1447  90fd 20c39f                     jsr sd_map_sectorbuffer
  1448                          
  1449                          ;;         ========================
  1450                          
  1451                                  ;; Check for 55/AA singature (again, for the Vol-ID of this partition)
  1452                                  ;;
  1453                          
  1454  9100 a902                       lda #dos_errorcode_bad_signature
  1455  9102 8dfabc                     sta dos_error_code
  1456                          
  1457  9105 adfedf                     lda sd_sectorbuffer+$1FE
  1458  9108 c955                       cmp #$55
  1459  910a f003                       beq ddop1a
  1460  910c 4cd590                     jmp partitionerror
  1461                          ddop1a:
  1462  910f adffdf                     lda sd_sectorbuffer+$1FF
  1463  9112 c9aa                       cmp #$AA
  1464  9114 f003                       beq ddop1b
  1465  9116 4cd590                     jmp partitionerror
  1466                          ddop1b:
  1467                                  +Checkpoint "Partn has $55, $AA GOOD"
  1468                          
  1469                                  ;; Start populating fields
  1470                          
  1471                          ;;         BG assumes this is all correct...
  1472                          
  1473                          ;;         ========================
  1474                          
  1475                                  ;; Filter out obviously FAT16/FAT12 file systems
  1476                                  ;;
  1477  9119 a903                       lda #dos_errorcode_is_small_fat
  1478  911b 8dfabc                     sta dos_error_code
  1479                                  ;;
  1480                                  ;; BG i think we dont need to check this for minimal operation
  1481                                  ;;
  1482                                  ;; for fat32, the 11'th entry is unused, http:;;www.easeus.com/resource/fat32-disk-structure.htm
  1483                                  ;;
  1484  911e ad11de                     lda sd_sectorbuffer+$11        ;; this is NOT the MBSyte of the number of FATs
  1485  9121 d0b2                       bne partitionerror
  1486                          
  1487                          ;;         ========================
  1488                          
  1489                                  ;; get # copies of fat
  1490                                  ;;
  1491  9123 ad04bc                     lda dos_disk_table_offset
  1492  9126 0917                       ora #fs_fat32_fat_copies        ;; is $17
  1493  9128 a8                         tay
  1494  9129 ad10de                     lda sd_sectorbuffer+$10        ;; should be 2
  1495  912c 9900bb                     sta dos_disk_table,y
  1496                          
  1497                          ;;         ========================
  1498                          
  1499                                  ;; With root directory entries = 0, the reserved sector count
  1500                                  ;; is the number of reserved sectors, plus (copies of fat) *
  1501                                  ;; (sectors in one copy of the fat).
  1502                                  ;; the first FAT begins immediately after the reserved sectors
  1503                          
  1504                                  ;; Determine system sector count
  1505                                  ;; (= reserved sectors + fat_count * fat_sectors)
  1506                                  ;; $20 + $EE5 + $EE5 = $1DEA
  1507                                  ;; plus partition offset = $81 = $1E6B
  1508                                  ;; partition length = $3BAF7F
  1509                                  ;; $08 sectors / cluster
  1510                                  ;; so data sectors in partition = $3BAF7F - $1DEA = $3B9195
  1511                                  ;; = $77232 clusters
  1512                          
  1513                                  ;; BG does not like the above reasoning, ie fixed number of reserved sectors.
  1514                          
  1515                                  ;; Reserved sector field on disk is only 2 bytes!
  1516                                  ;;
  1517  912f ad04bc                     lda dos_disk_table_offset
  1518  9132 090d                       ora #fs_fat32_system_sectors        ;; is $0D
  1519  9134 a8                         tay
  1520  9135 a200                       ldx #$00
  1521                          
  1522  9137 bd0ede             ddop10: lda sd_sectorbuffer+$0E,x
  1523  913a 9900bb                     sta dos_disk_table,y
  1524  913d c8                         iny
  1525  913e e8                         inx
  1526  913f e002                       cpx #$02
  1527  9141 d0f4                       bne ddop10
  1528                          
  1529                          ;;         ========================
  1530                          
  1531                                  ;; Store length of one copy of the FAT
  1532                                  ;;
  1533  9143 ad04bc                     lda dos_disk_table_offset
  1534  9146 0909                       ora #fs_fat32_length_of_fat        ;; is $09
  1535  9148 a8                         tay
  1536  9149 a200                       ldx #$00
  1537                          
  1538  914b bd24de             ddop11: lda sd_sectorbuffer+$24,x        ;; sectors_per_fat
  1539  914e 9900bb                     sta dos_disk_table,y
  1540  9151 c8                         iny
  1541  9152 e8                         inx
  1542  9153 e004                       cpx #$04
  1543  9155 d0f4                       bne ddop11
  1544                          
  1545                          ;;         ========================
  1546                          
  1547                                  ;; Get number of reserved clusters.  We only allow upto 255 reserved
  1548                                  ;; clusters, so report an error if the upper three bytes are not zero
  1549                                  ;;
  1550                                  ;; BG: why only 255 reserved clusters? and isnt it reserved sectors instead?
  1551                                  ;; and seems to be looking at the root_dir_first_cluster
  1552                                  ;;
  1553  9157 a904                       lda #dos_errorcode_too_many_reserved_clusters
  1554  9159 8dfabc                     sta dos_error_code
  1555                          
  1556  915c ad2dde                     lda sd_sectorbuffer+$2C+1
  1557  915f 0d2ede                     ora sd_sectorbuffer+$2C+2
  1558  9162 0d2fde                     ora sd_sectorbuffer+$2C+3
  1559                          
  1560                                  ;; XXX - 16 bit BNE should be fine here! Why doesn't it work?
  1561                                  ;;         bne partitionerror
  1562                          
  1563  9165 f003                       beq ddop11ok
  1564  9167 4cd590                     jmp partitionerror
  1565                          
  1566                          ;;         ========================
  1567                          
  1568                          ddop11ok:
  1569                          
  1570                                  ;; <64K reserved clusters, so file system passes this test -- just copy number
  1571                                  ;;
  1572                                  ;; BG does not agree with the logic, of <64k reservedclusters to passes
  1573                                  ;; BG the code below could be changed to be same as lda,ora,tay
  1574                                  ;;
  1575                                  ;; BG, so by design, we reject any Vol_ID that has
  1576                                  ;; RootDirFirstCluster[3..0] not equal to $00000002
  1577                                  ;;
  1578  916a ac04bc                     ldy dos_disk_table_offset
  1579  916d ad2cde                     lda sd_sectorbuffer+$2C        ;; 2c is the ClusterNumberOfFirstRootDir
  1580  9170 990fbb                     sta dos_disk_table + fs_fat32_reserved_clusters,y
  1581                          
  1582                          ;; Checkpoint("dos_disk_table-1")
  1583                          ;; jsr dump_disk_table        ; debugging
  1584                          
  1585                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00 = (fs_start_sector),                       (fs_sector_count)
  1586                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02 = type, (sectorsPerFat),(reservedSectors),(reservedClusters)
  1587                          ;; dos_disk_table[10-17] = 00,00,00,00,00,00,00,02 = x..x                                ,(fs_fat32_fat_copies)
  1588                          ;; dos_disk_table[18-1F] = 00,00,00,00,xx,xx,xx,xx
  1589                          
  1590                          ;;         ========================
  1591                          
  1592                                  ;; Now work out the sector of cluster 0, by adding:
  1593                                  ;;   fs_fat32_system_sectors
  1594                                  ;; + the length of each FAT
  1595                                  ;; + start of partition,
  1596                                  ;; and store this result in dos_disk_table[18..1B]
  1597                                  ;;
  1598                                  ;; For efficiency, we pull the fields we need out of the sector buffer,
  1599                                  ;; instead of working out their offsets in the dos_disk_table structure.
  1600                                  ;; BG disagree, we know the offsets of the fields in dos_disk_table
  1601                          
  1602                                  ;; Start with fs_fat32_system_sectors (which is 16 bits), then pad MSBs with zero
  1603                                  ;;
  1604  9173 ad04bc                     lda dos_disk_table_offset
  1605  9176 090d                       ora #fs_fat32_system_sectors        ;; is $0D
  1606  9178 a8                         tay
  1607  9179 ad04bc                     lda dos_disk_table_offset
  1608  917c 0918                       ora #fs_fat32_cluster0_sector        ;; is $18
  1609  917e aa                         tax
  1610  917f a302                       ldz #$02
  1611                          
  1612  9181 b900bb             ddop2:  lda dos_disk_table,y
  1613  9184 9d00bb                     sta dos_disk_table,x
  1614  9187 c8                         iny
  1615  9188 e8                         inx
  1616  9189 3b                         dez
  1617  918a d0f5                       bne ddop2
  1618                          
  1619                                  ;; clear top 16 bits of cluster0_sector (dos_disk_table[1A,1B])
  1620                                  ;;
  1621                                  ;; BG: why tza, just do lda#$00
  1622  918c 6b                         tza
  1623  918d 9d00bb                     sta dos_disk_table+0,x
  1624  9190 9d01bb                     sta dos_disk_table+1,x
  1625                          
  1626                          ;; Checkpoint("dos_disk_table-2")
  1627                          ;; jsr dump_disk_table        ; debugging
  1628                          
  1629                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1630                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1631                          ;; dos_disk_table[10-17] = 00,00,00,00,00,00,00,02
  1632                          ;; dos_disk_table[18-1F] = 38,02,00,00,xx,xx,xx,xx -> $00000238
  1633                          
  1634                          
  1635                          ;;         ========================
  1636                          
  1637                                  ;; Now add length of fat for each copy of the fat
  1638                                  ;;
  1639  9193 a905                       lda #dos_errorcode_not_two_fats
  1640  9195 8dfabc                     sta dos_error_code
  1641                          
  1642                                  ;; BG #FATs should be sourced from dos_disk_table[17], not from buffer+$10
  1643                          
  1644  9198 ab10de                     ldz sd_sectorbuffer+$10         ;; # of FAT copies
  1645  919b f004                       beq l_partitionerror            ;; There must be at least one copy of the FAT!
  1646  919d c202                       cpz #2
  1647  919f f003                       beq ddop_addnextfatsectors
  1648                          l_partitionerror:
  1649  91a1 4cd590                     jmp partitionerror
  1650                          
  1651                          ddop_addnextfatsectors:
  1652  91a4 ad04bc                     lda dos_disk_table_offset
  1653  91a7 0918                       ora #fs_fat32_cluster0_sector   ;; is $18
  1654  91a9 a8                         tay
  1655  91aa a200                       ldx #$00
  1656  91ac 18                         clc
  1657  91ad 08                         php                             ;; push processor-status (to remember the carry-flag)
  1658                          
  1659  91ae 28                 ddop12: plp                             ;; pull processor-status
  1660  91af b900bb                     lda dos_disk_table,y            ;; cluster0_sector
  1661  91b2 7d24de                     adc sd_sectorbuffer+$24,x       ;; sectors per fat ;BG should load from dos_disk_table[09]
  1662  91b5 9900bb                     sta dos_disk_table,y            ;; cluster0_sector
  1663  91b8 08                         php
  1664  91b9 c8                         iny
  1665  91ba e8                         inx
  1666  91bb e004                       cpx #$04
  1667  91bd d0ef                       bne ddop12
  1668                          
  1669  91bf 28                         plp
  1670                                  ;;
  1671                                  ;; as Z was initially 2 (#FATs), we do this loop twice
  1672                                  ;; resulting in 2x the sectorsPerFat added to "reservedSectors".
  1673  91c0 3b                         dez
  1674  91c1 d0e1                       bne ddop_addnextfatsectors
  1675                          
  1676                          ;; Checkpoint("dos_disk_table-3")
  1677                          ;; jsr dump_disk_table        ; debugging
  1678                          
  1679                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1680                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1681                          ;; dos_disk_table[10-17] = 00,00,00,00,00,00,00,02
  1682                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx -> $00000238 + ($000003e6 + $000003e6) = $00000A04
  1683                          
  1684                          ;; BG does not agree with the calculations below, why do we need to calculate it this way?
  1685                          
  1686                                  ;; Next, we temporarily need the number of data sectors, so that we can work
  1687                                  ;; out the number of clusters in the file system.
  1688                                  ;; This is the total number of sectors in the partition, minus the number of
  1689                                  ;; reserved sectors.
  1690                          
  1691                                  ;; Subtract (cluster 0 sector = 32 bits) from
  1692                                  ;; (length of filesystem in sectors = 32 bits)
  1693                          
  1694  91c3 ad04bc                     lda dos_disk_table_offset
  1695  91c6 0918                       ora #fs_fat32_cluster0_sector   ;; is $18
  1696  91c8 aa                         tax
  1697  91c9 ad04bc                     lda dos_disk_table_offset
  1698  91cc 0912                       ora #fs_fat32_cluster_count     ;; is $12
  1699  91ce a8                         tay
  1700  91cf 38                         sec
  1701  91d0 ad20de                     lda sd_sectorbuffer+$20+0     ;; from FAT spec, this is number of sectors in partition
  1702  91d3 fd00bb                     sbc dos_disk_table+0,x        ;; x=$18 initially
  1703  91d6 9900bb                     sta dos_disk_table+0,y        ;; y=$12 initially
  1704  91d9 ad21de                     lda sd_sectorbuffer+$20+1
  1705  91dc fd01bb                     sbc dos_disk_table+1,x
  1706  91df 9901bb                     sta dos_disk_table+1,y
  1707  91e2 ad22de                     lda sd_sectorbuffer+$20+2
  1708  91e5 fd02bb                     sbc dos_disk_table+2,x
  1709  91e8 9902bb                     sta dos_disk_table+2,y
  1710  91eb ad23de                     lda sd_sectorbuffer+$20+3
  1711  91ee fd03bb                     sbc dos_disk_table+3,x
  1712  91f1 9903bb                     sta dos_disk_table+3,y
  1713                          
  1714                          ;;         ========================
  1715                          
  1716                          get_sec_per_cluster:
  1717                                  ;; Get sectors per cluster (and store in dos_disk_table entry)
  1718                                  ;; (this gets destoryed below, so we have to re-read it again after)
  1719                                  ;;
  1720  91f4 ad04bc                     lda dos_disk_table_offset
  1721  91f7 0916                       ora #fs_fat32_sectors_per_cluster        ;; is $16
  1722  91f9 a8                         tay
  1723  91fa ad0dde                     lda sd_sectorbuffer+$0D
  1724  91fd 9900bb                     sta dos_disk_table,y
  1725                          
  1726                          ;; Checkpoint("dos_disk_table-4")
  1727                          ;; jsr dump_disk_table        ; debugging
  1728                          
  1729                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1730                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1731                          ;; dos_disk_table[10-17] = 00,00,FC,95,0F,00,08,02 -> new data appears
  1732                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1733                          
  1734                          
  1735                          ;;         ========================
  1736                          
  1737                                  ;; Now divide number of sectors available for clusters by the number of
  1738                                  ;; sectors per cluster to obtain the number of actual clusters in the file
  1739                                  ;; system.  Since clusters must contain a power-of-two number of sectors,
  1740                                  ;; we can implement the division using a simple shift.
  1741                          
  1742                                  ;; copy number of sectors into number of sectors ready for shifting down
  1743                          
  1744                                  ;; Put number of sectors per cluster into Z, and don't shift if there is only
  1745                                  ;; one sector per cluster.
  1746                                  ;;
  1747  9200 ad0dde                     lda sd_sectorbuffer+$0D            ;; because of the checkpoint message above
  1748  9203 4b                         taz                                ;; why store .A in .Z anyway
  1749                          
  1750  9204 29fe                       and #$fe        ;; #%1111.1110
  1751  9206 f01e                       beq ddop_gotclustercount
  1752                          
  1753                          ddop14:
  1754                                  ;; Divide cluster count by two.  This is a 32-bit value, so we have to use
  1755                                  ;; ROR to do the shift, and propagate the carry bits between the bytes.
  1756                                  ;; This also entails doing it from the last byte, backwards.
  1757                          
  1758                                  ;; Get offset of start of (sectors_per_cluster) field
  1759                                  ;;
  1760  9208 ad04bc                     lda dos_disk_table_offset
  1761  920b 0912                       ora #fs_fat32_cluster_count        ;; is $12
  1762                          
  1763                                  ;; get offset of last byte in this field
  1764                                  ;;
  1765  920d 18                         clc
  1766  920e 6903                       adc #$03
  1767  9210 a8                         tay
  1768                          
  1769  9211 a203                       ldx #$03
  1770  9213 18                         clc
  1771                          
  1772  9214 b900bb             ddop15: lda dos_disk_table,y
  1773  9217 6a                         ror
  1774  9218 9900bb                     sta dos_disk_table,y
  1775  921b 88                         dey
  1776  921c ca                         dex
  1777  921d 10f5                       bpl ddop15
  1778                          
  1779  921f 6b                         tza
  1780  9220 4a                         lsr
  1781  9221 4b                         taz
  1782  9222 29fe                       and #$fe
  1783  9224 d0e2                       bne ddop14
  1784                          
  1785                          ddop_gotclustercount:
  1786                          
  1787                          ;; Checkpoint("dos_disk_table-5")
  1788                          ;; jsr dump_disk_table        ; debugging
  1789                          
  1790                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1791                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1792                          ;; dos_disk_table[10-17] = 00,00,AF,7C,00,00,08,02 -> new data appears
  1793                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1794                          
  1795                          
  1796                                  ;; Re-get sectors per cluster (and store in dos_disk_table entry)
  1797                                  ;; (this was destroyed in the calculation above)
  1798                                  ;;
  1799  9226 ad04bc                     lda dos_disk_table_offset
  1800  9229 0916                       ora #fs_fat32_sectors_per_cluster        ;; is $16
  1801  922b a8                         tay
  1802  922c ad0dde                     lda sd_sectorbuffer+$0D
  1803  922f 9900bb                     sta dos_disk_table,y
  1804                          
  1805                          ;; Checkpoint("dos_disk_table-6")
  1806                          ;; jsr dump_disk_table        ; debugging
  1807                          
  1808                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1809                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1810                          ;; dos_disk_table[10-17] = 00,00,AF,7C,00,00,08,02
  1811                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1812                          
  1813                          ;;         ========================
  1814                          
  1815                                  ;; filter out non-FAT32 filesystems
  1816                                  ;; NOTE: FAT32 can have as few as 65525 clusters, but we do not support
  1817                                  ;; such file systems, which should be rare, anyway.
  1818                          
  1819  9232 ad04bc                     lda dos_disk_table_offset
  1820  9235 0916                       ora #fs_fat32_sectors_per_cluster        ;; is $16
  1821  9237 a8                         tay
  1822  9238 a906                       lda #dos_errorcode_too_few_clusters
  1823  923a 8dfabc                     sta dos_error_code
  1824                          
  1825  923d b903bb                     lda dos_disk_table+3,y        ;; BG this seems to creep-out-of-bounds from +16 to +19
  1826  9240 1902bb                     ora dos_disk_table+2,y
  1827  9243 d003                       bne +
  1828  9245 4cd590                     jmp partitionerror
  1829                          +
  1830                                  ;; Now get cluster of root directory.
  1831                                  ;;
  1832  9248 ad04bc                     lda dos_disk_table_offset
  1833  924b 0910                       ora #fs_fat32_root_dir_cluster                ;; is $10
  1834  924d a8                         tay
  1835                          
  1836  924e a203                       ldx #$03
  1837  9250 bd2cde             ddop16: lda sd_sectorbuffer+$2C,x        ;; +$2c is rootDirFirstCluster[3..0]
  1838  9253 9900bb                     sta dos_disk_table,y
  1839  9256 ca                         dex
  1840                          ;; BG should there be a "dey" here somewhere?
  1841  9257 10f7                       bpl ddop16
  1842                          
  1843                                  ;; We have now set the following fields:
  1844                                  ;;
  1845                                  ;; fs_fat32_length_of_fat
  1846                                  ;; fs_fat32_system_sectors
  1847                                  ;; fs_fat32_reserved_clusters
  1848                                  ;; fs_fat32_root_dir_cluster
  1849                                  ;; 12,13,14,15 ?
  1850                                  ;; fs_fat32_sectors_per_cluster
  1851                                  ;; fs_fat32_fat_copies
  1852                                  ;; fs_fat32_cluster0_sector
  1853                          
  1854                                  ;; Our caller has set:
  1855                                  ;;
  1856                                  ;; fs_start_sector
  1857                                  ;; fs_sector_count
  1858                          
  1859                          ;; Checkpoint("dos_disk_table-7")
  1860                          ;; jsr dump_disk_table        ; debugging
  1861                          
  1862                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1863                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1864                          ;; dos_disk_table[10-17] = 02,00,AF,7C,00,00,08,02 -> new data appears in [10]
  1865                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1866                          
  1867                                  ;; So all that is left for us is to set fs_type_and_source to $0F
  1868                                  ;; to indicate FAT32 filesystem on the SD card ...
  1869                                  ;;
  1870  9259 ad04bc                     lda dos_disk_table_offset
  1871  925c 0908                       ora #fs_type_and_source                ;; is $08
  1872  925e a8                         tay
  1873  925f a90f                       lda #$0f
  1874  9261 9900bb                     sta dos_disk_table,y
  1875                          
  1876                          ;; jsr dump_disk_table        ; debugging
  1877                          
  1878                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1879                          ;; dos_disk_table[08-0F] = 0F,E6,03,00,00,38,02,02 -> new data appears in [08]
  1880                          ;; dos_disk_table[10-17] = 02,00,AF,7C,00,00,08,02
  1881                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1882                          
  1883                                  +Checkpoint "FAT32 partition data copied to dos_disk_table"
  1884                          
  1885                                  ;; ... and increment the number of disks we know
  1886  9264 ee01bc                     inc dos_disk_count
  1887                          
  1888                          dos_return_success:
  1889                          
  1890                                  ;; Return success
  1891                                  ;;
  1892  9267 a900                       lda #$00
  1893  9269 8dfabc                     sta dos_error_code
  1894                          
  1895  926c 38                         sec
  1896  926d 60                         rts
  1897                          
  1898                          ;;         ========================
  1899                          ;;         ========================
  1900                          
  1901                          dos_return_error:
  1902                          
  1903  926e 8dfabc                     sta dos_error_code
  1904                          
  1905                          dos_return_error_already_set:
  1906                          
  1907  9271 18                         clc
  1908  9272 60                         rts
  1909                          
  1910                          ;;         ========================
  1911                          
  1912                          dos_set_current_disk:
  1913                          	
  1914                                  ;; Is disk number valid?
  1915                                  ;;
  1916                                  ;; INPUT: .X = disk
  1917                                  ;;
  1918                          
  1919  9273 ec01bc                     cpx dos_disk_count
  1920  9276 9007                       bcc + 			; Should this be BCC or BMI?
  1921                          
  1922  9278 a980                       lda #dos_errorcode_no_such_disk
  1923  927a 8dfabc                     sta dos_error_code
  1924  927d 18                 	clc
  1925  927e 60                 	rts
  1926                          	
  1927                          +
  1928  927f 8e03bc                     stx dos_disk_current_disk
  1929  9282 8a                         txa
  1930  9283 0a                         asl
  1931  9284 0a                         asl
  1932  9285 0a                         asl
  1933  9286 0a                         asl
  1934  9287 0a                         asl
  1935  9288 8d04bc                     sta dos_disk_table_offset
  1936                          
  1937                          !if DEBUG_HYPPO {
  1938                                  ldx dos_disk_current_disk        ;; convert .X to char-representation for display
  1939                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  1940                                  sty dscd+0
  1941                                  stx dscd+1
  1942                          
  1943                                  ;; print debug message
  1944                                  ;;
  1945                                  jsr checkpoint
  1946                                  !8 0
  1947                                  !text "dos_set_current_disk="
  1948                          dscd:   !text "xx"
  1949                                  !8 0
  1950                          }
  1951                          
  1952  928b 38                         sec
  1953  928c 60                         rts
  1954                          
  1955                          ;;         ========================
  1956                          
  1957                          dos_cdroot:
  1958                          
  1959                                  ;; Change to root directory on specified disk
  1960                                  ;; (Changes current disk if required)
  1961                                  ;;
  1962                                  ;; INPUT: .X = disk
  1963                          
  1964  928d 207392                     jsr dos_set_current_disk
  1965  9290 b002                       bcs dos_cdroot_current_disk_already_set
  1966                          
  1967                          	;; Could not set disk. Error will be already set
  1968  9292 18                 	clc
  1969  9293 60                 	rts	
  1970                          
  1971                          dos_cdroot_current_disk_already_set:
  1972                          
  1973                                  ;; get offset of disk entry
  1974                                  ;;
  1975                          	
  1976  9294 ae04bc                     ldx dos_disk_table_offset
  1977  9297 bd10bb                     lda dos_disk_table + fs_fat32_root_dir_cluster +0,x
  1978  929a 8d05bc                     sta dos_disk_cwd_cluster
  1979  929d bd11bb                     lda dos_disk_table + fs_fat32_root_dir_cluster +1,x
  1980  92a0 8d06bc                     sta dos_disk_cwd_cluster+1
  1981                          
  1982  92a3 a900                       lda #$00
  1983  92a5 8d07bc                     sta dos_disk_cwd_cluster+2        ;; BG here we assume that the 2x MSB's are zero
  1984  92a8 8d08bc                     sta dos_disk_cwd_cluster+3
  1985                          
  1986                                  ;; Nothing else to do, as it doesn't actually affect any existing DOS activity,
  1987                                  ;; only future file/directory operations.
  1988                          
  1989  92ab 4c6792                     jmp dos_return_success
  1990                          
  1991                          ;;         ========================
  1992                          
  1993                          dos_cluster_to_sector:
  1994                          
  1995                                  ;; convert a cluster number in dos_current_cluster into a sector number
  1996                                  ;; pre-loaded into SD address registers
  1997                                  ;; It is assumed to be on the current disk
  1998                          
  1999  92ae a203                       ldx #$03
  2000  92b0 bdb3bc             dcts0:  lda dos_current_cluster,x
  2001  92b3 9d81d6                     sta $d681,x
  2002  92b6 ca                         dex
  2003  92b7 10f7                       bpl dcts0
  2004                          
  2005                                  ;; subtract 2 from the cluster number (clusters 0 and 1 don't actually exist
  2006                                  ;; on FAT32).
  2007                                  ;;
  2008  92b9 a9ff                       lda #$ff
  2009  92bb aa                         tax
  2010  92bc a8                         tay
  2011  92bd 4b                         taz
  2012  92be a9fe                       lda #$fe
  2013  92c0 20299b                     jsr sdsector_add_uint32
  2014                          
  2015                                  ;; now shift it left according to fs_sectors_per_cluster
  2016                                  ;;
  2017  92c3 ae04bc                     ldx dos_disk_table_offset
  2018  92c6 bd16bb                     lda dos_disk_table+fs_fat32_sectors_per_cluster,x
  2019  92c9 a8                         tay
  2020  92ca 29fe                       and #$fe
  2021  92cc f014                       beq multipliedclusternumber
  2022                          
  2023  92ce 18                 dcts1:  clc
  2024  92cf 2e81d6                     rol $D681
  2025  92d2 2e82d6                     rol $D682
  2026  92d5 2e83d6                     rol $D683
  2027  92d8 2e84d6                     rol $D684
  2028  92db 98                         tya
  2029  92dc 4a                         lsr
  2030  92dd a8                         tay
  2031  92de 29fe                       and #$fe
  2032  92e0 d0ec                       bne dcts1
  2033                          
  2034                          multipliedclusternumber:
  2035                          
  2036                                  ;; skip over filesystem reserved and FAT sectors
  2037                                  ;;
  2038  92e2 a918                       lda #fs_fat32_cluster0_sector
  2039  92e4 20489b                     jsr sdsector_add_uint32_from_disktable
  2040                          
  2041                                  ;; add start sector of partition
  2042                                  ;;
  2043  92e7 a900                       lda #fs_start_sector
  2044  92e9 20489b                     jsr sdsector_add_uint32_from_disktable
  2045                          
  2046                                  ;; XXX - Check that result does not exceed fs_start_sector+fs_sector_count
  2047                                  ;; and run over into another partition
  2048                          
  2049                                  ;; return success
  2050  92ec 38                         sec
  2051  92ed 60                         rts
  2052                          
  2053                          ;;         ========================
  2054                          
  2055                          dos_requested_filename_to_uppercase:
  2056                          
  2057                                  ;; Convert filename to upper case for comparison
  2058                                  ;;
  2059  92ee ae66bc                     ldx dos_requested_filename_len
  2060  92f1 e03f                       cpx #$3f
  2061  92f3 9005                       bcc drftu1
  2062  92f5 a981                       lda #dos_errorcode_name_too_long
  2063  92f7 4c6e92                     jmp dos_return_error
  2064                          drftu1:
  2065  92fa bd67bc                     lda dos_requested_filename,x
  2066  92fd 20ec9e                     jsr toupper
  2067  9300 9d67bc                     sta dos_requested_filename,x
  2068  9303 ca                         dex
  2069  9304 10f4                       bpl drftu1
  2070  9306 38                         sec
  2071  9307 60                         rts
  2072                          
  2073                          ;;         ========================
  2074                          
  2075                          dos_get_free_descriptor:
  2076                          
  2077  9308 a200                       ldx #$00
  2078                          
  2079  930a 8a                 dgfd1:  txa
  2080  930b 0a                         asl
  2081  930c 0a                         asl
  2082  930d 0a                         asl
  2083  930e 0a                         asl
  2084  930f a8                         tay
  2085  9310 b9b8bc                     lda dos_file_descriptors+dos_filedescriptor_offset_diskid,y
  2086  9313 c9ff                       cmp #$FF
  2087  9315 f00a                       beq dgfd_found_free
  2088  9317 e8                         inx
  2089  9318 e004                       cpx #dos_filedescriptor_max
  2090  931a d0ee                       bne dgfd1
  2091                          
  2092  931c a984                       lda #dos_errorcode_too_many_open_files
  2093  931e 4c6e92                     jmp dos_return_error
  2094                          
  2095                          ;;         ========================
  2096                          
  2097                          dgfd_found_free:
  2098                          
  2099  9321 8ef8bc                     stx dos_current_file_descriptor
  2100  9324 8cf9bc                     sty dos_current_file_descriptor_offset
  2101                          
  2102                                  ;; Push the address dos_file_descriptors + dos_current_file_descriptor_offset
  2103                                  ;;
  2104  9327 18                         clc
  2105  9328 a9b8                       lda #<dos_file_descriptors
  2106  932a 6df9bc                     adc dos_current_file_descriptor_offset
  2107  932d a8                         tay
  2108  932e a9bc                       lda #>dos_file_descriptors
  2109  9330 6900                       adc #$00
  2110  9332 48                         pha
  2111  9333 5a                         phy
  2112                          
  2113                                  ;; Clear descriptor entry
  2114                                  ;;
  2115  9334 a00f                       ldy #$0f
  2116  9336 a900                       lda #$00
  2117                          
  2118  9338 8201               dgfd2:  sta ($01,sp),y
  2119  933a 88                         dey
  2120  933b d0fb                       bne dgfd2
  2121                          
  2122                                  ;; Pop the address
  2123  933d 68                         pla
  2124  933e 68                         pla
  2125                          
  2126                                  ;; Return file descriptor in X
  2127  933f 38                         sec
  2128  9340 60                         rts
  2129                          
  2130                          ;;         ========================
  2131                          
  2132                          dos_clearall:
  2133                          
  2134                                  ;; Free all file descriptors with extreme prejudice
  2135                                  ;; Clear dos_disk_table
  2136                          
  2137                                  ;; display debug message to uart
  2138                                  ;;
  2139                                  +Checkpoint "dos_clearall:"
  2140                          
  2141  9341 a9ff                       lda #$ff
  2142  9343 8db8bc                     sta dos_file_descriptors
  2143  9346 8dc8bc                     sta dos_file_descriptors+$10
  2144  9349 8dd8bc                     sta dos_file_descriptors+$20
  2145  934c 8de8bc                     sta dos_file_descriptors+$30
  2146  934f a200                       ldx #$00
  2147  9351 a900                       lda #$00
  2148  9353 9d00bb             dca1:   sta dos_disk_table,x
  2149  9356 e8                         inx
  2150  9357 d0fa                       bne dca1
  2151  9359 38                         sec
  2152  935a 60                         rts
  2153                          
  2154                          ;;         ========================
  2155                          
  2156                          dos_closefile:
  2157                          
  2158                                  ;; Close the current file/directory
  2159                                  ;; If the file is read-only, we can just free the file descriptor and return.
  2160                                  ;; XXX - If the file is open for write, we might have a buffer to flush.
  2161                                  ;; (Worry about this when we implement writing. Opening files for write will
  2162                                  ;; probably require the caller to nominate a 512 byte buffer in user-space
  2163                                  ;; memory so that the convenience write-byte routine can work.  The other case,
  2164                                  ;; writing a sector at a time, should just be synchronous, so that there is no
  2165                                  ;; buffering required.)
  2166                          
  2167  935b aef9bc                     ldx dos_current_file_descriptor_offset
  2168  935e bdb9bc                     lda dos_file_descriptors + dos_filedescriptor_offset_mode,x
  2169  9361 c901                       cmp #dos_filemode_readwrite
  2170  9363 d000                       bne dcf_simple
  2171                          
  2172                                  ;; This is where we would flush the write buffer, and update file length in
  2173                                  ;; directory, if required.  Note that to save space, we don't actually keep the
  2174                                  ;; location of the directory entry of the file in the file descriptor.  This
  2175                                  ;; complicates things somewhat, and we might need to change this.  However, the
  2176                                  ;; file descriptor table must be a power of two in length, and there isn't any
  2177                                  ;; space to double its' size.  Thus we will need a separate table that holds the
  2178                                  ;; directory sector and entry for any file being written to.  We might save a
  2179                                  ;; few bytes by allowing less than dos_filedescriptor_max files to be open for
  2180                                  ;; writing at any point in time.
  2181                          
  2182                          dcf_simple:
  2183                          
  2184  9365 aef9bc                     ldx dos_current_file_descriptor_offset
  2185  9368 a9ff                       lda #$ff ;; not allocated flag for file descriptor
  2186  936a 9db8bc                     sta dos_file_descriptors + dos_filedescriptor_offset_diskid,x
  2187  936d 38                         sec
  2188  936e 60                         rts
  2189                          
  2190                          ;;         ========================
  2191                          
  2192                          dos_chdir:
  2193                          	;; Works similarly to dos_openfile, i.e. you must first have the
  2194                          	;; directory in the dirent structure, found via dos_findfile
  2195                          
  2196                                  ;; Check if the file is a directory, if so, refuse to open it.
  2197                                  ;;
  2198  936f ad65bc                     lda dos_dirent_type_and_attribs
  2199  9372 2910                       and #fs_fat32_attribute_isdirectory
  2200  9374 d005                       bne dcd_is_a_directory
  2201                          
  2202  9376 a987                       lda #dos_errorcode_not_a_directory
  2203  9378 4c6e92                     jmp dos_return_error
  2204                          	
  2205                          ;;         ========================
  2206                          
  2207                          dcd_is_a_directory:
  2208                          
  2209  937b 204796                     jsr dos_set_current_file_from_dirent
  2210  937e 904c                       bcc l3_dos_return_error_already_set
  2211                          
  2212                          	;; Close the file descriptor opened by dos_set_current_file_from_dirent
  2213  9380 205b93             	jsr dos_closefile
  2214                          
  2215                          	;; Copy cluster of requesteed directory into disk CWD cluster
  2216  9383 a203               	ldx #3
  2217  9385 bd5dbc             dcd1:	lda dos_dirent_cluster,x
  2218  9388 9d05bc             	sta dos_disk_cwd_cluster,x
  2219  938b ca                 	dex
  2220  938c 10f7               	bpl dcd1
  2221                          
  2222                          	;; Check if cluster 0. If so, cd to root directory
  2223                          	;; (its a convention to put cluster 0 in references to the root directory
  2224                          	;; on some FAT implementations, apparently).
  2225                          	
  2226  938e a203               	ldx #3
  2227  9390 a900               	lda #0
  2228  9392 1d05bc             dcd2:	ora dos_disk_cwd_cluster,x
  2229  9395 ca                 	dex
  2230  9396 10fa               	bpl dcd2
  2231                          
  2232  9398 c900               	cmp #0
  2233  939a d003               	bne @nonZeroCluster
  2234                          
  2235                          	;; Is cluster 0, so change to root directory
  2236  939c 4c9492             	jmp dos_cdroot_current_disk_already_set
  2237                          	
  2238                          @nonZeroCluster:
  2239                          	;; Return success
  2240  939f 38                 	sec
  2241  93a0 60                 	rts
  2242                          
  2243                          ;;         ========================
  2244                          	
  2245                          	
  2246                          dos_openfile:
  2247                          
  2248                                  ;; Open the file that is in the dirent structure
  2249                                  ;; (to open a file by arbitrary name, you must first call dos_findfile)
  2250                          
  2251                                  ;; Check if the file is a directory, if so, refuse to open it.
  2252                                  ;;
  2253  93a1 ad65bc                     lda dos_dirent_type_and_attribs
  2254  93a4 2910                       and #fs_fat32_attribute_isdirectory
  2255  93a6 f005                       beq dos_not_a_directory
  2256                          
  2257  93a8 a986                       lda #dos_errorcode_is_a_directory
  2258  93aa 4c6e92                     jmp dos_return_error
  2259                          
  2260                          ;;         ========================
  2261                          
  2262                          dos_not_a_directory:
  2263                          
  2264  93ad 204796                     jsr dos_set_current_file_from_dirent
  2265  93b0 901a                       bcc l3_dos_return_error_already_set
  2266                          
  2267  93b2 4c9496                     jmp dos_open_current_file
  2268                          
  2269                          ;;         ========================
  2270                          
  2271                          dos_findfile:
  2272                          
  2273                                  ;; Convenience wrapper around dos_findfirst to make sure that we don't
  2274                                  ;; leave any hanging file descriptors.
  2275                          
  2276  93b5 20c293                     jsr dos_findfirst
  2277  93b8 b003                       bcs @found
  2278  93ba 4ccc93                     jmp l3_dos_return_error_already_set
  2279                          @found: ;; if we found the file, directory-FD is still open
  2280  93bd 205b93                     jsr dos_closefile
  2281  93c0 38                         sec
  2282  93c1 60                         rts
  2283                          
  2284                          ;;         ========================
  2285                          
  2286                          dos_findfirst:
  2287                          
  2288                                  ;; Search for file in current directory
  2289                                  ;; if found:
  2290                                  ;;    return return carry set
  2291                                  ;;    leaves directory-FD open, to enable call dos_findnext to find more
  2292                                  ;; if not found:
  2293                                  ;;    will return carry clear
  2294                                  ;;    closes directory-FD
  2295                          
  2296                                  ;; Convert name to upper case for searching
  2297                                  ;;
  2298  93c2 20ee92                     jsr dos_requested_filename_to_uppercase
  2299  93c5 9005                       bcc l3_dos_return_error_already_set
  2300                          
  2301  93c7 20e693                     jsr dos_opendir
  2302  93ca b003                       bcs +
  2303                          l3_dos_return_error_already_set:
  2304  93cc 4c7192                     jmp dos_return_error_already_set
  2305                          +
  2306                                  ;; Directory is now open, and we can now iterate through directory entries
  2307                                  ;;
  2308  93cf 4cd293             	jmp dos_findnext
  2309                          
  2310                          
  2311                          ;;         ========================
  2312                          
  2313                          dos_findnext:
  2314                          
  2315                                  ;; Keep searching in directory for another match
  2316                                  ;; see dos_findfirst above for return state!
  2317                          
  2318                          dff_try_next_entry:
  2319                          
  2320                                  ;; Get next directory entry
  2321                                  ;;
  2322  93d2 201c94                     jsr dos_readdir
  2323  93d5 b008                       bcs dff_have_next_entry
  2324                          
  2325                                  ;; no more entries, so we close file descriptor for convinience
  2326  93d7 205b93                     jsr dos_closefile
  2327                          
  2328  93da a988                       lda #dos_errorcode_file_not_found
  2329  93dc 4c6e92                     jmp dos_return_error
  2330                          
  2331                          dff_have_next_entry:
  2332                          
  2333                                  ;; Compare dos_dirent_longfilename with dos_requested_filename
  2334                                  ;;
  2335  93df 200896                     jsr dos_dirent_compare_name_to_requested
  2336                          
  2337                                  ;; no match? try next entry
  2338                                  ;;
  2339  93e2 90ee                       bcc dff_try_next_entry
  2340                          
  2341                                  ;; we have a match, so return success
  2342                                  ;; (we don't close the file handle for the directory search, because the
  2343                                  ;; caller may want to find multiple matches)
  2344                                  ;;
  2345  93e4 38                         sec
  2346  93e5 60                         rts
  2347                          
  2348                          ;;         ========================
  2349                          
  2350                          dos_opendir:
  2351                          
  2352                                  ;; Open the current directory as a file
  2353                                  ;;
  2354  93e6 200893                     jsr dos_get_free_descriptor
  2355  93e9 b003                       bcs +
  2356  93eb 4c7192                     jmp dos_return_error_already_set
  2357                          +
  2358                                  ;; get offset in file descriptor table
  2359                                  ;;
  2360  93ee 8a                         txa
  2361  93ef 0a                         asl
  2362  93f0 0a                         asl
  2363  93f1 0a                         asl
  2364  93f2 0a                         asl
  2365  93f3 a8                         tay
  2366                          
  2367                                  ;; set disk id
  2368                                  ;;
  2369  93f4 ad03bc                     lda dos_disk_current_disk
  2370  93f7 99b8bc                     sta dos_file_descriptors+dos_filedescriptor_offset_diskid,y
  2371                          
  2372                                  ;; load cluster of dir into file descriptor
  2373                                  ;;
  2374  93fa a200                       ldx #$00
  2375                          
  2376  93fc bd05bc             dff1:   lda dos_disk_cwd_cluster,x
  2377  93ff 99babc                     sta dos_file_descriptors+dos_filedescriptor_offset_startcluster,y
  2378  9402 99bebc                     sta dos_file_descriptors+dos_filedescriptor_offset_currentcluster,y
  2379  9405 c8                         iny
  2380  9406 e8                         inx
  2381  9407 e004                       cpx #$04
  2382  9409 d0f1                       bne dff1
  2383                          
  2384                                  ;; Mark file descriptor as being a directory
  2385                                  ;;
  2386  940b aef9bc                     ldx dos_current_file_descriptor_offset
  2387  940e a980                       lda #dos_filemode_directoryaccess
  2388  9410 9db9bc                     sta dos_file_descriptors + dos_filedescriptor_offset_mode,x
  2389                          
  2390  9413 209496                     jsr dos_open_current_file
  2391  9416 b003                       bcs +
  2392  9418 4c7192                     jmp dos_return_error_already_set
  2393  941b 60                 +       rts
  2394                          
  2395                          ;;         ========================
  2396                          
  2397                          dos_readdir:
  2398                          
  2399                                  ;; Get the current file entry, and advance pointer
  2400                                  ;; This requires parsing the current directory entry onwards, accumulating
  2401                                  ;; long filename parts as required.  We only support filenames to 64 chars,
  2402                                  ;; so long names longer than that will get ignored.
  2403                                  ;; LFN entries have an attribute byte of $0F (normally indicates volume label)
  2404                                  ;; LFN entries use 16-bit unicode values. For now we will just keep the lower
  2405                                  ;; byte of these
  2406                          
  2407                                  ;; clear long file name data from last call
  2408                                  ;;
  2409  941c a900                       lda #0
  2410  941e 8d4fbc                     sta dos_dirent_longfilename_length
  2411                          
  2412  9421 20e296                     jsr dos_file_read_current_sector
  2413                          
  2414                          !if DEBUG_HYPPO {
  2415                          ;; debug info, unsure what byte is being displayed...
  2416                          ;;
  2417                                  +Checkpoint "-"
  2418                          
  2419                                  ldy dos_current_file_descriptor_offset
  2420                                  clc
  2421                                  lda dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +0,y
  2422                          
  2423                                  tax                                ;; convert .X to char-representation for display
  2424                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2425                                  sty drdcp0+2
  2426                                  stx drdcp0+3
  2427                          
  2428                                  ldy dos_current_file_descriptor_offset
  2429                                  clc
  2430                                  lda dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +1,y
  2431                          
  2432                                  tax                                ;; convert .X to char-representation for display
  2433                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2434                                  sty drdcp0+0
  2435                                  stx drdcp0+1
  2436                          
  2437                                  jsr checkpoint
  2438                                  !8 0
  2439                                  !text "dos_readdir["
  2440                          drdcp0: !text "xxyy]"
  2441                                  !8 0
  2442                          
  2443                                  jsr dumpsectoraddress        ;; debug
  2444                                  jsr dumpfddata                ;; debug
  2445                          
  2446                          ;; end of debug
  2447                          }
  2448                          
  2449  9424 aef9bc                     ldx dos_current_file_descriptor_offset
  2450  9427 bdb9bc                     lda dos_file_descriptors + dos_filedescriptor_offset_mode,x
  2451  942a c980                       cmp #dos_filemode_directoryaccess
  2452  942c f00e                       beq drd_isdir
  2453  942e c981                       cmp #dos_filemode_end_of_directory
  2454  9430 d005                       bne drd_notadir
  2455                          
  2456  9432 a9ff                       lda #dos_errorcode_eof
  2457  9434 4c6e92                     jmp dos_return_error
  2458                          
  2459                          ;;         ========================
  2460                          
  2461                          drd_notadir:
  2462                                  ;; refuse to read files as directories
  2463                                  ;;
  2464  9437 a987                       lda #dos_errorcode_not_a_directory
  2465  9439 4c6e92                     jmp dos_return_error
  2466                          
  2467                          ;;         ========================
  2468                          
  2469                          drd_isdir:
  2470                          
  2471                                  ;; Clear dirent structure
  2472                                  ;; WARNING - Uses carnal knowledge to know that dirent structure is
  2473                                  ;; 64+1+11+4+4+1 = 85 contiguous bytes
  2474                                  ;;
  2475  943c a256                       ldx #dos_dirent_structure_length-1
  2476  943e a900                       lda #$00
  2477                          
  2478  9440 9d0fbc             drce1:  sta dos_dirent_longfilename,x
  2479  9443 ca                         dex
  2480  9444 10fa                       bpl drce1
  2481                          
  2482                                  ;; Read current sector
  2483                                  ;;
  2484  9446 20e296                     jsr dos_file_read_current_sector
  2485  9449 b003                       bcs +
  2486  944b 4c7192                     jmp dos_return_error_already_set
  2487  944e 20c39f             +       jsr sd_map_sectorbuffer
  2488                          
  2489                          drce_next_piece:
  2490                          
  2491                                  ;; Offset in sector correctly indicates where we need to read.
  2492                                  ;; Sectors are 512 bytes, so we can't just do a register index.
  2493                                  ;; Instead we will setup a 16-bit pointer.
  2494                                  ;;
  2495  9451 adf9bc                     lda dos_current_file_descriptor_offset
  2496  9454 090b                       ora #dos_filedescriptor_offset_offsetinsector
  2497  9456 aa                         tax
  2498  9457 bdb8bc                     lda dos_file_descriptors,x
  2499  945a 8500                       sta <dos_scratch_vector
  2500  945c bdb9bc                     lda dos_file_descriptors+1,x
  2501  945f 18                         clc
  2502  9460 69de                       adc #$DE   ;; high byte of SD card sector buffer
  2503  9462 8501                       sta <(dos_scratch_vector+1)
  2504                          
  2505                                  ;; (dos_scratch_vector) now has the address of the directory entry
  2506                          
  2507                          !if DEBUG_HYPPO {
  2508                                  phx        ;; as the code below clobbers X
  2509                          
  2510                                  ;; print out filename and attrib
  2511                                  ;;
  2512                                  ldy #fs_fat32_dirent_offset_shortname
  2513                                  ldx #0
  2514                          eight31:
  2515                                  lda (<dos_scratch_vector),y
  2516                                  jsr makeprintable
  2517                                  sta eight3,x
  2518                                  iny
  2519                                  inx
  2520                                  cpx #11                ;; 11 chars in the filename (8+3)
  2521                                  bne eight31
  2522                                  ;;
  2523                                  ;; attrib
  2524                                  ;;
  2525                                  ldy #fs_fat32_dirent_offset_attributes        ;; = 0x0B
  2526                                  lda (<dos_scratch_vector),y
  2527                                  tax                                ;; convert .X to char-representation for display
  2528                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2529                                  sty eight3attrib+0
  2530                                  stx eight3attrib+1
  2531                                  ;;
  2532                                  ;; char1
  2533                                  ;;
  2534                                  ldy #$00
  2535                                  lda (<dos_scratch_vector),y
  2536                                  tax                                ;; convert .X to char-representation for display
  2537                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2538                                  sty eight3char1+0
  2539                                  stx eight3char1+1
  2540                          
  2541                                  ;;
  2542                          
  2543                                  jsr checkpoint
  2544                                  !8 0
  2545                                  !text " (8.3)+(ATTRIB)+(NAME[0]) = "
  2546                          eight3: !text "FILENAMEEXT "
  2547                          eight3attrib:
  2548                                  !text "xx "
  2549                          eight3char1:
  2550                                  !text "xx"
  2551                                  !8 0
  2552                          
  2553                                  plx        ;; as the code above clobbers X
  2554                          }
  2555                          
  2556                          ;;         ========================
  2557                          
  2558                                  ;; first, check if the entry begins with $E5 marking a deleted file.
  2559                          	;; Entry entries we just ignore, as they are totally valid.
  2560                          
  2561  9464 a000                       ldy #fs_fat32_dirent_offset_shortname        ;; Y=0 (first char of entry)
  2562  9466 b100                       lda (<dos_scratch_vector),y
  2563  9468 c9e5                       cmp #$e5
  2564  946a d003                       bne +
  2565  946c 4cf895                     jmp drd_deleted_or_invalid_entry
  2566                          +
  2567  946f c900               	cmp #$00
  2568  9471 d003                       bne +
  2569                          	;; Empty entry, so skip over it
  2570  9473 4cf895             	jmp drd_deleted_or_invalid_entry
  2571                          +
  2572                                  ;; now check the attrib
  2573                          
  2574  9476 a00b                       ldy #fs_fat32_dirent_offset_attributes        ;; = 0x0B
  2575  9478 b100                       lda (<dos_scratch_vector),y
  2576                          
  2577                                  ;; check the kind of data we are looking at:
  2578                                  ;; bit 5 = 1         -> is a Archive
  2579                                  ;; bit 4 = 1         -> is a Directory
  2580                                  ;; bit 3 = 1         -> is a Volume ID
  2581                                  ;; bit 2 = 1         -> is a System
  2582                                  ;; bit 1 = 1         -> is a Hidden
  2583                                  ;; bit 0 = 1         -> is a Readonly
  2584                          
  2585  947a a8                         tay        ;; for safe keeping
  2586                          
  2587                                  ;; if bits xx3210 = xx1111 -> is a long filename
  2588                                  ;; we process these differently to the standard (shortname) entries
  2589                                  ;;
  2590  947b 290f                       and #$0f
  2591  947d c90f                       cmp #$0f                ;; %00001111 LFN entry special attribute value (xxxx1111)
  2592  947f d003                       bne drce_cont0
  2593  9481 4c9994                     jmp drce_longname        ;; MATCH -> must be LFN
  2594                          
  2595                          drce_cont0:
  2596  9484 98                         tya        ;; from safe keeping
  2597                          
  2598                                  ;; if bit-3 = 1 -> Vol ID
  2599                                  ;; we process the Vol ID different (for now)
  2600                                  ;;
  2601  9485 2908                       and #$08
  2602  9487 c908                       cmp #$08                ;; %00001000 Vol-ID
  2603  9489 d003                       bne drce_cont2
  2604  948b 4c2495             	jmp drce_cont_next_part	; Ignore it
  2605                          
  2606                          drce_cont2:
  2607  948e 98                         tya        ;; from safe keeping
  2608                          
  2609                                  ;; check for bits 2 or 1 asserted
  2610                                  ;; we should ignore these hidden/system files (for now)
  2611                                  ;;
  2612  948f 2906                       and #$06                ;; %00000110
  2613  9491 f003                       beq drce_cont3        ;; branch if equal to zero (ie not Hidden OR System)
  2614                          	;; Ignore hidden/system files for now
  2615                          	;; XXX We should have a flag to enable/disable this behaviour
  2616  9493 4c2495             	jmp drce_cont_next_part
  2617                          
  2618                          drce_cont3:
  2619                          
  2620                                  ;; was not hidden/system, or Vol-ID, or LFN,
  2621                                  ;; so we process this entry regardless of if read-only (bit0) or not
  2622                          
  2623  9496 4c2f95                     jmp drce_normalrecord
  2624                          
  2625                          ;;         ========================
  2626                          
  2627                          drce_longname:
  2628                          
  2629                          disable_lfn_byte:	
  2630  9499 4c2495             	jmp drce_cont_next_part
  2631                          
  2632  949c ee20d0             	inc $d020
  2633  949f 4c9994             	jmp drce_longname
  2634                          	
  2635                                  ;; make sure long entry type is "filename" (=$00)
  2636                                  ;;
  2637  94a2 a00c                       ldy #fs_fat32_dirent_offset_lfn_type
  2638  94a4 b100                       lda (<dos_scratch_vector),y
  2639  94a6 f003                       beq +
  2640  94a8 4c2f95                     jmp drce_normalrecord
  2641                          +
  2642                                  ;; verify checksum of long name
  2643                                  ;; XXX - Actually, we need to keep the checksum, and then compare it with the
  2644                                  ;; checksum we compute on the short name to check if this is the right long
  2645                                  ;; name.  We are just going to ignore this for now, and assume (and hope) that
  2646                                  ;; the LFN structure is always healthy.  I am sure this will come back to bite
  2647                                  ;; us at some point, and it can be fixed at that point in time.
  2648                          
  2649                                  ;; It's a long filename piece
  2650                                  ;; byte 0 gives the position in the LFN of this piece.
  2651                                  ;; Each piece has 13 16-bit unicode values.
  2652                                  ;; For now, we will only use the lower byte.  later we should gather the
  2653                                  ;; long filenames as UTF-16, and then convert them to UTF-8.
  2654                          
  2655  94ab a000                       ldy #fs_fat32_dirent_offset_lfn_part_number
  2656  94ad b100                       lda (<dos_scratch_vector),y
  2657  94af 293f                       and #$3f ;; mask out end of LFN indicator
  2658  94b1 3a                         dec ;; subtract one, since pieces are numbered from 1 upwards
  2659                          
  2660                                  ;; each piece has 13 chars, and we only allow 64 characters total, so any
  2661                                  ;; piece number >4 can be ignored
  2662                                  ;;
  2663  94b2 c905                       cmp #5
  2664  94b4 b061                       bcs drce_ignore_lfn_piece
  2665  94b6 aa                         tax
  2666  94b7 bd0396                     lda lfn_piece_offsets,x
  2667  94ba aa                         tax
  2668                          
  2669                                  +Checkpoint "found LFN piece <start>"
  2670                          
  2671                                  ;; Copy first part of LFN
  2672                                  ;;
  2673  94bb a001                       ldy #fs_fat32_dirent_offset_lfn_part1_start
  2674  94bd a305                       ldz #fs_fat32_dirent_offset_lfn_part1_chars
  2675  94bf b100               drce2:  lda (<dos_scratch_vector),y
  2676  94c1 f040                       beq drce_eot_in_filename
  2677  94c3 9d0fbc                     sta dos_dirent_longfilename,x
  2678  94c6 8e4fbc                     stx dos_dirent_longfilename_length
  2679  94c9 e8                         inx
  2680                                  ;; protect against over-long LFNs
  2681  94ca e040                       cpx #$40
  2682  94cc f035                       beq drce_eot_in_filename
  2683  94ce c8                         iny
  2684  94cf c8                         iny
  2685  94d0 3b                         dez
  2686  94d1 d0ec                       bne drce2
  2687                          
  2688                                  ;; Copy second part of LFN
  2689                                  ;;
  2690  94d3 a00e                       ldy #fs_fat32_dirent_offset_lfn_part2_start
  2691  94d5 a306                       ldz #fs_fat32_dirent_offset_lfn_part2_chars
  2692  94d7 b100               drce3:  lda (<dos_scratch_vector),y
  2693  94d9 f028                       beq drce_eot_in_filename
  2694  94db 9d0fbc                     sta dos_dirent_longfilename,x
  2695  94de 8e4fbc                     stx dos_dirent_longfilename_length
  2696  94e1 e8                         inx
  2697                                  ;; protect against over-long LFNs
  2698  94e2 e040                       cpx #$40
  2699  94e4 f01d                       beq drce_eot_in_filename
  2700  94e6 c8                         iny
  2701  94e7 c8                         iny
  2702  94e8 3b                         dez
  2703  94e9 d0ec                       bne drce3
  2704                          
  2705                                  ;; Copy third part of LFN
  2706                                  ;;
  2707  94eb a01c                       ldy #fs_fat32_dirent_offset_lfn_part3_start
  2708  94ed a302                       ldz #fs_fat32_dirent_offset_lfn_part3_chars
  2709  94ef b100               drce4:  lda (<dos_scratch_vector),y
  2710  94f1 f010                       beq drce_eot_in_filename
  2711  94f3 9d0fbc                     sta dos_dirent_longfilename,x
  2712  94f6 8e4fbc                     stx dos_dirent_longfilename_length
  2713  94f9 e8                         inx
  2714                                  ;; protect against over-long LFNs
  2715  94fa e040                       cpx #$40
  2716  94fc f005                       beq drce_eot_in_filename
  2717  94fe c8                         iny
  2718  94ff c8                         iny
  2719  9500 3b                         dez
  2720  9501 d0ec                       bne drce4
  2721                          
  2722                          drce_eot_in_filename:
  2723                          
  2724                                  +Checkpoint "BGOK drce_eot_in_filename"
  2725                          
  2726                                  ;; got all characters from this LFN piece
  2727                                  ;;
  2728  9503 ec4fbc                     cpx dos_dirent_longfilename_length
  2729  9506 900f                       bcc drce_piece_didnt_grow_name_length
  2730  9508 8e4fbc                     stx dos_dirent_longfilename_length
  2731  950b e03f                       cpx #$3f
  2732  950d b008                       bcs drce_eot_in_filename2
  2733                          
  2734                                  ;; null terminate if there is space, for convenience
  2735                                  ;;
  2736  950f a900                       lda #$00
  2737  9511 9d0fbc                     sta dos_dirent_longfilename,x
  2738  9514 8e4fbc                     stx dos_dirent_longfilename_length
  2739                          
  2740                          drce_eot_in_filename2:
  2741                          
  2742                          drce_piece_didnt_grow_name_length:
  2743                          
  2744                          drce_ignore_lfn_piece:
  2745                          
  2746                                  +Checkpoint "BGOK drce_ignore_lfn_piece"
  2747                          
  2748                                  ;; We have finished processing this piece of long name.
  2749                                  ;; bump directory entry, read next sector if required, and re-enter loop
  2750                                  ;; above to keep accumulating
  2751                          
  2752                          drce_cont_next:
  2753                          
  2754                                  +Checkpoint "BGOK drce_cont_next"
  2755                          
  2756  9517 202396                     jsr dos_readdir_advance_to_next_entry
  2757  951a 9003                       bcc drce_no_more_pieces
  2758                          
  2759  951c 4c5194                     jmp drce_next_piece
  2760                          
  2761                          drd_end_of_directory:
  2762                                  ;; If we have pieces, then emit the final filename,
  2763                                  ;; else return EOF on the directory by falling through to the following
  2764                                  ;; Can we ever be in such a position?  Let's assume for the time being that
  2765                                  ;; we can't.  If we start losing the last name in a directory list, then we
  2766                                  ;; can worry about fixing it then.
  2767                          
  2768                                  ;; FALL THROUGH to drce_no_more_pieces
  2769                          
  2770                          ;;         ========================
  2771                          
  2772                          drce_no_more_pieces:
  2773                                  +Checkpoint "FOUND END_OF_DIRECTORY"
  2774                          
  2775  951f a9ff                       lda #dos_errorcode_eof
  2776  9521 4c6e92                     jmp dos_return_error
  2777                          
  2778                          ;;         ========================
  2779                          
  2780                          
  2781                          drce_cont_next_part:
  2782                          
  2783  9524 202396                     jsr dos_readdir_advance_to_next_entry
  2784  9527 9003                       bcc +
  2785  9529 4c1c94                     jmp dos_readdir
  2786  952c 4c7192             +       jmp dos_return_error_already_set
  2787                          
  2788                          ;;         ========================
  2789                          
  2790                          drce_normalrecord:
  2791                                  ;; PGS: We have found a short name.
  2792                          
  2793                          
  2794                                  +Checkpoint "processing SHORT-name"
  2795                          
  2796                                  ;; store short name
  2797                                  ;;
  2798  952f a000                       ldy #fs_fat32_dirent_offset_shortname
  2799                          
  2800                          ;; this test has already been done
  2801                          ;;
  2802                          ;;         ; Ignore empty and deleted entries (first byte $00 or $E5 respectively)
  2803                          ;;         ;
  2804                          ;;         lda (<dos_scratch_vector),y
  2805                          ;;         beq drd_end_of_directory
  2806                          ;;         cmp #$e5
  2807                          ;;         beq drd_deleted_or_invalid_entry
  2808                          
  2809  9531 a200                       ldx #$00
  2810  9533 b100               drce5:  lda (<dos_scratch_vector),y
  2811  9535 9d50bc                     sta dos_dirent_shortfilename,x
  2812  9538 e8                         inx
  2813  9539 c8                         iny
  2814  953a e00b                       cpx #11
  2815  953c d0f5                       bne drce5
  2816                          
  2817                                  ;; If we have no long name, copy it also to long name, inserting "." between
  2818                                  ;; name and extension as required.
  2819                                  ;;
  2820  953e ad4fbc                     lda dos_dirent_longfilename_length
  2821  9541 d05b                       bne drce_already_have_long_name
  2822                          
  2823                                  ;; copy name part
  2824                                  ;;
  2825  9543 a000                       ldy #fs_fat32_dirent_offset_shortname
  2826  9545 a200                       ldx #$00
  2827  9547 b100               drce7:  lda (<dos_scratch_vector),y
  2828  9549 9d0fbc                     sta dos_dirent_longfilename,x
  2829  954c 8e4fbc                     stx dos_dirent_longfilename_length
  2830  954f e8                         inx
  2831  9550 c8                         iny
  2832  9551 c920                       cmp #$20            ;; space indicates end of short name before extension
  2833  9553 f005                       beq drce_insert_dot
  2834  9555 e008                       cpx #8
  2835  9557 d0ee                       bne drce7
  2836  9559 e8                         inx
  2837                          
  2838                          drce_insert_dot:
  2839  955a ca                         dex
  2840  955b a92e                       lda #'.'
  2841  955d 9d0fbc                     sta dos_dirent_longfilename,x
  2842  9560 8e4fbc                     stx dos_dirent_longfilename_length
  2843  9563 e8                         inx
  2844                          
  2845                                  ;; copy extension part
  2846                                  ;;
  2847  9564 a008                       ldy #fs_fat32_dirent_offset_shortname+8
  2848  9566 a300                       ldz #0
  2849  9568 b100               drce6:  lda (<dos_scratch_vector),y
  2850  956a 9d0fbc                     sta dos_dirent_longfilename,x
  2851  956d 8e4fbc                     stx dos_dirent_longfilename_length
  2852  9570 e8                         inx
  2853  9571 c8                         iny
  2854  9572 1b                         inz
  2855  9573 c203                       cpz #3  ;; short name extensions are <=3 chars
  2856  9575 f008                       beq drce_copied_extension
  2857                          
  2858                                  ;; also terminate extensions early if they are <3 chars
  2859                                  ;;
  2860  9577 c920                       cmp #$20
  2861  9579 f004                       beq drce_copied_extension
  2862  957b e00c                       cpx #8+1+3
  2863  957d d0e9                       bne drce6
  2864                          
  2865                          drce_copied_extension:
  2866                          	
  2867                          	;; Trim spaces from the end of the filename
  2868  957f e000               	cpx #0
  2869  9581 f013               	beq @filename0bytes
  2870  9583 a920               	lda #$20
  2871  9585 dd0ebc             	cmp dos_dirent_longfilename-1,x
  2872  9588 d004               	bne @nomorespaces
  2873  958a ca                 	dex
  2874  958b 4c7f95             	jmp drce_copied_extension
  2875                          	
  2876                          @nomorespaces:
  2877                          
  2878                          	;; And trim trailing . from file name in case extension
  2879                          	;; was all spaces. But don't trim it if the filename starts
  2880                          	;; with ., so that we don't mess up . and .. directories
  2881  958e bd0ebc             	lda dos_dirent_longfilename-1,x
  2882                          	;; Is last char a . ?
  2883  9591 c92e               	cmp #$2e
  2884  9593 d001               	bne @notrailingdot
  2885                          
  2886                          @hastrailingdot:
  2887                          	
  2888                          	;; Cut . from end of filename
  2889  9595 ca                 	dex
  2890                          
  2891                          @notrailingdot:
  2892                          	
  2893                          @filename0bytes:
  2894                          
  2895                          	;; null terminate short name for convenience in our debugging
  2896                                  ;;
  2897  9596 a900                       lda #$00
  2898  9598 9d0fbc                     sta dos_dirent_longfilename,x
  2899                          
  2900                                  ;; record length of short name
  2901  959b 8e4fbc                     stx dos_dirent_longfilename_length
  2902                          
  2903                                  ;; fall through
  2904                          
  2905                          drce_already_have_long_name:
  2906                          
  2907                                  ;; now copy attribute field and other useful data
  2908                          
  2909                                  ;; starting cluster
  2910                                  ;;
  2911  959e a01a                       ldy #fs_fat32_dirent_offset_clusters_low
  2912  95a0 b100                       lda (<dos_scratch_vector),y
  2913  95a2 8d5dbc                     sta dos_dirent_cluster
  2914  95a5 c8                         iny
  2915  95a6 b100                       lda (<dos_scratch_vector),y
  2916  95a8 8d5ebc                     sta dos_dirent_cluster+1
  2917                          
  2918  95ab a014                       ldy #fs_fat32_dirent_offset_clusters_high
  2919  95ad b100                       lda (<dos_scratch_vector),y
  2920  95af 8d5fbc                     sta dos_dirent_cluster+2
  2921  95b2 c8                         iny
  2922  95b3 b100                       lda (<dos_scratch_vector),y
  2923  95b5 8d60bc                     sta dos_dirent_cluster+3
  2924                          
  2925                          
  2926                                  ;; file length in bytes
  2927                                  ;;
  2928  95b8 a01c                       ldy #fs_fat32_dirent_offset_file_length
  2929  95ba a200                       ldx #0
  2930                          drce_fl:
  2931  95bc b100                       lda (<dos_scratch_vector),y
  2932  95be 9d61bc                     sta dos_dirent_length,x
  2933  95c1 c8                         iny
  2934  95c2 e8                         inx
  2935  95c3 e004                       cpx #4
  2936  95c5 d0f5                       bne drce_fl
  2937                          
  2938                                  ;; attributes
  2939                                  ;;
  2940  95c7 a00b                       ldy #fs_fat32_dirent_offset_attributes
  2941  95c9 b100                       lda (<dos_scratch_vector),y
  2942  95cb 8d65bc                     sta dos_dirent_type_and_attribs
  2943                          
  2944                                  +Checkpoint "drce_fl populated fields"
  2945                          
  2946  95ce 202396                     jsr dos_readdir_advance_to_next_entry
  2947  95d1 b010                       bcs drce_not_eof
  2948                          
  2949                          drce_is_eof:
  2950                          
  2951                                  +Checkpoint "DEBUG drce_is_eof <!>"
  2952                          
  2953                                  ;; We need to pass the error through here to indicate EOF in directory,
  2954                                  ;; but in a way that can be defered to the next call to dos_readdir, because
  2955                                  ;; we have a valid entry right now.  We do this with a special file mode which
  2956                                  ;; is EOF of directory (dos_filemode_end_of_directory)
  2957                                  ;;
  2958  95d3 aef9bc                     ldx dos_current_file_descriptor_offset
  2959  95d6 a981                       lda #dos_filemode_end_of_directory
  2960  95d8 9db9bc                     sta dos_file_descriptors + dos_filedescriptor_offset_mode ,x
  2961                          
  2962  95db aef9bc                     ldx dos_current_file_descriptor_offset
  2963  95de bdb9bc                     lda dos_file_descriptors + dos_filedescriptor_offset_mode,x
  2964                          
  2965  95e1 38                         sec
  2966  95e2 60                         rts
  2967                          
  2968                          drce_not_eof:
  2969                          
  2970                                  +Checkpoint "drce_not_eof CHECK<1/3>"
  2971                          
  2972                                  ;; Ignore zero-length filenames (corresponding to empty directory entries)
  2973                                  ;;
  2974  95e3 ad4fbc                     lda dos_dirent_longfilename_length
  2975  95e6 c900                       cmp #0
  2976  95e8 f009                       beq l_dos_readdir
  2977                          
  2978                                  +Checkpoint "drce_not_eof CHECK<2/3>"
  2979                          
  2980  95ea ad50bc                     lda dos_dirent_shortfilename
  2981  95ed f004                       beq l_dos_readdir
  2982  95ef c920                       cmp #$20
  2983  95f1 d003                       bne +
  2984                          l_dos_readdir:
  2985  95f3 4c1c94                     jmp dos_readdir
  2986                          +
  2987                                  +Checkpoint "drce_not_eof CHECK<3/3>"
  2988                          
  2989                          !if DEBUG_HYPPO {
  2990                                  ldx dos_dirent_longfilename_length
  2991                                  jsr lfndebug
  2992                          }
  2993                          
  2994  95f6 38                         sec
  2995  95f7 60                         rts
  2996                          
  2997                          ;;         ========================
  2998                          
  2999                          !if DEBUG_HYPPO {
  3000                          lfndebug:
  3001                                  ;; requires .X to be set
  3002                                  ;;
  3003                                                                  ;; convert .X to char-representation for display
  3004                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  3005                                  sty fnmsg1-5
  3006                                  stx fnmsg1-4
  3007                          
  3008                                  ;; Show what we have in the filename so far
  3009                                  ;;
  3010                                  phx        ;; safekeep
  3011                          
  3012                                  ldx #29
  3013                          drce23: lda dos_dirent_longfilename,x
  3014                                  jsr makeprintable
  3015                                  sta fnmsg1,x
  3016                                  dex
  3017                                  bpl drce23
  3018                          
  3019                                  plx        ;; unsafekeep
  3020                          
  3021                                  jsr checkpoint
  3022                                  !8 0
  3023                                  !text "LFN(xx): " ;; the "xx" can be replaced with the name_length
  3024                          fnmsg1: !text ".............................." ;; BG: why only 30 chars?
  3025                                  !8 0
  3026                          
  3027                                  rts
  3028                          }
  3029                          
  3030                          ;;         ========================
  3031                          
  3032                          drd_deleted_or_invalid_entry:
  3033                          
  3034                          !if DEBUG_HYPPO {
  3035                                  tax
  3036                                                                  ;; convert .X to char-representation for display
  3037                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  3038                                  sty ddie+0
  3039                                  stx ddie+1
  3040                          
  3041                                  jsr checkpoint
  3042                                  !8 0
  3043                          ddie:   !text "xx drd_deleted_or_invalid_entry"
  3044                                  !8 0
  3045                          }
  3046                          	
  3047  95f8 202396                     jsr dos_readdir_advance_to_next_entry
  3048  95fb 9003                       bcc +
  3049  95fd 4c1c94                     jmp dos_readdir
  3050                          +
  3051  9600 4c7192                     jmp dos_return_error_already_set
  3052                          
  3053                          ;;         ========================
  3054                          
  3055                          lfn_piece_offsets:
  3056  9603 000d1a2734                 !8 13*0,13*1,13*2,13*3,13*4
  3057                          
  3058                          ;;         ========================
  3059                          
  3060                          dos_dirent_compare_name_to_requested:
  3061                          
  3062                                  ;; print debug message showing what we are comparing
  3063                          
  3064                                  ;; print filename for debug
  3065                          
  3066                                  ;; Do the cheap check of comparing the lengths first
  3067                                  ;;
  3068  9608 ad4fbc                     lda dos_dirent_longfilename_length
  3069  960b cd66bc                     cmp dos_requested_filename_len
  3070  960e d011                       bne dff3
  3071                          
  3072                                  ;; lengths match, so compare bytes
  3073                                  ;; XXX - Needs to support * and ?
  3074                                  ;; see http:;;6502.org/source/strings/patmatch.htm for a routine to take
  3075                                  ;; inspiration from.
  3076                                  ;;
  3077  9610 ae4fbc                     ldx dos_dirent_longfilename_length
  3078  9613 ca                         dex
  3079  9614 bd0fbc             dff4:   lda dos_dirent_longfilename,x
  3080  9617 dd67bc                     cmp dos_requested_filename,x
  3081  961a d005                       bne dff3
  3082  961c ca                         dex
  3083  961d 10f5                       bpl dff4
  3084                          
  3085                                  ;; File names match, so return success
  3086                          
  3087                                  +Checkpoint "Found the file..."
  3088                          
  3089  961f 38                         sec
  3090  9620 60                         rts
  3091                          
  3092                          dff3:
  3093                                  ;; file names don't match, so return failure
  3094  9621 18                         clc
  3095  9622 60                         rts
  3096                          
  3097                          ;;         ========================
  3098                          
  3099                          dos_readdir_advance_to_next_entry:
  3100                          
  3101  9623 acf9bc                     ldy dos_current_file_descriptor_offset
  3102                          
  3103  9626 18                         clc
  3104  9627 b9c3bc                     lda dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +0,y
  3105  962a 6920                       adc #$20 ;; length of FAT32/VFAT directory entry
  3106  962c 99c3bc                     sta dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +0,y
  3107  962f d00b                       bne dratne_done
  3108                          
  3109                                  ;; Increment upper byte
  3110                                  ;;
  3111  9631 b9c4bc                     lda dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +1,y
  3112  9634 1a                         inc
  3113  9635 c901                       cmp #$01
  3114  9637 d005                       bne drce_end_of_sector
  3115  9639 99c4bc                     sta dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +1,y
  3116                          
  3117                          dratne_done:
  3118  963c 38                         sec
  3119  963d 60                         rts
  3120                          
  3121                          ;;         ========================
  3122                          
  3123                          drce_end_of_sector:
  3124                          
  3125                                  ;; Reset pointer back to start of sector
  3126                                  ;;
  3127  963e a900                       lda #$00
  3128  9640 99c4bc                     sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+1,y
  3129                          
  3130  9643 20ff96                     jsr dos_file_advance_to_next_sector
  3131  9646 60                         rts
  3132                          
  3133                          ;;         ========================
  3134                          
  3135                          dos_set_current_file_from_dirent:
  3136                          
  3137                                  ;; copy start cluster from dirent to start and current cluster
  3138                                  ;;
  3139  9647 200893                     jsr dos_get_free_descriptor
  3140  964a 20bb96                     jsr dos_get_file_descriptor_offset
  3141  964d b003                       bcs +
  3142  964f 4c7192                     jmp dos_return_error_already_set
  3143                          +
  3144                                  ;; set disk id
  3145                                  ;;
  3146  9652 ad03bc                     lda dos_disk_current_disk
  3147  9655 9db8bc                     sta dos_file_descriptors+dos_filedescriptor_offset_diskid,x
  3148                          
  3149                                  ;; set current cluster to start cluster
  3150                                  ;;
  3151  9658 a000                       ldy #0
  3152                          dscffd1:
  3153  965a b95dbc                     lda dos_dirent_cluster,y
  3154  965d 9dbabc                     sta dos_file_descriptors+dos_filedescriptor_offset_startcluster,x
  3155  9660 9dbebc                     sta dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
  3156  9663 e8                         inx
  3157  9664 c8                         iny
  3158  9665 c004                       cpy #4
  3159  9667 d0f1                       bne dscffd1
  3160                          
  3161  9669 20bb96                     jsr dos_get_file_descriptor_offset
  3162  966c b003                       bcs +
  3163  966e 4c7192                     jmp dos_return_error_already_set
  3164                          +
  3165                          
  3166                                  ;; set disk id
  3167                                  ;;
  3168  9671 ad03bc                     lda dos_disk_current_disk
  3169  9674 9db8bc                     sta dos_file_descriptors+dos_filedescriptor_offset_diskid,x
  3170                          
  3171                                  ;; set mode
  3172                                  ;;
  3173  9677 a900                       lda #dos_filemode_readonly
  3174  9679 9db9bc                     sta dos_file_descriptors+dos_filedescriptor_offset_mode,x
  3175                          
  3176                                  ;; set sector in cluster (set to 0)
  3177                                  ;;
  3178  967c a900                       lda #$00
  3179  967e 9dc2bc                     sta dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,x
  3180                          
  3181                                  ;; set offset in sector (set to 0)
  3182                                  ;;
  3183  9681 9dc3bc                     sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+0,x
  3184  9684 9dc4bc                     sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+1,x
  3185                          
  3186                                  ;; Get length of file, so that we can
  3187                                  ;; limit load to reported length of file, instead assuming cluster
  3188                                  ;; chain is correct length, and file ends on a cluster boundary
  3189  9687 a203                       ldx #$03
  3190  9689 bd61bc             -       lda dos_dirent_length,x
  3191  968c 9dabbc                     sta dos_bytes_remaining,x
  3192  968f ca                         dex
  3193  9690 10f7                       bpl -
  3194                          	
  3195  9692 38                         sec
  3196  9693 60                         rts
  3197                          
  3198                          ;;         ========================
  3199                          
  3200                          dos_open_current_file:
  3201                          
  3202                                  ;; copy start cluster to current cluster, and zero position in file
  3203                                  ;;
  3204  9694 20bb96                     jsr dos_get_file_descriptor_offset
  3205  9697 b003                       bcs +
  3206  9699 4c7192                     jmp dos_return_error_already_set
  3207                          +
  3208                                  ;; Copy start cluster to current cluster
  3209                                  ;;
  3210  969c a003                       ldy #3
  3211  969e bdbabc             docf1:  lda dos_file_descriptors + dos_filedescriptor_offset_startcluster   ,x
  3212  96a1 9dbebc                     sta dos_file_descriptors + dos_filedescriptor_offset_currentcluster ,x
  3213  96a4 e8                         inx
  3214  96a5 88                         dey
  3215  96a6 10f6                       bpl docf1
  3216                          
  3217  96a8 20bb96                     jsr dos_get_file_descriptor_offset
  3218  96ab a900                       lda #$00
  3219                          
  3220                                  ;; sectorincluster, offsetinsector, fileoffset are contiguous, which allows
  3221                                  ;; us to clear these more efficiently.
  3222                                  ;;
  3223  96ad a006                       ldy #6
  3224  96af 9dc2bc             docf2:  sta dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,x
  3225  96b2 e8                         inx
  3226  96b3 88                         dey
  3227  96b4 d0f9                       bne docf2
  3228                          
  3229  96b6 20bb96                     jsr dos_get_file_descriptor_offset
  3230                          
  3231  96b9 38                         sec
  3232  96ba 60                         rts
  3233                          
  3234                          ;;         ========================
  3235                          
  3236                                  ;; Load A & X with the offset of the current file descriptor, relative to
  3237                                  ;; dos_file_descriptors.
  3238                          
  3239                          dos_get_file_descriptor_offset:
  3240                          
  3241  96bb adf8bc                     lda dos_current_file_descriptor
  3242  96be c904                       cmp #4
  3243  96c0 b007                       bcs dos_bad_file_descriptor
  3244  96c2 0a                         asl
  3245  96c3 0a                         asl
  3246  96c4 0a                         asl
  3247  96c5 0a                         asl
  3248  96c6 aa                         tax
  3249  96c7 38                         sec
  3250  96c8 60                         rts
  3251                          
  3252                          ;;         ========================
  3253                          
  3254                          dos_bad_file_descriptor:
  3255                          
  3256  96c9 a989                       lda #dos_errorcode_invalid_file_descriptor
  3257  96cb 4c6e92                     jmp dos_return_error
  3258                          
  3259                          ;;         ========================
  3260                          
  3261                          dos_set_current_cluster_from_file:
  3262                          
  3263                                  ;; copy cluster number in file to current cluster
  3264                                  ;;
  3265  96ce 20bb96                     jsr dos_get_file_descriptor_offset
  3266  96d1 901d                       bcc l2_dos_return_error_already_set
  3267                          
  3268  96d3 a000                       ldy #$00
  3269  96d5 bdbebc             dfrcs1: lda dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
  3270  96d8 99b3bc                     sta dos_current_cluster,y
  3271  96db e8                         inx
  3272  96dc c8                         iny
  3273  96dd c004                       cpy #$04
  3274  96df d0f4                       bne dfrcs1
  3275  96e1 60                         rts
  3276                          
  3277                          ;;         ========================
  3278                          
  3279                          dos_file_read_current_sector:
  3280                          
  3281  96e2 20bb96                     jsr dos_get_file_descriptor_offset
  3282  96e5 20ce96                     jsr dos_set_current_cluster_from_file
  3283  96e8 20ae92                     jsr dos_cluster_to_sector
  3284                          
  3285                                  ;; Add sector within cluster
  3286                                  ;;
  3287  96eb 20bb96                     jsr dos_get_file_descriptor_offset
  3288  96ee b003                       bcs gotFDOffset
  3289                          l2_dos_return_error_already_set:
  3290  96f0 4c7192                     jmp dos_return_error_already_set
  3291                          gotFDOffset:
  3292                          
  3293                                  ;; Set A to the offset of the sectorincluster field of the current
  3294                                  ;; file descriptor
  3295                                  ;;
  3296  96f3 090a                       ora #dos_filedescriptor_offset_sectorincluster
  3297                          
  3298                                  ;; Now put that offset in y, so that we can load the sector number in the
  3299                                  ;; current cluster for the current file descriptor
  3300                                  ;;
  3301  96f5 a8                         tay
  3302  96f6 b9b8bc                     lda dos_file_descriptors,y
  3303                          
  3304                                  ;; add sector number in cluster to current sector number (which is the
  3305                                  ;; start of the cluster)
  3306                                  ;;
  3307  96f9 20229b                     jsr sdsector_add_uint8
  3308                          
  3309  96fc 4cd89f                     jmp sd_readsector
  3310                          
  3311                          ;;         ========================
  3312                          
  3313                          dos_file_advance_to_next_sector:
  3314                          
  3315                                  ;; Increment file position offset by 2 pages
  3316                                  ;;
  3317  96ff aef9bc                     ldx dos_current_file_descriptor_offset
  3318                          
  3319  9702 bdc5bc                     lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0 ,x
  3320  9705 18                         clc
  3321  9706 6902                       adc #$02
  3322  9708 9dc5bc                     sta dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0 ,x
  3323  970b 9008                       bcc dfatns1
  3324  970d fec6bc                     inc dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1 ,x
  3325  9710 d003                       bne dfatns1
  3326  9712 fec7bc                     inc dos_file_descriptors + dos_filedescriptor_offset_fileoffset+2 ,x
  3327                          dfatns1:
  3328                          
  3329                                  ;; increase sector
  3330                                  ;;
  3331  9715 fec2bc                     inc dos_file_descriptors + dos_filedescriptor_offset_sectorincluster ,x
  3332  9718 bdc2bc                     lda dos_file_descriptors + dos_filedescriptor_offset_sectorincluster ,x
  3333  971b ac04bc                     ldy dos_disk_table_offset
  3334                          
  3335  971e d916bb                     cmp dos_disk_table + fs_fat32_sectors_per_cluster ,y
  3336                          
  3337                                  ;; and if necessary, advance to next cluster
  3338                                  ;;
  3339  9721 f002                       beq dos_file_advance_to_next_cluster
  3340  9723 38                         sec
  3341  9724 60                         rts
  3342                          
  3343                          ;;         ========================
  3344                          
  3345                          dos_file_advance_to_next_cluster:
  3346                          
  3347                                  ;; set to sector 0 in cluster
  3348                                  ;;
  3349  9725 acf9bc                     ldy dos_current_file_descriptor_offset
  3350  9728 a900                       lda #$00
  3351  972a 99c2bc                     sta dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,y
  3352                          
  3353                                  ;; read chained cluster number for fs_clusternumber
  3354                          
  3355                                  ;; FAT32 uses 32-bit cluster numbers.
  3356                                  ;; the text below may be misleading, as we have 8 sectors per cluster
  3357                                  ;; 512 / 4 = 128 cluster numbers per sector.
  3358                                  ;; To get the sector of the FAT containin a particular
  3359                                  ;; cluster entry, we thus need to shift the cluster number
  3360                                  ;; right 7 bits.  Then we add the start sector number of the FAT.
  3361                          
  3362  972d 20ce96                     jsr dos_set_current_cluster_from_file
  3363                          
  3364                                  ;; copy cluster to sector number
  3365                                  ;;
  3366  9730 a203                       ldx #$03
  3367                          dfanc1:
  3368  9732 bdb3bc                     lda dos_current_cluster,x
  3369  9735 9dafbc                     sta dos_current_sector,x
  3370  9738 ca                         dex
  3371  9739 10f7                       bpl dfanc1
  3372                          
  3373                                  ;; Remember low byte of cluster number so that we can pull the
  3374                                  ;; cluster number for the next cluster out of the FAT sector
  3375                                  ;;
  3376  973b adb3bc                     lda dos_current_cluster
  3377  973e 8d04bf                     sta dos_scratch_byte_1
  3378                          
  3379  9741 200298                     jsr dos_cluster_to_fat_sector
  3380                          
  3381  9744 20e797             	jsr dos_remember_sd_sector
  3382                          	
  3383                                  ;; copy from current cluster to SD sector address register
  3384                                  ;;
  3385  9747 a203                       ldx #$03
  3386  9749 08                         php
  3387                          dfanc41:
  3388  974a bdb3bc                     lda dos_current_cluster,x
  3389  974d 9d81d6                     sta $d681,x
  3390  9750 ca                         dex
  3391  9751 10f7                       bpl dfanc41
  3392                          
  3393                          dfanc44:
  3394  9753 28                         plp
  3395  9754 bdb3bc                     lda dos_current_cluster,x
  3396  9757 6900                       adc #$00
  3397  9759 9db3bc                     sta dos_current_cluster,x
  3398  975c 08                         php
  3399  975d e8                         inx
  3400  975e e004                       cpx #$04
  3401  9760 d0f1                       bne dfanc44
  3402                          
  3403  9762 28                         plp
  3404                          
  3405                                  ;; read FAT sector
  3406                                  ;;
  3407  9763 20d89f                     jsr sd_readsector
  3408  9766 b003                       bcs @readSectorOk
  3409  9768 4c7192                     jmp dos_return_error_already_set
  3410                          @readSectorOk:
  3411                          
  3412  976b 20c39f                     jsr sd_map_sectorbuffer
  3413                          
  3414                                  ;; now read the right four bytes out.
  3415                                  ;; cluster number needs to be shifted left 2 bits.
  3416                                  ;; we only need the lowest order byte.
  3417                                  ;; Get low byte of old cluster number from dos_scratch_byte_1
  3418                                  ;; where we put it.
  3419                                  ;;
  3420  976e ad04bf                     lda dos_scratch_byte_1
  3421  9771 0a                         asl
  3422  9772 0a                         asl
  3423  9773 aa                         tax
  3424                          
  3425                                  ;; get offset to current cluster field in current file descriptor ...
  3426  9774 adf9bc                     lda dos_current_file_descriptor_offset
  3427  9777 0906                       ora #dos_filedescriptor_offset_currentcluster
  3428  9779 a8                         tay
  3429                          
  3430                                  ;; ... and keep it handy, because we will need it a few times
  3431                                  ;;
  3432  977a 8c05bf                     sty dos_scratch_byte_2
  3433                          
  3434                                  ;; get offset of current cluster number field in file descriptor
  3435                                  ;; so that we can write the new cluster number in there.
  3436                                  ;;
  3437  977d ac05bf                     ldy dos_scratch_byte_2
  3438                          
  3439  9780 a300                       ldz #$00
  3440  9782 ad04bf                     lda dos_scratch_byte_1
  3441  9785 2940                       and #$40
  3442  9787 d00f                       bne dfanc_high
  3443                          
  3444  9789 bd00de             dfanc6: lda sd_sectorbuffer,x
  3445  978c 99b8bc                     sta dos_file_descriptors,y
  3446  978f e8                         inx
  3447  9790 c8                         iny
  3448  9791 1b                         inz
  3449  9792 c204                       cpz #$04
  3450  9794 d0f3                       bne dfanc6
  3451  9796 800d                       bra dfanc_check
  3452                          
  3453                          dfanc_high:
  3454  9798 bd00df                     lda sd_sectorbuffer+$100,x
  3455  979b 99b8bc                     sta dos_file_descriptors,y
  3456  979e e8                         inx
  3457  979f c8                         iny
  3458  97a0 1b                         inz
  3459  97a1 c204                       cpz #$04
  3460  97a3 d0f3                       bne dfanc_high
  3461                          
  3462                          dfanc_check:
  3463                                  ;; check that resulting cluster number is valid.
  3464                          
  3465                          ;;         jsr debug_show_cluster_number
  3466                          
  3467                                  ;; get current cluster field address again
  3468                                  ;;
  3469  97a5 ac05bf                     ldy dos_scratch_byte_2
  3470                          
  3471                                  ;; First, only the lower 28-bits are valid
  3472                                  ;;
  3473  97a8 b9bbbc                     lda dos_file_descriptors+3,y
  3474  97ab 290f                       and #$0f
  3475  97ad 99bbbc                     sta dos_file_descriptors+3,y
  3476                          
  3477                                  ;; Now check for special values:
  3478                                  ;; cluster 0 is invalid
  3479                                  ;;
  3480  97b0 b9bbbc                     lda dos_file_descriptors+3,y
  3481  97b3 19babc                     ora dos_file_descriptors+2,y
  3482  97b6 19b9bc                     ora dos_file_descriptors+1,y
  3483  97b9 19b8bc                     ora dos_file_descriptors,y
  3484  97bc c900                       cmp #$00
  3485  97be f01f                       beq dfanc_fail
  3486                          
  3487                                  ;; $FFFFFF7 = bad cluster
  3488                                  ;; $FFFFFFF = end of file
  3489                                  ;; (we'll treat anything from $FFFFFF0-F as bad/invalid for simplicity)
  3490  97c0 b9bbbc                     lda dos_file_descriptors+3,y
  3491  97c3 c90f                       cmp #$0f
  3492  97c5 d013                       bne dfanc_ok
  3493  97c7 b9babc                     lda dos_file_descriptors+2,y
  3494  97ca 39b9bc                     and dos_file_descriptors+1,y
  3495  97cd c9ff                       cmp #$ff
  3496  97cf d009                       bne dfanc_ok
  3497  97d1 b9b8bc                     lda dos_file_descriptors,y
  3498  97d4 29f0                       and #$f0
  3499  97d6 c9f0                       cmp #$f0
  3500  97d8 f005                       beq dfanc_fail
  3501                          
  3502                          dfanc_ok:
  3503                                  ;; cluster number is okay
  3504  97da 20f397             	jsr dos_restore_sd_sector
  3505  97dd 38                         sec
  3506  97de 60                         rts
  3507                          
  3508                          dfanc_fail:
  3509  97df 20f397             	jsr dos_restore_sd_sector
  3510  97e2 a985                       lda #dos_errorcode_invalid_cluster
  3511  97e4 4c6e92                     jmp dos_return_error
  3512                          
  3513                          	;; Some routines disturb the current SD card sector in the buffer,
  3514                          	;; but where the caller might not expect or want this to happen.
  3515                          	;; For this reason we have the following convenience routines for
  3516                          	;; stashing and restoring the current ready sector.
  3517                          dos_remember_sd_sector:
  3518  97e7 a203               	ldx #3
  3519  97e9 bd81d6             -	lda $d681,x
  3520  97ec 9d55bd             	sta dos_stashed_sd_sector_number,x
  3521  97ef ca                 	dex
  3522  97f0 10f7               	bpl -
  3523  97f2 60                 	rts
  3524                          
  3525                          dos_restore_sd_sector:
  3526  97f3 a203               	ldx #3
  3527  97f5 bd55bd             -	lda dos_stashed_sd_sector_number,x
  3528  97f8 9d81d6             	sta $d681,x
  3529  97fb ca                 	dex
  3530  97fc 10f7               	bpl -
  3531  97fe 20d89f             	jsr sd_readsector
  3532  9801 60                 	rts
  3533                          	
  3534                          	
  3535                          ;;         ========================
  3536                          
  3537                          dos_cluster_to_fat_sector:
  3538                                  ;; Take dos_current_cluster, as a cluster number,
  3539                                  ;; and compute the absolute sector number on the SD card
  3540                                  ;; where that cluster must live.
  3541                                  ;; INPUT: dos_current_cluster = cluster number
  3542                                  ;; OUTPUT: dos_current_cluster = absolute sector, which
  3543                                  ;;         contains the FAT sector that has the FAT entry
  3544                                  ;;         corresponding to the requested cluster number.
  3545                          
  3546                                  ;; shift right 7 times = divide by 128
  3547                                  ;;
  3548  9802 a007                       ldy #$07
  3549  9804 18                 dfanc2: clc
  3550  9805 6eb6bc                     ror dos_current_cluster+3
  3551  9808 6eb5bc                     ror dos_current_cluster+2
  3552  980b 6eb4bc                     ror dos_current_cluster+1
  3553  980e 6eb3bc                     ror dos_current_cluster+0
  3554  9811 88                         dey
  3555  9812 d0f0                       bne dfanc2
  3556                          
  3557                                  ;; add start of partition offset
  3558                                  ;;
  3559  9814 ac04bc                     ldy dos_disk_table_offset
  3560  9817 a200                       ldx #$00
  3561  9819 18                         clc
  3562  981a 08                         php
  3563  981b 28                 dfanc3: plp
  3564  981c bdb3bc                     lda dos_current_cluster,x
  3565  981f 7900bb                     adc dos_disk_table + fs_start_sector ,y
  3566  9822 9db3bc                     sta dos_current_cluster,x
  3567  9825 08                         php
  3568  9826 c8                         iny
  3569  9827 e8                         inx
  3570  9828 e004                       cpx #$04
  3571  982a d0ef                       bne dfanc3
  3572  982c 28                         plp
  3573                          
  3574                                  ;; add start of fat offset
  3575                                  ;;
  3576  982d ac04bc                     ldy dos_disk_table_offset
  3577  9830 a200                       ldx #$00
  3578  9832 18                         clc
  3579  9833 08                         php
  3580  9834 28                 dfanc4: plp
  3581  9835 bdb3bc                     lda dos_current_cluster,x
  3582  9838 790dbb                     adc dos_disk_table + fs_fat32_system_sectors ,y
  3583  983b 9db3bc                     sta dos_current_cluster,x
  3584  983e 08                         php
  3585  983f c8                         iny
  3586  9840 e8                         inx
  3587  9841 e002                       cpx #$02
  3588  9843 d0ef                       bne dfanc4
  3589                          
  3590  9845 28                         plp
  3591                          
  3592  9846 60                         rts
  3593                          
  3594                          ;;         ========================
  3595                          
  3596                          !if DEBUG_HYPPO {
  3597                          dos_print_current_cluster:
  3598                          
  3599                                  ;; prints a message to the screen
  3600                                  ;;
  3601                                  ldx #<msg_clusternumber
  3602                                  ldy #>msg_clusternumber
  3603                                  jsr printmessage
  3604                                  ldy #$00
  3605                                  ldz dos_current_cluster+3
  3606                                  jsr printhex
  3607                                  ldz dos_current_cluster+2
  3608                                  jsr printhex
  3609                                  ldz dos_current_cluster+1
  3610                                  jsr printhex
  3611                                  ldz dos_current_cluster+0
  3612                                  jsr printhex
  3613                          
  3614                                  +Checkpoint "dos_print_current_cluster"
  3615                          
  3616                                  rts
  3617                          }
  3618                          
  3619                          ;;         ========================
  3620                          
  3621                          dos_readfileintomemory:
  3622                          
  3623                                  ;; assumes that filename is already set using "dos_setname", which
  3624                                  ;; copies filename string into "dos_requested_filename",
  3625                                  ;;        and sets length into "dos_requested_filename_length".
  3626                                  ;;
  3627                                  ;; assumes that the 32-bit load-address pointer is set by
  3628                                  ;; storing load-address at "dos_file_loadaddress+{0-3}"
  3629                          
  3630                                  ;; print some debug information
  3631                                  ;;
  3632                                  ;;         jsr dos_print_current_cluster
  3633                          
  3634                                  ;; Clear number of sectors read
  3635  9847 a200                       ldx #$00
  3636  9849 8ea9bc                     stx dos_sectorsread
  3637  984c 8eaabc                     stx dos_sectorsread+1
  3638                          
  3639  984f 20c293                     jsr dos_findfirst
  3640  9852 900e                       bcc l_dos_return_error_already_set
  3641                                  ;; close directory now that we have what we were looking for ...
  3642  9854 205b93                     jsr dos_closefile
  3643                          
  3644  9857 20a193                     jsr dos_openfile
  3645  985a 9006                       bcc l_dos_return_error_already_set
  3646                          
  3647  985c 20c39f                     jsr sd_map_sectorbuffer
  3648                          
  3649  985f 4c6598                     jmp drfim_sector_loop
  3650                          
  3651                          l_dos_return_error_already_set:
  3652  9862 4c7192                     jmp dos_return_error_already_set
  3653                          
  3654                          ;;         ========================
  3655                          
  3656                          drfim_sector_loop:
  3657                          
  3658  9865 20e296                     jsr dos_file_read_current_sector
  3659  9868 903d                       bcc drfim_eof
  3660                          
  3661                                  ;; copy sector to memory
  3662                                  ;;
  3663                          
  3664                                  ;; Work out how many bytes of this page we need to read
  3665  986a 20ad98                     jsr dos_load_y_based_on_dos_bytes_remaining
  3666                          
  3667  986d a200                       ldx #$00
  3668  986f a300                       ldz #$00
  3669                          
  3670                                  ;; Actually write the bytes to memory that have been loaded
  3671                          drfim_rr1:
  3672  9871 bd00de                     lda sd_sectorbuffer,x                ;; is $DE00
  3673  9874 ea9218                     sta [<dos_file_loadaddress],z
  3674  9877 1b                         inz ;; dest offset
  3675  9878 e8                         inx ;; src offset
  3676  9879 88                         dey ;; bytes in page to copy
  3677  987a d0f5                       bne drfim_rr1
  3678                          
  3679  987c e319                       inw <dos_file_loadaddress+1
  3680                          
  3681                                  ;; Work out how many bytes of this page we need to read
  3682  987e 20ad98                     jsr dos_load_y_based_on_dos_bytes_remaining
  3683                          
  3684                                  ;; Actually write the bytes to memory that have been loaded
  3685                          drfim_rr1b:
  3686  9881 bd00df                     lda sd_sectorbuffer+$100,x        ;; is $DF00
  3687  9884 ea9218                     sta [<dos_file_loadaddress],z
  3688  9887 1b                         inz ;; dest offset
  3689  9888 e8                         inx ;; src offset
  3690  9889 88                         dey ;; bytes in page to copy
  3691  988a d0f5                       bne drfim_rr1b
  3692                          
  3693  988c 20ff96                     jsr dos_file_advance_to_next_sector
  3694  988f 9016                       bcc drfim_eof
  3695                          
  3696                                  ;; We only allow loading into a 16MB space
  3697                                  ;; Provided that we check the load address before starting,
  3698                                  ;; this ensures that a user-land request cannot load a huge file
  3699                                  ;; that eventually overwrites the hypervisor and results in privilege
  3700                                  ;; escalation.
  3701                                  ;; This restriction to a 16MB space is implemented by only incrementing the middle 2 bytes of
  3702                                  ;; the address, instead of all 3 upper bytes.
  3703                                  ;;
  3704  9891 e319                       inw <dos_file_loadaddress+1
  3705                          
  3706                                  ;; Increment number of sectors read (16 bit valie)
  3707                                  ;;
  3708  9893 eea9bc                     inc dos_sectorsread
  3709  9896 d0cd                       bne drfim_sector_loop
  3710                          
  3711  9898 eeaabc                     inc dos_sectorsread+1
  3712                                  ;; see if there is another sector
  3713  989b d0c8                       bne drfim_sector_loop
  3714                          
  3715  989d 205b93                     jsr dos_closefile
  3716                          
  3717                                  ;; File is >65535 sectors (32MB), report error
  3718                                  ;;
  3719  98a0 a983                       lda #dos_errorcode_file_too_long
  3720  98a2 4c6e92                     jmp dos_return_error
  3721                          
  3722                          ;;         ========================
  3723                          
  3724                          drfim_eof_pop_pc:
  3725  98a5 68                         pla
  3726  98a6 68                         pla
  3727                          
  3728                          drfim_eof:
  3729                          
  3730  98a7 205b93                     jsr dos_closefile
  3731  98aa 4c6792                     jmp dos_return_success
  3732                          
  3733                          dos_load_y_based_on_dos_bytes_remaining:
  3734  98ad a000                       ldy #$00
  3735  98af adacbc                     lda dos_bytes_remaining+1
  3736  98b2 0dadbc                     ora dos_bytes_remaining+2
  3737  98b5 0daebc                     ora dos_bytes_remaining+3
  3738  98b8 d00e                       bne +
  3739  98ba adabbc                     lda dos_bytes_remaining+0
  3740                                  ;; If no more bytes to read, then jump to EOF
  3741  98bd f0e6                       beq drfim_eof_pop_pc
  3742  98bf acabbc                     ldy dos_bytes_remaining+0
  3743  98c2 a900                       lda #$00
  3744  98c4 8dabbc                     sta  dos_bytes_remaining+0
  3745  98c7 60                         rts
  3746                          +
  3747  98c8 adacbc                     lda dos_bytes_remaining+1
  3748  98cb 38                         sec
  3749  98cc e901                       sbc #$01
  3750  98ce 8dacbc                     sta dos_bytes_remaining+1
  3751  98d1 adadbc                     lda dos_bytes_remaining+2
  3752  98d4 e900                       sbc #0
  3753  98d6 8dadbc                     sta dos_bytes_remaining+2
  3754  98d9 adaebc                     lda dos_bytes_remaining+3
  3755  98dc e900                       sbc #0
  3756  98de 8daebc                     sta dos_bytes_remaining+3
  3757  98e1 60                         rts
  3758                          
  3759                          
  3760                          dos_readfile:
  3761                          
  3762                          ;; 	ldx dos_bytes_remaining+3 
  3763                          ;; 	jsr checkpoint_bytetohex
  3764                          ;; 	sty lenhex+0
  3765                          ;; 	stx lenhex+1
  3766                          ;; 	ldx dos_bytes_remaining+2
  3767                          ;; 	jsr checkpoint_bytetohex
  3768                          ;; 	sty lenhex+2
  3769                          ;; 	stx lenhex+3
  3770                          ;; 	ldx dos_bytes_remaining+1
  3771                          ;; 	jsr checkpoint_bytetohex
  3772                          ;; 	sty lenhex+4
  3773                          ;; 	stx lenhex+5
  3774                          ;; 	ldx dos_bytes_remaining+0
  3775                          ;; 	jsr checkpoint_bytetohex
  3776                          ;; 	sty lenhex+6
  3777                          ;; 	stx lenhex+7
  3778                          	
  3779                          ;; 	jsr checkpoint
  3780                          ;; 	!8 0
  3781                          ;; 	ascii("$")
  3782                          ;; lenhex:	
  3783                          ;; 	ascii("%%%%%%%% bytes remaining.")
  3784                          ;; 	!8 0
  3785                          	
  3786  98e2 adabbc             	lda dos_bytes_remaining+0
  3787  98e5 0dacbc             	ora dos_bytes_remaining+1
  3788  98e8 0dadbc             	ora dos_bytes_remaining+2
  3789  98eb 0daebc             	ora dos_bytes_remaining+3
  3790  98ee d00a               	bne +
  3791                          
  3792                          	;; End of file: So zero bytes returned
  3793  98f0 a900               	lda #$00
  3794  98f2 8d41d6             	sta hypervisor_x
  3795  98f5 8d42d6             	sta hypervisor_y
  3796  98f8 18                 	clc
  3797  98f9 60                 	rts
  3798                          	
  3799                          +
  3800                          	;; Indicate how many bytes we are returning
  3801  98fa a200               	ldx #<$0200
  3802  98fc a002               	ldy #>$0200
  3803                          	
  3804  98fe adadbc             	lda dos_bytes_remaining+2
  3805  9901 0daebc             	ora dos_bytes_remaining+3
  3806  9904 d017               	bne +   ;; lots more to read
  3807  9906 adacbc             	lda dos_bytes_remaining+1
  3808  9909 c902               	cmp #2
  3809  990b b010               	bcs +   ;; at least a whole sector more to read
  3810                          
  3811                          	;; Only a fractional part of a sector to read, so zero out remaining
  3812                          
  3813                          	;; Update number of bytes for fractional sector read
  3814  990d aeabbc             	ldx dos_bytes_remaining+0
  3815  9910 acacbc             	ldy dos_bytes_remaining+1
  3816                          	
  3817  9913 a900               	lda #$00
  3818  9915 8dabbc             	sta dos_bytes_remaining+0
  3819                          	;; Actually make it look like 1 sector to go, so we decrement that to zero
  3820                          	;; immediately below
  3821  9918 a902               	lda #$02
  3822  991a 8dacbc             	sta dos_bytes_remaining+1
  3823                          	;; FALL THROUGH
  3824                          +
  3825                          	
  3826                          	;; Deduct one sector from the remaining
  3827  991d adacbc             	lda dos_bytes_remaining+1
  3828  9920 38                 	sec
  3829  9921 e902               	sbc #2
  3830  9923 8dacbc             	sta dos_bytes_remaining+1
  3831  9926 adadbc             	lda dos_bytes_remaining+2
  3832  9929 e900               	sbc #0
  3833  992b 8dadbc             	sta dos_bytes_remaining+2
  3834  992e adaebc             	lda dos_bytes_remaining+3
  3835  9931 e900               	sbc #0
  3836  9933 8daebc             	sta dos_bytes_remaining+3
  3837                          
  3838                          	;; Store number of bytes read in X and Y for calling process
  3839  9936 8e41d6             	stx hypervisor_x
  3840  9939 8c42d6             	sty hypervisor_y
  3841                          	
  3842                          	;; Now read sector and return
  3843                          	
  3844  993c 20c39f                     jsr sd_map_sectorbuffer
  3845  993f 20e296                     jsr dos_file_read_current_sector
  3846  9942 b001                       bcs drf_gotsector
  3847  9944 60                 	rts
  3848                          	
  3849                          drf_gotsector:
  3850                          	;; Then advance to next sector.
  3851                          	;; Ignore the error, as the EOF will get picked up on the next call.
  3852                          
  3853  9945 20ff96             	jsr dos_file_advance_to_next_sector
  3854                          
  3855  9948 38                 	sec
  3856  9949 60                 	rts
  3857                          	
  3858                          	
  3859                          ;;         ========================
  3860                          
  3861                          dos_setname:
  3862                          
  3863                                  ;; INPUT: .X .Y = pointer to filename,
  3864                                  ;;                 filename string must be terminated with $00
  3865                                  ;;                 filename string must be <= $3F chars
  3866                          
  3867  994a 8600                       stx <dos_scratch_vector
  3868  994c 8401                       sty <(dos_scratch_vector+1)
  3869  994e a000                       ldy #$00
  3870                          
  3871  9950 b100               lr11:   lda (<dos_scratch_vector),y
  3872  9952 9967bc                     sta dos_requested_filename,y
  3873  9955 f00e                       beq dsn_eon
  3874  9957 c8                         iny
  3875  9958 c040                       cpy #$40
  3876  995a d0f4                       bne lr11
  3877                          
  3878  995c a900                       lda #0
  3879  995e 8d66bc                     sta dos_requested_filename_len
  3880  9961 a981                       lda #dos_errorcode_name_too_long
  3881  9963 18                         clc
  3882  9964 60                         rts
  3883                          
  3884                          dsn_eon:
  3885  9965 8c66bc                     sty dos_requested_filename_len
  3886                          
  3887  9968 38                         sec
  3888  9969 60                         rts
  3889                          
  3890                          ;;         ========================
  3891                          
  3892                          dos_d81detach:
  3893                          	;; Detaches both drive 0 and drive 1
  3894                          	
  3895  996a a900                       lda #$00
  3896  996c 8d8bd6                     sta $d68b
  3897                          
  3898                                  ;; Mark it as unmounted (but preserve other flags for remounting, e.g., if it should be write-enabled)
  3899  996f ad11bd                     lda currenttask_d81_image0_flags
  3900  9972 0901                       ora #d81_image_flag_mounted
  3901  9974 4901                       eor #d81_image_flag_mounted
  3902  9976 8d11bd                     sta currenttask_d81_image0_flags
  3903                          
  3904                                  ;; But we leave the file name there, in case someone wants to re-mount the image.
  3905                                  ;; This is exactly what happens when a process is unfrozen: dos_d81detach is called,
  3906                                  ;; followed by dos_d81attach, after first retrieving the filename
  3907  9979 38                         sec
  3908  997a 60                         rts
  3909                          
  3910                          dos_d81attach0:
  3911                          
  3912                          	;;  Always works on drive 0
  3913                          	
  3914                                  ;; Assumes only that D81 file name has been set with dos_setname.
  3915                                  ;;
  3916  997b 20b593                     jsr dos_findfile
  3917  997e b004                       bcs d81a1
  3918                          
  3919  9980 a988                       lda #dos_errorcode_file_not_found
  3920  9982 18                         clc
  3921  9983 60                         rts
  3922                          
  3923                          ;;         ========================
  3924                          
  3925                          d81a1:  ;; Why do we call closefile here?
  3926                                  ;; -> because dos_findfile/first only closes on file_not_found
  3927  9984 205b93                     jsr dos_closefile
  3928                          
  3929  9987 20459a                     jsr dos_d81check
  3930  998a b001                       bcs d81a1a
  3931  998c 60                         rts
  3932                          d81a1a:	
  3933                          
  3934                                  ;; copy sector number from $D681 to $D68c
  3935                                  ;;
  3936  998d a203                       ldx #$03
  3937  998f bd81d6             l94d:   lda $d681,x		;; resolved sector number
  3938  9992 9d8cd6                     sta $d68c,x  		;; sector number of disk image #0
  3939  9995 ca                         dex
  3940  9996 10f7                       bpl l94d
  3941                          	
  3942                                  // disable real floppy 0
  3943  9998 ada1d6                     lda $d6a1
  3944  999b 29fe                       and #$fe
  3945  999d 8da1d6                     sta $d6a1
  3946                                  
  3947                                  // Set flags to indicate it is mounted (and read-write)
  3948                                  // But don't mess up the flags for the 2nd drive
  3949  99a0 ad8bd6             	lda $d68b
  3950  99a3 29b8               	and #%10111000
  3951  99a5 0907                       ora #$07
  3952  99a7 8d8bd6                     sta $d68b
  3953                          
  3954                          	;; And set the MEGAfloppy flag if the file is ~5.5MiB long
  3955  99aa ad2ebf             	lda d81_clustercount+1
  3956  99ad c905               	cmp #$05
  3957  99af d00a               	bne not_mega_floppy2
  3958                          
  3959  99b1 ad8bd6             	lda $d68b
  3960  99b4 29b8               	and #%10111000
  3961  99b6 0947                       ora #$47
  3962  99b8 8d8bd6             	sta $d68b
  3963                          
  3964                          not_mega_floppy2:	
  3965                          
  3966                                  +Checkpoint "dos_d81attach0 <success>"
  3967                          
  3968                                  ;; Save name and set mount flag for disk image in process descriptor block
  3969  99bb a901                       lda #d81_image_flag_mounted
  3970  99bd 8d11bd                     sta currenttask_d81_image0_flags
  3971                          
  3972  99c0 ae66bc                     ldx dos_requested_filename_len
  3973                          
  3974                                  ;; Check if the filename of the disk image is too long
  3975  99c3 e020                       cpx #d81_image_max_namelen
  3976  99c5 b013                       bcs @d81NameTooLongForProcessDescriptor
  3977                          
  3978                                  ;; Name not too long, save name and length
  3979  99c7 8e13bd                     stx currenttask_d81_image0_namelen
  3980  99ca a200                       ldx #0
  3981  99cc bd67bc             -       lda dos_requested_filename,x
  3982  99cf 9d15bd                     sta currenttask_d81_image0_name,x
  3983  99d2 e8                         inx
  3984  99d3 ec13bd                     cpx currenttask_d81_image0_namelen
  3985  99d6 d0f4                       bne -
  3986                          
  3987  99d8 38                         sec
  3988  99d9 60                         rts
  3989                          
  3990                          @d81NameTooLongForProcessDescriptor:
  3991                                  ;; Name is too long, so don't save it.
  3992                                  ;; This means that the disk image will unmount on freeze, and will not re-mount after
  3993                                  ;; XXX - This should probably be an error.
  3994  99da a900                       lda #0
  3995  99dc 8d13bd                     sta currenttask_d81_image0_namelen
  3996                          
  3997  99df 38                         sec
  3998  99e0 60                         rts
  3999                          
  4000                          dos_d81attach1:
  4001                          
  4002                                  ;; Assumes only that D81 file name has been set with dos_setname.
  4003                                  ;;
  4004  99e1 20b593                     jsr dos_findfile
  4005  99e4 b004                       bcs d81a1b
  4006                          
  4007  99e6 a988                       lda #dos_errorcode_file_not_found
  4008  99e8 18                         clc
  4009  99e9 60                         rts
  4010                          
  4011                          ;;         ========================
  4012                          
  4013                          d81a1b: ;; Why do we call closefile here?
  4014                                  ;; -> because dos_findfile/first only closes on file_not_found
  4015  99ea 205b93                     jsr dos_closefile
  4016                          
  4017  99ed 20459a                     jsr dos_d81check
  4018  99f0 b001                       bcs d81a1ab
  4019  99f2 60                         rts
  4020                          d81a1ab:	
  4021                          
  4022                                  ;; copy sector number from $D681 to $D690
  4023                                  ;;
  4024  99f3 a203                       ldx #$03
  4025  99f5 bd81d6             l94db:   lda $d681,x		;; resolved sector number
  4026  99f8 9d90d6                     sta $d690,x  		;; sector number of disk image #1
  4027  99fb ca                         dex
  4028  99fc 10f7                       bpl l94db
  4029                          		
  4030                                  // disable real floppy 1
  4031  99fe ada1d6                     lda $d6a1
  4032  9a01 29fb                       and #$fb
  4033  9a03 8da1d6                     sta $d6a1
  4034                          
  4035                                  // Set flags to indicate it is mounted (and read-write)
  4036                                  // But don't mess up the flags for the 1st drive
  4037  9a06 ad8bd6             	lda $d68b
  4038  9a09 2947               	and #%01000111
  4039  9a0b 0938                       ora #$38
  4040  9a0d 8d8bd6                     sta $d68b
  4041                          
  4042                          	;; And set the MEGAfloppy flag if the file is 5500KB long
  4043  9a10 ad2ebf             	lda d81_clustercount+1
  4044  9a13 c905               	cmp #$05
  4045  9a15 d008               	bne not_mega_floppy2b
  4046                          
  4047  9a17 ad8bd6             	lda $d68b
  4048  9a1a 0980                       ora #$80
  4049  9a1c 8d8bd6             	sta $d68b
  4050                          
  4051                          not_mega_floppy2b:	
  4052                          	
  4053                                  +Checkpoint "dos_d81attach1 <success>"
  4054                          
  4055                                  ;; Save name and set mount flag for disk image in process descriptor block
  4056  9a1f a901                       lda #d81_image_flag_mounted
  4057  9a21 8d12bd                     sta currenttask_d81_image1_flags
  4058                          
  4059  9a24 ae66bc                     ldx dos_requested_filename_len
  4060                          
  4061                                  ;; Check if the filename of the disk image is too long
  4062  9a27 e020                       cpx #d81_image_max_namelen
  4063  9a29 b013                       bcs @d81NameTooLongForProcessDescriptor1
  4064                          
  4065                                  ;; Name not too long, save name and length
  4066  9a2b 8e14bd                     stx currenttask_d81_image1_namelen
  4067  9a2e a200                       ldx #0
  4068  9a30 bd67bc             -       lda dos_requested_filename,x
  4069  9a33 9d35bd                     sta currenttask_d81_image1_name,x
  4070  9a36 e8                         inx
  4071  9a37 ec14bd                     cpx currenttask_d81_image1_namelen
  4072  9a3a d0f4                       bne -
  4073                          
  4074  9a3c 38                         sec
  4075  9a3d 60                         rts
  4076                          
  4077                          @d81NameTooLongForProcessDescriptor1:
  4078                                  ;; Name is too long, so don't save it.
  4079                                  ;; This means that the disk image will unmount on freeze, and will not re-mount after
  4080                                  ;; XXX - This should probably be an error.
  4081  9a3e a900                       lda #0
  4082  9a40 8d14bd                     sta currenttask_d81_image1_namelen
  4083                          
  4084  9a43 38                         sec
  4085  9a44 60                         rts
  4086                          
  4087                          	
  4088                          dos_d81check:	
  4089                                  ;; now we need to check that the file is long enough,
  4090                                  ;; and also that the clusters are contiguous.
  4091                          
  4092                                  ;; Start by opening the file
  4093                                  ;;
  4094  9a45 204796                     jsr dos_set_current_file_from_dirent
  4095  9a48 9005                       bcc @fileNotOpenedOk
  4096                          
  4097  9a4a 20a193                     jsr dos_openfile
  4098  9a4d b003                       bcs @fileOpenedOk
  4099                          @fileNotOpenedOk:
  4100  9a4f 4c209b                     jmp nod81
  4101                          @fileOpenedOk:
  4102                          
  4103                                  ;; work out how many clusters we need
  4104                                  ;; We need 1600 sectors, so halve for every zero tail
  4105                                  ;; bit in sectors per cluster.  we can do this because
  4106                                  ;; clusters in FAT must be 2^n sectors.
  4107                                  ;;
  4108  9a52 a900                       lda #$00
  4109  9a54 8d2dbf                     sta d81_clustercount
  4110  9a57 8d2ebf                     sta d81_clustercount+1
  4111  9a5a a940                       lda #<1600
  4112  9a5c 8d2bbf                     sta d81_clustersneeded
  4113  9a5f a906                       lda #>1600
  4114  9a61 8d2cbf                     sta d81_clustersneeded+1
  4115                          
  4116                                  ;; get sectors per cluster of disk
  4117                                  ;;
  4118  9a64 ae04bc                     ldx dos_disk_table_offset
  4119  9a67 bd16bb                     lda dos_disk_table+fs_fat32_sectors_per_cluster,x
  4120  9a6a 4b                         taz
  4121                          
  4122  9a6b 6b                 l94:    tza
  4123  9a6c 2901                       and #$01
  4124  9a6e d00c                       bne d81firstcluster
  4125  9a70 6b                         tza
  4126  9a71 4a                         lsr
  4127  9a72 4b                         taz
  4128  9a73 4e2cbf                     lsr d81_clustersneeded+1
  4129  9a76 6e2bbf                     ror d81_clustersneeded
  4130  9a79 4c6b9a                     jmp l94
  4131                          
  4132                          d81firstcluster:
  4133                                  ;; Get current cluster of D81 file, so that
  4134                                  ;; we can check that clusters in file are contiguous
  4135                                  ;;
  4136  9a7c aef9bc                     ldx dos_current_file_descriptor_offset
  4137  9a7f a000                       ldy #0
  4138                          
  4139  9a81 bdbebc             l94b:   lda dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
  4140  9a84 9927bf                     sta d81_clusternumber,y
  4141  9a87 e8                         inx
  4142  9a88 c8                         iny
  4143  9a89 c004                       cpy #4
  4144  9a8b d0f4                       bne l94b
  4145                          
  4146                          d81nextcluster:
  4147                                  ;; Now read through clusters and make sure that all is
  4148                                  ;; well.
  4149                          
  4150                                  ;; check that it matches expected cluster number
  4151                                  ;;
  4152  9a8d aef9bc                     ldx dos_current_file_descriptor_offset
  4153  9a90 a000                       ldy #0
  4154                          
  4155  9a92 bdbebc             l94a:   lda dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
  4156  9a95 d927bf                     cmp d81_clusternumber,y
  4157  9a98 d07f                       bne d81isfragged
  4158  9a9a e8                         inx
  4159  9a9b c8                         iny
  4160  9a9c c004                       cpy #4
  4161  9a9e d0f2                       bne l94a
  4162                          
  4163                                  ;; increment number of clusters found so far
  4164                                  ;;
  4165  9aa0 ee2dbf                     inc d81_clustercount
  4166  9aa3 d003                       bne l96
  4167  9aa5 ee2ebf                     inc d81_clustercount+1
  4168                          l96:
  4169                          
  4170                                  ;; increment expected cluster number
  4171                                  ;;
  4172  9aa8 18                         clc
  4173  9aa9 ad27bf                     lda d81_clusternumber
  4174  9aac 6901                       adc #$01
  4175  9aae 8d27bf                     sta d81_clusternumber
  4176  9ab1 ad28bf                     lda d81_clusternumber+1
  4177  9ab4 6900                       adc #$00
  4178  9ab6 8d28bf                     sta d81_clusternumber+1
  4179  9ab9 ad29bf                     lda d81_clusternumber+2
  4180  9abc 6900                       adc #$00
  4181  9abe 8d29bf                     sta d81_clusternumber+2
  4182  9ac1 ad2abf                     lda d81_clusternumber+3
  4183  9ac4 6900                       adc #$00
  4184  9ac6 8d2abf                     sta d81_clusternumber+3
  4185                          
  4186  9ac9 202597                     jsr dos_file_advance_to_next_cluster
  4187  9acc b0bf                       bcs d81nextcluster
  4188                          
  4189                                  ;; The above continues until EOF is reached, so clear DOS
  4190                                  ;; error after.
  4191                                  ;;
  4192  9ace a900                       lda #$00
  4193  9ad0 8dfabc                     sta dos_error_code
  4194                          
  4195                                  +Checkpoint "dos_d81attach <measured end of image>"
  4196                          
  4197  9ad3 205b93                     jsr dos_closefile
  4198                          
  4199                                  ;; we have read to end of D81 file, and it is contiguous
  4200                                  ;; now check that it is the right length
  4201                          
  4202                          	;; First check if we read enough for 85 tracks x 64 sectors x 2 sides = 5,570,560 bytes
  4203                          	;; = 1,360 clusters = $0550 clusters
  4204                          	;; XXX - This currently assumes 8 sectors per cluster = 4KB sectors
  4205  9ad6 ad2dbf             	lda d81_clustercount
  4206  9ad9 c950               	cmp #$50
  4207  9adb d00f               	bne not_mega_floppy
  4208  9add ad2ebf             	lda d81_clustercount+1
  4209  9ae0 c905               	cmp #$05
  4210  9ae2 d008               	bne not_mega_floppy
  4211  9ae4 ad2fbf             	lda d81_clustercount+2
  4212  9ae7 0d30bf             	ora d81_clustercount+3
  4213  9aea f010               	beq is_mega_floppy
  4214                          
  4215                          not_mega_floppy:	
  4216                          	;; Is a 5.5MiB MEGA Floppy?
  4217                          	;; (These behave as double-sided 85-track 64-sector disks of 512 byte sectors,
  4218                          	;;  but with normal D81 directory format on side 0 of track 40.)
  4219                          	
  4220  9aec ad2bbf                     lda d81_clustersneeded
  4221  9aef cd2dbf                     cmp d81_clustercount
  4222  9af2 d01e                       bne d81wronglength
  4223                          
  4224  9af4 ad2cbf                     lda d81_clustersneeded+1
  4225  9af7 cd2ebf                     cmp d81_clustercount+1
  4226  9afa d016                       bne d81wronglength
  4227                          is_mega_floppy:	
  4228                          
  4229                          d81_is_good:	
  4230                                  ;; D81 is good.
  4231                          
  4232                                  ;; Get cluster number again, convert to sector, and copy to
  4233                                  ;; SD controller FDC emulation disk image offset registers
  4234                                  ;;
  4235  9afc aef9bc                     ldx dos_current_file_descriptor_offset
  4236  9aff a000                       ldy #0
  4237                          
  4238  9b01 bdbabc             l94c:   lda dos_file_descriptors+dos_filedescriptor_offset_startcluster,x
  4239  9b04 99b3bc                     sta dos_current_cluster,y
  4240  9b07 e8                         inx
  4241  9b08 c8                         iny
  4242  9b09 c004                       cpy #4
  4243  9b0b d0f4                       bne l94c
  4244                          
  4245  9b0d 20ae92                     jsr dos_cluster_to_sector
  4246                          
  4247  9b10 38                 	sec
  4248  9b11 60                 	rts
  4249                          	
  4250                          
  4251                          ;;         ========================
  4252                          
  4253                          d81wronglength:
  4254                                  +Checkpoint "dos_d81attach <wrong length>"
  4255                          
  4256  9b12 a98a                       lda #dos_errorcode_image_wrong_length
  4257  9b14 8dfabc                     sta dos_error_code
  4258  9b17 18                         clc
  4259  9b18 60                         rts
  4260                          
  4261                          ;;         ========================
  4262                          
  4263                          d81isfragged:
  4264                                  +Checkpoint "dos_d81attach <fragmented>"
  4265                          
  4266  9b19 a98b                       lda #dos_errorcode_image_fragmented
  4267  9b1b 8dfabc                     sta dos_error_code
  4268  9b1e 18                         clc
  4269  9b1f 60                         rts
  4270                          
  4271                          ;;         ========================
  4272                          
  4273                          nod81:
  4274                                  +Checkpoint "dos_d81attach <file not found>"
  4275                          
  4276  9b20 18                         clc
  4277  9b21 60                         rts
  4278                          
  4279                          ;;         ========================
  4280                          
  4281                          sdsector_add_uint8:
  4282                          
  4283  9b22 48                         pha
  4284  9b23 a900                       lda #0
  4285  9b25 aa                         tax
  4286  9b26 a8                         tay
  4287  9b27 4b                         taz
  4288  9b28 68                         pla
  4289                                  ;; FALL THROUGH to sdsector_add_uint32
  4290                          
  4291                          sdsector_add_uint32:
  4292                          
  4293                                  ;; Add the 32-bit value contained in A,X,Y,Z to
  4294                                  ;; $D681-$D684, the SD card sector number.
  4295                                  ;;
  4296  9b29 18                         clc
  4297  9b2a 6d81d6                     adc $D681
  4298  9b2d 8d81d6                     sta $D681
  4299  9b30 8a                         txa
  4300  9b31 6d82d6                     adc $d682
  4301  9b34 8d82d6                     sta $d682
  4302  9b37 98                         tya
  4303  9b38 6d83d6                     adc $d683
  4304  9b3b 8d83d6                     sta $d683
  4305  9b3e 6b                         tza
  4306  9b3f 6d84d6                     adc $d684
  4307  9b42 8d84d6                     sta $d684
  4308  9b45 a300                       ldz #$00
  4309  9b47 60                         rts
  4310                          
  4311                          ;;         ========================
  4312                          
  4313                          sdsector_add_uint32_from_disktable:
  4314                          
  4315  9b48 0d04bc                     ora dos_disk_table_offset
  4316  9b4b a8                         tay
  4317  9b4c a200                       ldx #$00
  4318  9b4e 18                         clc
  4319  9b4f 08                         php
  4320  9b50 28                 l23:    plp
  4321  9b51 bd81d6                     lda $D681,x
  4322  9b54 7900bb                     adc dos_disk_table,y
  4323  9b57 9d81d6                     sta $D681,x
  4324  9b5a 08                         php
  4325  9b5b c8                         iny
  4326  9b5c e8                         inx
  4327  9b5d e004                       cpx #$04
  4328  9b5f d0ef                       bne l23
  4329  9b61 28                         plp
  4330  9b62 60                         rts
  4331                          
  4332                          ;;         ========================
  4333                          
  4334                          makeprintable:
  4335                                  ;; Convert unprintable ASCII characters to question marks
  4336                          
  4337  9b63 c920                       cmp #$20
  4338  9b65 9005                       bcc unprintable
  4339  9b67 c97f                       cmp #$7f
  4340  9b69 b001                       bcs unprintable
  4341  9b6b 60                         rts
  4342                          
  4343                          unprintable:
  4344  9b6c a93f                       lda #$3f
  4345  9b6e 60                         rts
  4346                          
  4347                          ;;         ========================

; ******** Source: src/hyppo/main.asm

; ******** Source: dos_write.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          
     5                          ;;     Routines for writing to FAT file system.
     6                          ;;     ---------------------------------------------------------------- */
     7                          
     8                          dos_find_contiguous_free_space:
     9                                  ;; Find a piece of free space in the specified file system
    10                                  ;; (dos_default_disk), and return the first cluster number
    11                                  ;; if it can be found.
    12                                  ;;
    13                                  ;; INPUT: dos_dirent_length = # of clusters required
    14                                  ;; OUTPUT: dos_opendir_cluster = first cluster
    15                                  ;; C flag set on success, clear on failure.
    16                                  ;;
    17                                  ;; FAT32 file systems have the expected first cluster free
    18                                  ;; stored in the 2nd sector of the file system at offset
    19                                  ;; $1EC (actually, this may point to the last allocated cluster).
    20                                  ;; This field is only a suggestion however, to accelerate allocation,
    21                                  ;; and thus should not be relied upon, but rather to allow quick
    22                                  ;; skipping of the already allocated area of disk.
    23                                  ;;
    24                                  ;; The number of clusters we need to allocate is to be provided in
    25                                  ;; dos_opendir_cluster as a 32-bit value, thus allowing for files
    26                                  ;; upto 2^32 * cluster size bytes long to be created.
    27                                  ;; (Note that in practice files are limited to 2GiB - 1 bytes for
    28                                  ;; total compatibility, and 4GiB -1 for fairly decent compatibility,
    29                                  ;; and 256GiB - 1 if we implement the FAT+ specification
    30                                  ;; (http:;;www.fdos.org/kernel/fatplus.txt.1) in the appropriate places
    31                                  ;; at some point, which we will likely do, as it is really very simple.
    32                                  ;; Mostly we just have to use 40 bit offsets for file lengths.
    33                          
    34                                  ;; Let's start with a completely naive algorithm:
    35                                  ;; 1. Begin at cluster 2. Reset # of contiguous clusters found to zero.
    36                                  ;;    Remember this cluster as candidatee starting point.
    37                                  ;; 2. If current cluster not free, advance to next cluster number, reset
    38                                  ;;    contiguous free cluster count.  Remember the newly advanced cluster
    39                                  ;;    number as candidate starting point.
    40                                  ;; 3. If current cluster is free, increase contiguous free clusters found.
    41                                  ;;    If equal to desired number, return candidate cluster number.
    42                                  ;; 4. Repeat 2 and 3 above until end of file system is reached (and return
    43                                  ;;    an error), or until step 3 has returned success.
    44                                  ;;
    45                                  ;; This algorithm can be made more efficient by using the last allocated
    46                                  ;; cluster number field as an alternative starting point, and only if that
    47                                  ;; fails, retrying beginning at cluster 2.
    48                          
    49                                  ;; So the state we need to keep track of is:
    50                                  ;; dos_opendir_cluster = current cluster we are considering as candidate starting point.
    51                                  ;; dos_file_loadaddress = current cluster being tested for vacancy.
    52                                  ;; dos_dirent_length = number of clusters required, in total.
    53                                  ;; dos_dirent_cluster = number of clusters required, from this point
    54                                  ;; (i.e., the total minus the number we have already found contiguously free).
    55                                  ;; current_disk[fs_fat32_cluster_count] = number of clusters in disk
    56                                  ;; (and thus the end point of our search).
    57                                  ;;
    58                                  ;; Other than that, we just need to advance our way linearly through the FAT sectors.
    59                                  ;; This is straight forward, as we can just read the first FAT sector, and then progress
    60                                  ;; our way through, until we reach the end.
    61                          
    62                                  ;; First, make sure we can see the sector buffer at $DE00-$DFFF
    63  9b6f 20c39f                     jsr sd_map_sectorbuffer
    64                          
    65                                  ;; 1. Start at cluster 2
    66  9b72 a902                       lda #$02
    67  9b74 8d09bc                     sta dos_opendir_cluster+0
    68  9b77 8d18bf                     sta dos_file_loadaddress+0
    69  9b7a a900                       lda #$00
    70  9b7c 8d0abc                     sta dos_opendir_cluster+1
    71  9b7f 8d0bbc                     sta dos_opendir_cluster+2
    72  9b82 8d0cbc                     sta dos_opendir_cluster+3
    73  9b85 8d19bf                     sta dos_file_loadaddress+1
    74  9b88 8d1abf                     sta dos_file_loadaddress+2
    75  9b8b 8d1bbf                     sta dos_file_loadaddress+3
    76                          
    77                          @tryNewStartingPointCandidate:
    78                          
    79                                  ;; Reset # of clusters still required
    80  9b8e a203                       ldx #$03
    81  9b90 bd61bc             @ll74:  lda dos_dirent_length, X
    82  9b93 9d5dbc                     sta dos_dirent_cluster, X
    83  9b96 ca                         dex
    84  9b97 10f7                       bpl @ll74
    85                          
    86                          @testIfClusterEmptyAfterReadingFATSector:
    87                                  ;; Read the appropriate sector of the FAT
    88                                  ;; To do this, we copy the target cluster number to
    89                                  ;; dos_current_cluster, and call dos_cluster_to_fat_sector.
    90                                  ;; This leaves the absolute sector number in
    91                                  ;; dos_current_cluster.
    92  9b99 a203                       ldx #$03
    93  9b9b bd18bf             @ll78:  lda dos_file_loadaddress, X
    94  9b9e 9db3bc                     sta dos_current_cluster, X
    95  9ba1 ca                         dex
    96  9ba2 10f7                       bpl @ll78
    97  9ba4 200298                     jsr dos_cluster_to_fat_sector
    98                                  ;; Now we have the sector # in dos_current_cluster
    99                                  ;; Copy to the SD card sector register, and do the read
   100  9ba7 a203                       ldx #$03
   101  9ba9 bdb3bc             @ll83:  lda dos_current_cluster, X
   102  9bac 9d81d6                     sta $D681, X
   103  9baf ca                         dex
   104  9bb0 10f7                       bpl @ll83
   105                          
   106                                  ;; Finally, do the read
   107  9bb2 a920                       lda #dos_errorcode_read_error
   108  9bb4 8dfabc                     sta dos_error_code
   109  9bb7 20d89f                     jsr sd_readsector
   110                                  ;; XXX - Fail on error
   111  9bba b001                       bcs @ll93
   112  9bbc 60                         rts
   113                          @ll93:
   114                          
   115                          @testIfClusterEmpty:
   116                                  ;; Here we have the sector read, and do the test on the contents of the cluster
   117                                  ;; entry.
   118                          
   119                                  ;; But first, check that the cluster number is valid:
   120                                  ;; 1. Get dos_disk_table_offset pointing correctly
   121  9bbd ae03bc                     ldx dos_disk_current_disk
   122  9bc0 207392                     jsr dos_set_current_disk
   123  9bc3 ae04bc                     ldx dos_disk_table_offset
   124                                  ;; 2. Compare cluster count to current cluster
   125  9bc6 a000                       ldy #$00
   126  9bc8 bd12bb             @ll128: lda dos_disk_table + fs_fat32_cluster_count + 0, X
   127  9bcb d918bf                     cmp dos_file_loadaddress, Y
   128  9bce d00d                       bne @notLastClusterOfFileSystem
   129  9bd0 e8                         inx
   130  9bd1 c8                         iny
   131  9bd2 c004                       cpy #$04
   132  9bd4 d0f2                       bne @ll128
   133                          
   134                                  ;; Return error due to lack of space
   135  9bd6 a98c                       lda #dos_errorcode_no_space
   136  9bd8 8dfabc                     sta dos_error_code
   137  9bdb 18                         clc
   138  9bdc 60                         rts
   139                          
   140                          @notLastClusterOfFileSystem:
   141                          
   142                                  ;; The offset in the sector is computed from the bottom
   143                                  ;; 7 bits of the cluster number * 4, to give an offset
   144                                  ;; in the 512 byte sector. Once we have the offset, OR the
   145                                  ;; four bytes of the cluster number together to test if = 0,
   146                                  ;; and thus empty.
   147  9bdd ad18bf                     lda dos_file_loadaddress+0
   148  9be0 0a                         asl
   149  9be1 0a                         asl
   150  9be2 a8                         tay
   151  9be3 ad18bf                     lda dos_file_loadaddress+0
   152  9be6 2940                       and #$40
   153  9be8 f00e                       beq @lowMoby
   154  9bea b900df                     lda $df00, y
   155  9bed 1901df                     ora $df01, y
   156  9bf0 1902df                     ora $df02, y
   157  9bf3 1903df                     ora $df03, y
   158  9bf6 800c                       bra @ll120
   159                          @lowMoby:
   160  9bf8 b900de                     lda $De00, y
   161  9bfb 1901de                     ora $De01, y
   162  9bfe 1902de                     ora $de02, y
   163  9c01 1903de                     ora $de03, y
   164                          @ll120:
   165                                  ;; Remember result of free-test
   166  9c04 aa                         tax
   167                          
   168                                  ;; Increment next cluster number we will look at
   169  9c05 ad18bf                     lda dos_file_loadaddress+0
   170  9c08 18                         clc
   171  9c09 6901                       adc #$01
   172  9c0b 8d18bf                     sta dos_file_loadaddress+0
   173  9c0e ad19bf                     lda dos_file_loadaddress+1
   174  9c11 6900                       adc #$00
   175  9c13 ad19bf                     lda dos_file_loadaddress+1
   176  9c16 ad1abf                     lda dos_file_loadaddress+2
   177  9c19 6900                       adc #$00
   178  9c1b ad1abf                     lda dos_file_loadaddress+2
   179  9c1e ad1bbf                     lda dos_file_loadaddress+3
   180  9c21 6900                       adc #$00
   181  9c23 ad1bbf                     lda dos_file_loadaddress+3
   182                          
   183                                  ;; If the cluster was not free, then reset search point
   184  9c26 e000                       cpx #$00
   185  9c28 f00e                       beq @thisClusterWasFree
   186  9c2a a203                       ldx #$03
   187  9c2c bd18bf             @ll160: lda dos_file_loadaddress, X
   188  9c2f 9d09bc                     sta dos_opendir_cluster, X
   189  9c32 ca                         dex
   190  9c33 10f7                       bpl @ll160
   191  9c35 4c8e9b                     jmp @tryNewStartingPointCandidate
   192                          
   193                          @thisClusterWasFree:
   194                                  ;; Decrement # of clusters still required
   195  9c38 ad5dbc                     lda dos_dirent_cluster+0
   196  9c3b 38                         sec
   197  9c3c e901                       sbc #$01
   198  9c3e 8d5dbc                     sta dos_dirent_cluster+0
   199  9c41 ad5ebc                     lda dos_dirent_cluster+1
   200  9c44 e900                       sbc #$00
   201  9c46 8d5ebc                     sta dos_dirent_cluster+1
   202  9c49 ad5fbc                     lda dos_dirent_cluster+2
   203  9c4c e900                       sbc #$00
   204  9c4e 8d5fbc                     sta dos_dirent_cluster+2
   205  9c51 ad60bc                     lda dos_dirent_cluster+3
   206  9c54 e900                       sbc #$00
   207  9c56 8d60bc                     sta dos_dirent_cluster+3
   208                                  ;; Now see if zero
   209  9c59 0d5fbc                     ora dos_dirent_cluster+2
   210  9c5c 0d5ebc                     ora dos_dirent_cluster+1
   211  9c5f 0d5dbc                     ora dos_dirent_cluster+0
   212  9c62 f00d                       beq @foundFreeSpace
   213                          
   214                                  ;; Nope, we still need more, so continue the search
   215                          
   216                                  ;; Then check if this next cluster is unallocated?
   217                                  ;; (If the cluster entry in the FAT will be in the same
   218                                  ;;  sector as the last, then don't waste time recomputing
   219                                  ;;  and reading the FAT sector number).
   220  9c64 ad18bf                     lda dos_file_loadaddress+0
   221  9c67 297f                       and #$7F
   222  9c69 d003                       bne @sameSector
   223  9c6b 4c999b                     jmp @testIfClusterEmptyAfterReadingFATSector
   224                          @sameSector:
   225  9c6e 4cbd9b                     jmp @testIfClusterEmpty
   226                          
   227                          @foundFreeSpace:
   228                                  ;; Found the requested space
   229  9c71 38                         sec
   230  9c72 60                         rts

; ******** Source: src/hyppo/main.asm
   381                          
   382                          ;; /*  -------------------------------------------------------------------
   383                          ;;     Virtual memory and memory management
   384                          ;;     ---------------------------------------------------------------- */

; ******** Source: mem.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          ;; Display error and infinite loop on page fault
     7                          page_fault:
     8  9c73 204aa2                     jsr reset_machine_state
     9  9c76 a2a3                       ldx #<msg_pagefault
    10  9c78 a09c                       ldy #>msg_pagefault
    11  9c7a 20c8a8                     jsr printmessage
    12  9c7d a000                       ldy #$00
    13                                  ;; Print PC
    14  9c7f ab49d6                     ldz $d649
    15  9c82 2041a9                     jsr printhex
    16  9c85 ab48d6                     ldz $d648
    17  9c88 2041a9                     jsr printhex
    18                                  ;; and MAPLO state
    19  9c8b ab4fd6                     ldz $d64f
    20  9c8e 2041a9                     jsr printhex
    21  9c91 ab4ad6                     ldz $d64a
    22  9c94 2041a9                     jsr printhex
    23  9c97 ab49d6                     ldz $d649
    24  9c9a 2041a9                     jsr printhex
    25                          
    26  9c9d ee20d0             pf1:    inc $d020
    27  9ca0 4c9d9c                     jmp pf1
    28                          
    29                          msg_pagefault:
    30  9ca3 5041474520464155...        !text "PAGE FAULT: PC=$$$$, MAP=$$.$$$$.00     "
    31                          
    32                          memory_trap:
    33  9ccb 78                         sei
    34  9ccc d8                         cld
    35  9ccd 29fe                       and #$fe
    36  9ccf aa                         tax
    37  9cd0 7cd39c                     jmp (memory_trap_table,x)
    38                          
    39                          memory_trap_table:
    40                                  ;; $00-$0E
    41  9cd3 5b9d                       !16 rom_writeprotect
    42  9cd5 539d                       !16 rom_writeenable
    43  9cd7 2f82                       !16 invalid_subfunction
    44  9cd9 2f82                       !16 invalid_subfunction
    45  9cdb 2f82                       !16 invalid_subfunction
    46  9cdd 2f82                       !16 invalid_subfunction
    47  9cdf 2f82                       !16 invalid_subfunction
    48  9ce1 2f82                       !16 invalid_subfunction
    49                          
    50                                  ;; $10-$1E
    51  9ce3 2f82                       !16 invalid_subfunction
    52  9ce5 2f82                       !16 invalid_subfunction
    53  9ce7 2f82                       !16 invalid_subfunction
    54  9ce9 2f82                       !16 invalid_subfunction
    55  9ceb 2f82                       !16 invalid_subfunction
    56  9ced 2f82                       !16 invalid_subfunction
    57  9cef 2f82                       !16 invalid_subfunction
    58  9cf1 2f82                       !16 invalid_subfunction
    59                          
    60                                  ;; $20-$2E
    61  9cf3 2f82                       !16 invalid_subfunction
    62  9cf5 2f82                       !16 invalid_subfunction
    63  9cf7 2f82                       !16 invalid_subfunction
    64  9cf9 2f82                       !16 invalid_subfunction
    65  9cfb 2f82                       !16 invalid_subfunction
    66  9cfd 2f82                       !16 invalid_subfunction
    67  9cff 2f82                       !16 invalid_subfunction
    68  9d01 2f82                       !16 invalid_subfunction
    69                          
    70                                  ;; $30-$3E
    71  9d03 2f82                       !16 invalid_subfunction
    72  9d05 2f82                       !16 invalid_subfunction
    73  9d07 2f82                       !16 invalid_subfunction
    74  9d09 2f82                       !16 invalid_subfunction
    75  9d0b 2f82                       !16 invalid_subfunction
    76  9d0d 2f82                       !16 invalid_subfunction
    77  9d0f 2f82                       !16 invalid_subfunction
    78  9d11 2f82                       !16 invalid_subfunction
    79                          
    80                                  ;; $40-$4E
    81  9d13 2f82                       !16 invalid_subfunction
    82  9d15 2f82                       !16 invalid_subfunction
    83  9d17 2f82                       !16 invalid_subfunction
    84  9d19 2f82                       !16 invalid_subfunction
    85  9d1b 2f82                       !16 invalid_subfunction
    86  9d1d 2f82                       !16 invalid_subfunction
    87  9d1f 2f82                       !16 invalid_subfunction
    88  9d21 2f82                       !16 invalid_subfunction
    89                          
    90                                  ;; $50-$5E
    91  9d23 2f82                       !16 invalid_subfunction
    92  9d25 2f82                       !16 invalid_subfunction
    93  9d27 2f82                       !16 invalid_subfunction
    94  9d29 2f82                       !16 invalid_subfunction
    95  9d2b 2f82                       !16 invalid_subfunction
    96  9d2d 2f82                       !16 invalid_subfunction
    97  9d2f 2f82                       !16 invalid_subfunction
    98  9d31 2f82                       !16 invalid_subfunction
    99                          
   100                                  ;; $60-$6E
   101  9d33 2f82                       !16 invalid_subfunction
   102  9d35 2f82                       !16 invalid_subfunction
   103  9d37 2f82                       !16 invalid_subfunction
   104  9d39 2f82                       !16 invalid_subfunction
   105  9d3b 2f82                       !16 invalid_subfunction
   106  9d3d 2f82                       !16 invalid_subfunction
   107  9d3f 2f82                       !16 invalid_subfunction
   108  9d41 2f82                       !16 invalid_subfunction
   109                          
   110                                  ;; $70-$7E
   111  9d43 2f82                       !16 invalid_subfunction
   112  9d45 2f82                       !16 invalid_subfunction
   113  9d47 2f82                       !16 invalid_subfunction
   114  9d49 2f82                       !16 invalid_subfunction
   115  9d4b 2f82                       !16 invalid_subfunction
   116  9d4d 2f82                       !16 invalid_subfunction
   117  9d4f 2f82                       !16 invalid_subfunction
   118  9d51 2f82                       !16 invalid_subfunction
   119                          
   120                          rom_writeenable:
   121  9d53 a904                       lda #$04
   122  9d55 1c7dd6                     trb hypervisor_feature_enables
   123  9d58 4c1082                     jmp return_from_trap_with_success
   124                          
   125                          rom_writeprotect:
   126  9d5b a904                       lda #$04
   127  9d5d 0c7dd6                     tsb hypervisor_feature_enables
   128  9d60 4c1082                     jmp return_from_trap_with_success
   129                          

; ******** Source: src/hyppo/main.asm
   386                          
   387                          ;; /*  -------------------------------------------------------------------
   388                          ;;     Task (process) management
   389                          ;;     ---------------------------------------------------------------- */

; ******** Source: task.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                  ;; Return the next free task ID
     7                                  ;; XXX - Task ID $FF is hypervisor/operating system
     8                                  ;; XXX - For now just lie, and always say task $00 is next.
     9                                  ;; We should have a process allocation table that we consult.
    10                                  ;; (actual suspended processes should be held on SD card in files)
    11                          
    12                          task_get_next_taskid:
    13                          
    14  9d63 a900                       lda #$00
    15  9d65 60                         rts
    16                          
    17                          ;;         ========================
    18                          
    19                          task_set_c64_memorymap:
    20                          
    21                                  ;; set contents of CPU registers for exit from hypervisor mode
    22                          
    23  9d66 a900                       lda #$00
    24  9d68 8d40d6                     sta hypervisor_a
    25  9d6b 8d41d6                     sta hypervisor_x
    26  9d6e 8d42d6                     sta hypervisor_y
    27  9d71 8d43d6                     sta hypervisor_z
    28  9d74 8d44d6                     sta hypervisor_b
    29  9d77 a9ff                       lda #$ff
    30  9d79 8d45d6                     sta hypervisor_spl
    31  9d7c a901                       lda #$01
    32  9d7e 8d46d6                     sta hypervisor_sph
    33  9d81 a9f7                       lda #$f7     ;; All flags except decimal mode
    34  9d83 8d47d6                     sta hypervisor_flags
    35  9d86 a900                       lda #$00
    36  9d88 8d4ad6                     sta hypervisor_maplolo
    37  9d8b 8d4bd6                     sta hypervisor_maplohi
    38  9d8e 8d4cd6                     sta hypervisor_maphilo
    39  9d91 8d4dd6                     sta hypervisor_maphihi
    40  9d94 8d4ed6                     sta hypervisor_maplomb
    41  9d97 8d4fd6                     sta hypervisor_maphimb
    42  9d9a a93f                       lda #$3f
    43  9d9c 8d50d6                     sta hypervisor_cpuport00
    44  9d9f 8d51d6                     sta hypervisor_cpuport01
    45                          
    46  9da2 a900                       lda #$00
    47  9da4 8d52d6                     sta hypervisor_iomode    ;; C64 IO map
    48                          
    49                                  ;; Unmap SD sector buffer
    50  9da7 a982                       lda #$82
    51  9da9 8d80d6                     sta $D680
    52                          
    53                                  ;; Unmap 2nd KB colour RAM
    54  9dac a901                       lda #$01
    55  9dae 1c30d0                     trb $d030
    56                          
    57                          	;; Clear 16-bit text mode, but keep CRT emulation and horizontal filter settings
    58  9db1 a9d7               	lda #$d7
    59  9db3 1c54d0                     trb $d054	
    60                          	
    61                                  ;; 40 column mode normal C64 screen
    62  9db6 a900                       lda #$00
    63  9db8 8d30d0                     sta $d030
    64  9dbb 8d31d0                     sta $d031
    65  9dbe ad00dd                     lda $dd00
    66  9dc1 0903                       ora #$03
    67  9dc3 8d00dd                     sta $dd00
    68  9dc6 a9c0                       lda #$c0    ;; also enable raster delay to match rendering with interrupts more correctly
    69  9dc8 8d5dd0                     sta $d05d
    70  9dcb a91b                       lda #$1b
    71  9dcd 8d11d0                     sta $d011
    72  9dd0 a9c8                       lda #$c8
    73  9dd2 8d16d0                     sta $d016
    74  9dd5 a914                       lda #$14
    75  9dd7 8d18d0                     sta $d018
    76                          
    77                                  ;; XXX - disable C65 ROM maps
    78  9dda 60                         rts
    79                          
    80                          ;;         ========================
    81                          
    82                          task_set_pc_to_reset_vector:
    83                          
    84                                  ;; Set PC from $FFFC in ROM, i.e., $802FFFC
    85  9ddb a2fc                       ldx #<reset_vector
    86  9ddd a0ff                       ldy #>reset_vector
    87  9ddf a302                       ldz #$02
    88  9de1 a900                       lda #$00
    89  9de3 2044aa                     jsr longpeek
    90  9de6 ad00bc                     lda hyppo_scratchbyte0
    91  9de9 8d48d6                     sta hypervisor_pcl
    92  9dec a2fc                       ldx #<reset_vector
    93  9dee e8                         inx
    94  9def a0ff                       ldy #>reset_vector
    95  9df1 a302                       ldz #$02
    96  9df3 a900                       lda #$00
    97  9df5 2044aa                     jsr longpeek
    98  9df8 ad00bc                     lda hyppo_scratchbyte0
    99  9dfb 8d49d6                     sta hypervisor_pch
   100                          
   101  9dfe 60                         rts
   102                          
   103                          ;;         ========================
   104                          
   105                                  ;; Set dummy C64 NMI vector
   106                                  ;; This avoid a nasty crash if NMI is called during hyppo
   107                                  ;; Points to a RTI instruction in $FEC1
   108                          
   109                          task_dummy_nmi_vector:
   110                          
   111  9dff a9c1                       lda #<$FEC1
   112  9e01 8d1803                     sta $0318
   113  9e04 a9fe                       lda #>$FEC1
   114  9e06 8d1903                     sta $0319
   115  9e09 60                         rts
   116                          
   117                          ;;         ========================
   118                          
   119                                  ;; Set all page entries and current page number to all zeroes
   120                                  ;; so that we don't think any page is loaded.
   121                                  ;; XXX - Is all zeroes the best value here?  Physical page 0 is $00000000, which
   122                                  ;; is in chipram. It might be legitimate to try to map that.  Perhaps we should set
   123                                  ;; the pages to $FFFF instead (but that would reduce available VM space by 16KB).
   124                                  ;; Physical page 0 is probably reasonable for now. We can revisit as required.
   125                          
   126                          task_clear_pagetable:
   127                          
   128  9e0a a900                       lda #$00
   129  9e0c a25d                       ldx #<hypervisor_vm_currentpage_lo
   130  9e0e 9d00d6             tcp1:   sta $d600,x
   131  9e11 e8                         inx
   132  9e12 e070                       cpx #<hypervisor_vm_pagetable3_physicalpage_hi+1
   133  9e14 d0f8                       bne tcp1
   134  9e16 60                         rts
   135                          
   136                          ;;         ========================
   137                          
   138                          task_erase_processcontrolblock:
   139                          
   140                                  ;; Erase process control block
   141                                  ;;
   142  9e17 a200                       ldx #$00
   143  9e19 8a                         txa
   144  9e1a 9d00bd             tabs1:        sta currenttask_block,x
   145  9e1d e8                         inx
   146  9e1e d0fa                       bne tabs1
   147  9e20 200a9e                     jsr task_clear_pagetable
   148                          
   149                                  ;; Mark all files as closed
   150                          
   151  9e23 4cc28f                     jmp dos_clear_filedescriptors
   152                          
   153                          ;;         ========================
   154                          
   155                          task_new_processcontrolblock:
   156                          
   157  9e26 20179e                     jsr task_erase_processcontrolblock
   158  9e29 20639d                     jsr task_get_next_taskid
   159  9e2c 8d00bd                     sta currenttask_id
   160  9e2f 60                         rts
   161                          
   162                          ;;         ========================
   163                          
   164                                  ;; Initialise memory to indicate a new blank task.
   165                                  ;; (actually, it will be a task preconfigured for C64/C65 mode)
   166                          
   167                          task_asblankslate:
   168                          
   169  9e30 20269e                     jsr task_new_processcontrolblock
   170                          
   171  9e33 20669d                     jsr task_set_c64_memorymap
   172  9e36 60                         rts
   173                          
   174                          ;;         ========================
   175                          
   176                          unstable_illegal_opcode_trap:
   177                          kill_opcode_trap:
   178                          	;; For now, just launch the freezer if an illegal opcode is hit that
   179                          	;; we can't work with.
   180                          	;; (Ideally later we will allow some clever tricks with at least the KIL
   181                          	;; opcodes, e.g., to call the hypervisor from C64 mode)
   182                          
   183                          	;; FALL THROUGH
   184                          	
   185                          restore_press_trap:
   186                          
   187                                  ;; Clear colour RAM at $DC00 flag, as it causes no end of trouble
   188  9e37 a901                       lda #$01
   189  9e39 1c30d0                     trb $D030
   190                          	;; and DMA audio
   191  9e3c a900               	lda #$00
   192  9e3e 8d11d7             	sta $d711
   193                          
   194                                  ;; Freeze to slot 0
   195  9e41 aa                 	tax ;;   <- uses $00 in A from above
   196  9e42 a8                 	tay ;;   <- uses $00 in A from above
   197  9e43 204686                     jsr freeze_to_slot
   198                          
   199                                  ;; Load freeze program
   200  9e46 209ba5                     jsr attempt_loadcharrom
   201  9e49 20b5a5                     jsr attempt_loadc65rom
   202                          
   203  9e4c a2fe                       ldx #<txt_FREEZER
   204  9e4e a0b2                       ldy #>txt_FREEZER
   205  9e50 204a99                     jsr dos_setname
   206                          
   207                                  ;; Prepare 32-bit pointer for loading freezer program ($000007FF)
   208                                  ;; (i.e. $0801 - 2 byte header, so we can use a normal PRG file)
   209                                  ;;
   210  9e53 a900                       lda #$00
   211  9e55 851a                       sta <dos_file_loadaddress+2
   212  9e57 851b                       sta <dos_file_loadaddress+3
   213  9e59 a907                       lda #$07
   214  9e5b 8519                       sta <dos_file_loadaddress+1
   215  9e5d a9ff                       lda #$ff
   216  9e5f 8518                       sta <dos_file_loadaddress+0
   217                          
   218                          @tryAgain:
   219  9e61 204798                     jsr dos_readfileintomemory
   220  9e64 ee20d0                     inc $d020
   221  9e67 90f8                       bcc @tryAgain
   222  9e69 ce20d0                     dec $d020
   223                          
   224  9e6c 20669d                     jsr task_set_c64_memorymap
   225  9e6f 20ff9d                     jsr task_dummy_nmi_vector
   226                          
   227                                  ;; set entry point and memory config
   228  9e72 a90d                       lda #<2061
   229  9e74 8d48d6                     sta hypervisor_pcl
   230  9e77 a908                       lda #>2061
   231  9e79 8d49d6                     sta hypervisor_pch
   232                          
   233                                  ;; Make $FFD2 vector at $0326 point to an RTS, so that if the freezer
   234                                  ;; is built using CC65's C64 profile, the call to $FFD2 to set lower-case mode
   235                                  ;; doesn't do something terrible.
   236  9e7c a9ff                       lda #<$03FF
   237  9e7e 8d2603                     sta $0326
   238  9e81 a903                       lda #>$03FF
   239  9e83 8d2703                     sta $0327
   240  9e86 a960                       lda #$60 ;; = RTS
   241  9e88 8dff03                     sta $03FF
   242                          
   243                                  ;; Similarly neuter IRQ/BRK and NMI vectors, in part because the call to $FFD2 above
   244                                  ;; will do a CLI, and thus any pending IRQ will immediately trigger, and since the freezer
   245                                  ;; is running without the kernal initialising things, it would otherwise use the IRQ
   246                                  ;; vector from whatever was being frozen.  Clearly this is a bad thing.
   247  9e8b a9fc                       lda #<$03FC
   248  9e8d 8d1403                     sta $0314
   249  9e90 8d1603                     sta $0316
   250  9e93 8d1803                     sta $0318
   251  9e96 a903                       lda #>$03FC
   252  9e98 8d1503                     sta $0315
   253  9e9b 8d1703                     sta $0317
   254  9e9e 8d1903                     sta $0319
   255  9ea1 a94c                       lda #$4C   ;; JMP $EA81
   256  9ea3 8dfc03                     sta $03FC
   257  9ea6 a981                       lda #<$EA81
   258  9ea8 8dfd03                     sta $03FD
   259  9eab a9ea                       lda #>$EA81
   260  9ead 8dfe03                     sta $03FE
   261                          
   262                                  ;; Disable IRQ/NMI sources
   263  9eb0 a97f                       lda #$7f
   264  9eb2 8d0ddc                     sta $DC0D
   265  9eb5 8d0ddd                     sta $DD0D
   266  9eb8 a900                       lda #$00
   267  9eba 8d1ad0                     sta $D01A
   268                          
   269                                  ;; return from hypervisor, causing freeze menu to start
   270                                  ;;
   271  9ebd 8d7fd6                     sta hypervisor_enterexit_trigger
   272                          
   273                          ;;         ========================
   274                          
   275                          protected_hardware_config:
   276                          
   277                                  ;; store config info passed from register a
   278  9ec0 ad40d6                     lda hypervisor_a
   279  9ec3 8d72d6                     sta hypervisor_secure_mode_flags
   280                          
   281                                  ;; bump border colour so that we know something has happened
   282                                  ;;
   283                          
   284  9ec6 8d7fd6                     sta hypervisor_enterexit_trigger
   285                          
   286                          ;;         ========================
   287                          
   288                          matrix_mode_toggle:
   289                          
   290  9ec9 ad72d6                     lda hypervisor_secure_mode_flags
   291                                  ;; We want to toggle bit 6 only.
   292  9ecc 4940                       eor #$40
   293  9ece 8d72d6                     sta hypervisor_secure_mode_flags
   294                          
   295  9ed1 8d7fd6                     sta hypervisor_enterexit_trigger

; ******** Source: src/hyppo/main.asm
   391                          
   392                          ;; /*  -------------------------------------------------------------------
   393                          ;;     Secure mode / compartmentalised operation management
   394                          ;;     ---------------------------------------------------------------- */

; ******** Source: securemode.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          securemode_trap:
     7                          
     8                                  ;; XXX - The following is what we SHOULD do for the complete system to work:
     9                                  ;; XXX Freeze current process to slot
    10                                  ;; XXX Find the requested service
    11                                  ;; XXX Load the requested service
    12                          
    13                                  ;; Set secure mode flag, and set PC and memory map in the secure service
    14                          
    15                                  ;; XXX - What we WILL do for now, is just enable secure mode, and set the PC to
    16                                  ;; $8000.
    17                          
    18                                  ;; First, disable access to cartridge, force 50MHz mode and 4502 CPU personality
    19  9ed4 a932                       lda #$32
    20  9ed6 8d7dd6                     sta hypervisor_feature_enables
    21                          
    22                                  ;; Second, disable all protecteed IO access, and mark matrix mode and secure mode.
    23                                  ;; This also freezes the CPU until the monitor acknowledges that the CPU is in
    24                                  ;; secure mode.  Only after that will the remainder of this routine proceed,
    25                                  ;; and thus allow the secure program to run.
    26                                  ;; XXX - This means that a little piece of the hypervisor is still running when we
    27                                  ;; go into the secure compartment.  For this reason, the CPU needs to be blocked
    28                                  ;; from writing to hypervisor_secure_mode_flags when in that state.
    29  9ed9 a9c0                       lda #$c0
    30  9edb 8d72d6                     sta hypervisor_secure_mode_flags
    31                          
    32                          
    33                                  ;; At this point, the monitor detects that we have asked for secure mode, and will
    34                                  ;; ask for the user to either accept or reject.  If they accept, the CPU will be
    35                                  ;; resumed into the loaded service.  If not, all memory will be erased, before the
    36                                  ;; CPU is resumed.  For now, a rejected action will just require a reboot. But
    37                                  ;; later, we will have the monitor tell the hypervisor by synthesising an appropriate
    38                                  ;; trap after wiping memory, presumbly by causing a write to a $D65x register.
    39  9ede 4c0082                     jmp nosuchtrap
    40                          
    41                          
    42                          leave_securemode_trap:
    43                          
    44                                  ;; If we get here, we have left a secure compartment, with either memory erased
    45                                  ;; or intact.  Either way, we should hand control back to the user, and disable
    46                                  ;; matrix mode display.
    47                          
    48                                  ;; XXX - Debug
    49  9ee1 ee21d0                     inc $d021
    50                          
    51  9ee4 a900                       lda #$00
    52  9ee6 8d72d6                     sta hypervisor_secure_mode_flags
    53                          
    54  9ee9 4c0082                     jmp nosuchtrap

; ******** Source: src/hyppo/main.asm
   396                          
   397                          ;; /*  -------------------------------------------------------------------
   398                          ;;     SD-Card and FAT related functions
   399                          ;;     ---------------------------------------------------------------- */

; ******** Source: sdfat.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          
     5                          ;;     These routines provide support for FAT32 and SDCARD support.
     6                          ;;     ---------------------------------------------------------------- */
     7                          
     8                          ;; /*  -------------------------------------------------------------------
     9                          ;;     FAT file system routines
    10                          ;;     ---------------------------------------------------------------- */
    11                          toupper:
    12                                  ;; convert ASCII character to upper case
    13                                  ;;
    14                                  ;; INPUT:  .A is the ASCII char to convert up uppercase
    15                                  ;; OUTPUT: .A will hold the resulting uppersace
    16  9eec c961                       cmp #$61  ; #$60 = ` char (just before lower-case 'a')
    17  9eee 9006                       bcc tu1   ; branch if < #$60
    18  9ef0 c97b                       cmp #$7b  ; #$7a = 'z' char
    19  9ef2 b002                       bcs tu1   ; branch if > #$7a
    20  9ef4 295f                       and #$5f  ; 's' = %01110011 & %01011111 = 'S' = %01010011
    21  9ef6 60                 tu1:    rts
    22                          
    23                          ;; /*  -------------------------------------------------------------------
    24                          ;;     MBP / partition routines
    25                          
    26                          ;;     Read master boot record. Does not sanity check anything.
    27                          ;;     ---------------------------------------------------------------- */
    28                          readmbr:
    29                                  ;; begin by resetting SD card
    30                                  ;;
    31                          
    32                                  +Checkpoint "Resetting SDCARD"
    33                          
    34  9ef7 206f9f                     jsr sd_resetsequence
    35  9efa b001                       bcs l7
    36                                  +Checkpoint "FAILED resetting SDCARD"
    37                          
    38  9efc 60                         rts
    39                          
    40                          l7:     ;; MBR is sector 0
    41                                  ;;
    42  9efd a900                       lda #$00
    43  9eff 8d81d6                     sta sd_address_byte0 ;; is $D681
    44  9f02 8d82d6                     sta sd_address_byte1 ;; is $d682
    45  9f05 8d83d6                     sta sd_address_byte2 ;; is $d683
    46  9f08 8d84d6                     sta sd_address_byte3 ;; is $d684
    47                          
    48                                  ;; Work out if SD card or SDHC card
    49                                  ;; SD cards only read on 512 byte aligned addresses.
    50                                  ;; SDHC addresses by sector, so all addresses are valid
    51                          
    52                                  ;; Clear SDHC flag to begin with (flag persists through reset)
    53  9f0b a940                       lda #$40
    54  9f0d 8d80d6                     sta $d680
    55                          
    56                                  ;; Attempt non-aligned read
    57  9f10 a902                       lda #$02
    58  9f12 8d81d6                     sta sd_address_byte0
    59  9f15 8d80d6                     sta $d680
    60                          
    61                          sdhccheckwait:
    62  9f18 20a79f                     jsr sdreadytest
    63  9f1b b017                       bcs issdhc
    64  9f1d d0f9                       bne sdhccheckwait
    65                          
    66                                  ;; Normal SD (SDSC) card
    67                          
    68  9f1f a900                       lda #$00
    69  9f21 8d81d6                     sta sd_address_byte0
    70                          
    71                                  ;; Reset after SDHC test for normal SD mode
    72  9f24 206f9f                     jsr sd_resetsequence
    73                          
    74                                  ;; XXX - We no longer support standard SD cards, so
    75                                  ;; we display an error and infinite loop.
    76                          
    77  9f27 a209                       ldx #<msg_foundsdcard
    78  9f29 a0af                       ldy #>msg_foundsdcard
    79  9f2b 20c8a8                     jsr printmessage
    80                          
    81                          @unsupportedcard:
    82  9f2e ee20d0                     inc $D020
    83  9f31 4c2e9f                     jmp @unsupportedcard
    84                          
    85                          issdhc:
    86  9f34 a22c                       ldx #<msg_foundsdhccard
    87  9f36 a0af                       ldy #>msg_foundsdhccard
    88  9f38 20c8a8                     jsr printmessage
    89                          
    90                                  ;; set SDHC flag
    91  9f3b a941                       lda #$41
    92  9f3d 8d80d6                     sta $d680
    93                          
    94  9f40 4cd89f                     jmp sd_readsector
    95                          
    96                          ;; /*  -------------------------------------------------------------------
    97                          ;;     SD Card access routines
    98                          ;;     ---------------------------------------------------------------- */
    99                          
   100                          sd_open_write_gate:	
   101  9f43 a957               	lda #$57
   102  9f45 8d80d6             	sta $d680
   103  9f48 60                 	rts
   104                          
   105                          write_non_mbr_sector:
   106  9f49 20439f             	jsr sd_open_write_gate
   107  9f4c 4c549f             	jmp write_sector_trigger
   108                          write_mbr_sector:
   109  9f4f a94d               	lda #$4D
   110  9f51 8d80d6             	sta $d680
   111                          write_sector_trigger:	
   112  9f54 a903               	lda #$03
   113  9f56 8d80d6             	sta $d680
   114  9f59 60                 	rts
   115                          	
   116                          
   117                          sd_wait_for_ready:
   118  9f5a 20999f                     jsr sdtimeoutreset
   119  9f5d 20a79f             @loop:  jsr sdreadytest
   120  9f60 90fb                       bcc @loop
   121  9f62 60                         rts
   122                          
   123                          sd_wait_for_ready_reset_if_required:
   124                                  ;; Wait until the SD card is ready. If it doesn't get ready,
   125                                  ;; then continuously reset it until it does become ready.
   126  9f63 205a9f                     jsr sd_wait_for_ready
   127  9f66 b006                       bcs @isReady
   128  9f68 206f9f                     jsr sd_resetsequence
   129  9f6b 4c639f                     jmp sd_wait_for_ready_reset_if_required
   130                          @isReady:
   131  9f6e 60                         rts
   132                          
   133                          sd_resetsequence:
   134                                  ;; write $00 to $D680 to start reset
   135                                  ;;
   136                          
   137                                  ;; Assert and release reset
   138  9f6f a900                       lda #$00
   139  9f71 8d80d6                     sta $D680
   140  9f74 a901                       lda #$01
   141  9f76 8d80d6                     sta $D680
   142                          
   143                                  ;; Wait for SD card to become ready
   144  9f79 205a9f             re2:    jsr sd_wait_for_ready
   145  9f7c b003                       bcs re2done        ;; success, so return
   146  9f7e d0f9                       bne re2                ;; not timed out, so keep trying
   147  9f80 60                         rts                ;; timeout, so return
   148                          
   149                          re2done:
   150  9f81 20c39f                     jsr sd_map_sectorbuffer
   151                          
   152                          redone:
   153  9f84 38                         sec
   154  9f85 60                         rts
   155                          
   156                          ;;         ========================
   157                          
   158                                  ;; Watch for ethernet packets while waiting for the SD card.
   159                                  ;; this allows loading of code into the hypervisor for testing and
   160                                  ;; bare-metal operation.
   161                                  ;;
   162                          sdwaitawhile:
   163  9f86 20999f                     jsr sdtimeoutreset
   164                          
   165  9f89 ee1cbf             sw1:    inc sdcounter+0
   166  9f8c d0fb                       bne sw1
   167  9f8e ee1dbf                     inc sdcounter+1
   168  9f91 d0f6                       bne sw1
   169  9f93 ee1ebf                     inc sdcounter+2
   170  9f96 d0f1                       bne sw1
   171  9f98 60                         rts
   172                          
   173                          ;;         ========================
   174                          
   175                          sdtimeoutreset:
   176                                  ;; count to timeout value when trying to read from SD card
   177                                  ;; (if it is too short, the SD card won't reset)
   178                                  ;;
   179  9f99 a900                       lda #$00
   180  9f9b 8d1cbf                     sta sdcounter+0
   181  9f9e 8d1dbf                     sta sdcounter+1
   182  9fa1 a9f3                       lda #$f3
   183  9fa3 8d1ebf                     sta sdcounter+2
   184  9fa6 60                         rts
   185                          
   186                          ;;         ========================
   187                          
   188                          sdreadytest:
   189                                  ;; check if SD card is ready, or if timeout has occurred
   190                                  ;; C is set if ready.
   191                                  ;; Z is set if timeout has occurred.
   192                                  ;;
   193  9fa7 ad80d6                     lda $d680
   194  9faa 2903                       and #$03
   195  9fac f013                       beq sdisready
   196  9fae ee1cbf                     inc sdcounter+0
   197  9fb1 d00c                       bne sr1
   198  9fb3 ee1dbf                     inc sdcounter+1
   199  9fb6 d007                       bne sr1
   200  9fb8 ee1ebf                     inc sdcounter+2
   201  9fbb d002                       bne sr1
   202                          
   203                                  ;; timeout
   204                                  ;;
   205  9fbd a900                       lda #$00 ;; set Z
   206                          
   207  9fbf 18                 sr1:    clc
   208  9fc0 60                         rts
   209                          
   210                          sdisready:
   211  9fc1 38                         sec
   212  9fc2 60                         rts
   213                          
   214                          ;;         ========================
   215                          
   216                          sd_map_sectorbuffer:
   217                          
   218                                  ;; BG this clobbers .A, maybe we should protect .A as the UNMAP-function does? (see below)
   219                          
   220                                  ;; Clear colour RAM at $DC00 flag, as this prevents mapping of sector buffer at $DE00
   221  9fc3 a901                       lda #$01
   222  9fc5 1c30d0                     trb $D030
   223                          
   224                                  ;; Actually map the sector buffer
   225  9fc8 a981                       lda #$81
   226  9fca 8d80d6                     sta $D680
   227  9fcd 38                         sec
   228  9fce 60                         rts
   229                          
   230                          ;;         ========================
   231                          
   232                          sd_unmap_sectorbuffer:
   233                          
   234  9fcf 48                         pha
   235  9fd0 a982                       lda #$82
   236  9fd2 8d80d6                     sta $D680
   237  9fd5 68                         pla
   238  9fd6 38                         sec
   239  9fd7 60                         rts
   240                          
   241                          
   242                          ;;         ========================
   243                          
   244                          ;; /*  -------------------------------------------------------------------
   245                          ;;     Below function is self-contained
   246                          ;;     ---------------------------------------------------------------- */
   247                          
   248                          sd_readsector:
   249                                  ;; Assumes fixed sector number (or byte address in case of SD cards)
   250                                  ;; is loaded into $D681 - $D684
   251                          
   252                          !if DEBUG_HYPPO {
   253                                  ;; print out debug info
   254                                  ;;
   255                          ;;         jsr printsectoraddress        ; to screen
   256                                  jsr dumpsectoraddress        ;; checkpoint message
   257                          }
   258                          
   259                                  ;; check if sd card is busy
   260                                  ;;
   261  9fd8 ad80d6                     lda $d680
   262  9fdb 2901                       and #$01
   263  9fdd d032                       bne rsbusyfail
   264                          
   265                                  ;;
   266  9fdf 4cf89f                     jmp rs4                ;; skipping the redoread-delay below
   267                          
   268                          ;;         ========================
   269                          
   270                          redoread:
   271                                  ;; redo-read delay
   272                                  ;;
   273                                  ;; when retrying, introduce a delay.  This seems to be needed often
   274                                  ;; when reading the first sector after SD card reset.
   275                                  ;;
   276                                  ;; print out a debug message to indicate RE-reading (ie previous read failed)
   277                                  ;;
   278  9fe2 a261                       ldx #<msg_sdredoread
   279  9fe4 a0af                       ldy #>msg_sdredoread
   280  9fe6 20c8a8                     jsr printmessage
   281                          
   282                                  +Checkpoint "ERROR redoread:"
   283                          
   284  9fe9 a2f0                       ldx #$f0
   285  9feb a000                       ldy #$00
   286  9fed a300                       ldz #$00
   287  9fef 1b                 r1:     inz
   288  9ff0 d0fd                       bne r1
   289  9ff2 c8                         iny
   290  9ff3 d0fa                       bne r1
   291  9ff5 e8                         inx
   292  9ff6 d0f7                       bne r1
   293                          
   294                          rs4:
   295                                  ;; ask for sector to be read
   296                                  ;;
   297  9ff8 a902                       lda #$02
   298  9ffa 8d80d6                     sta $d680
   299                          
   300                                  ;; wait for sector to be read
   301                                  ;;
   302  9ffd 20999f                     jsr sdtimeoutreset
   303                          rs3:
   304  a000 20a79f                     jsr sdreadytest
   305  a003 b004                       bcs rsread        ;; yes, sdcard is ready
   306  a005 d0f9                       bne rs3                ;; not ready, so check if ready now?
   307  a007 f002                       beq rereadsector        ;; Z was set, ie timeout
   308                          rsread:
   309  a009 38                         sec
   310  a00a 60                         rts
   311                          
   312                          ;;         ========================
   313                          
   314                          rereadsector:
   315                                  ;; reset sd card and try again
   316                                  ;;
   317                          
   318                                  +Checkpoint "ERROR rereadsector:"
   319                          
   320  a00b 206f9f                     jsr sd_resetsequence
   321  a00e 4cf89f                     jmp rs4
   322                          
   323                          rsbusyfail:     ;; fail
   324                                  ;;
   325  a011 a907                       lda #dos_errorcode_read_timeout
   326  a013 8dfabc                     sta dos_error_code
   327                                  +Checkpoint "ERROR rsbusyfail:"
   328                          
   329  a016 18                         clc
   330  a017 60                         rts
   331                          
   332                          ;; /*  -------------------------------------------------------------------
   333                          ;;     Above function is self-contained
   334                          ;;     ---------------------------------------------------------------- */
   335                          
   336                          sd_inc_sectornumber:
   337                          
   338                                  ;; PGS 20190225 - SD SC card support deprecated. Only SD HC supported.
   339                          
   340                                  ;; SDHC card mode: add 1
   341                                  ;;
   342                          
   343  a018 ee81d6                     inc sd_address_byte0
   344  a01b d00d                       bne s1
   345  a01d ee82d6                     inc sd_address_byte1
   346  a020 d008                       bne s1
   347  a022 ee83d6                     inc sd_address_byte2
   348  a025 d003                       bne s1
   349  a027 ee84d6                     inc sd_address_byte3
   350  a02a 60                 s1:     rts
   351                          
   352                          ;;         ========================

; ******** Source: src/hyppo/main.asm
   401                          
   402                          ;; /*  -------------------------------------------------------------------
   403                          ;;     Virtualised F011 access (used for disk over serial monitor)
   404                          ;;     ---------------------------------------------------------------- */

; ******** Source: virtual_f011.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          f011_virtual_read:
     7                          
     8                                  ;; Reset buffer pointers and stop SD card from reading
     9                                  ;; from card and overwriting what we load
    10  a02b a901                       lda #$01
    11  a02d 8d81d0                     sta $D081
    12                          
    13  a030 a980                       lda #$80
    14  a032 0c86d0                     tsb $D086
    15                          
    16                                  ;; We write the job details to the uart monitor interface.
    17                                  ;; Assume uart monitor interface is at 2mbits = 20 cycles
    18                                  ;; per char, so we need to add a short delay between each char
    19  a035 ad84d0                     lda $d084
    20  a038 0980                       ora #$80
    21  a03a 8d7cd6                     sta $d67C
    22                          
    23  a03d 2068a0                     jsr wait5usec
    24  a040 ad85d0                     lda $d085
    25  a043 0980                       ora #$80
    26  a045 8d7cd6                     sta $D67C
    27                          
    28  a048 2068a0                     jsr wait5usec
    29  a04b ad86d0                     lda $D086
    30  a04e 0980                       ora #$80
    31  a050 8d7cd6                     sta $D67C
    32                          
    33  a053 2068a0                     jsr wait5usec
    34  a056 a921                       lda #$21
    35  a058 8d7cd6                     sta $D67C
    36                          
    37                                  ;; Wait for monitor_load to clear bit 7 of side register to indicate that
    38                                  ;; it has done the job
    39  a05b ad86d0             fvr3:   lda $d086
    40  a05e 30fb                       bmi fvr3
    41                          
    42                          fvr_same_as_last_time:
    43                                  ;; Set floppy flags as appropriate to look like FDC has just successfully read a
    44                                  ;; sector
    45  a060 a935                       lda #$35
    46  a062 8dafd6                     sta f011_flag_stomp
    47                          
    48  a065 8d7fd6                     sta hypervisor_enterexit_trigger
    49                          
    50                          wait5usec:
    51                                  ;; 40MHz = 40 cycles / usec, so we need 200 cycles
    52                                  ;; JSR/RTS is ~10 cycles
    53                                  ;; 64 iterations of 3 cycles = ~192 cycles
    54                                  ;; so should be about right
    55  a068 a240                       ldx #$40
    56  a06a ca                 -       dex
    57  a06b d0fd                       bne -
    58  a06d 60                         rts
    59                          
    60                          f011_virtual_write:
    61                          
    62                                  ;; Reset buffer pointers and stop SD card from reading
    63                                  ;; from card and overwriting what we load
    64  a06e a901                       lda #$01
    65  a070 8d81d0                     sta $D081
    66                          
    67  a073 a940                       lda #$40
    68  a075 0c86d0                     tsb $D086
    69                          
    70                                  ;; We write the job details to the uart monitor interface.
    71                                  ;; Assume uart monitor interface is at 2mbits = 20 cycles
    72                                  ;; per char, so we need to add a short delay between each char
    73  a078 ad84d0                     lda $d084
    74  a07b 0980                       ora #$80
    75  a07d 8d7cd6                     sta $d67C
    76                          
    77  a080 2068a0                     jsr wait5usec
    78  a083 ad85d0                     lda $d085
    79  a086 0980                       ora #$80
    80  a088 8d7cd6                     sta $D67C
    81                          
    82  a08b 2068a0                     jsr wait5usec
    83  a08e ad86d0                     lda $D086
    84  a091 0980                       ora #$80
    85  a093 8d7cd6                     sta $D67C
    86                          
    87  a096 2068a0                     jsr wait5usec
    88  a099 a95c                       lda #$5C
    89  a09b 8d7cd6                     sta $D67C
    90                          
    91  a09e ad86d0             fvw1:   lda $d086
    92  a0a1 29c0                       and #$c0
    93  a0a3 d0f9                       bne fvw1
    94                          
    95  a0a5 a916                       lda #$16
    96  a0a7 8dafd6                     sta f011_flag_stomp
    97                          
    98                                  ;; Return from hypervisor
    99                                  ;;
   100  a0aa 8d7fd6             fvw2:   sta hypervisor_enterexit_trigger
   101                          

; ******** Source: src/hyppo/main.asm
   406                          
   407                          ;; /*  -------------------------------------------------------------------
   408                          ;;     Audio mixer control functions
   409                          ;;     ---------------------------------------------------------------- */

; ******** Source: audiomix.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          audiomix_setup:
     6                          
     7                                  ;; Set all audio mixer coefficients to silent by default
     8  a0ad a200                       ldx #$00
     9  a0af 8a                         txa 
    10                          aml1:
    11  a0b0 206ea1                     jsr audiomix_setcoefficient
    12  a0b3 e8                         inx
    13  a0b4 d0fa                       bne aml1
    14                          
    15                                  ;; Set master volume to max for L & R channels on M65R2 audio jack
    16  a0b6 a9ff                       lda #$ff
    17  a0b8 a2fe                       ldx #$fe
    18  a0ba 2089a1                     jsr audiomix_set2coefficients
    19  a0bd a2de                       ldx #$de
    20  a0bf 2089a1                     jsr audiomix_set2coefficients
    21                          	;; And also for speaker / HDMI audio outputs
    22                          	;; Now we have a fun problem: Internal speakers need it MUCH louder than HDMI
    23                          	;; and we wouldn't be able to set the two independently.
    24  a0c2 a9ff               	lda #$ff
    25  a0c4 a21e                       ldx #$1e
    26  a0c6 2089a1                     jsr audiomix_set2coefficients
    27  a0c9 a23e                       ldx #$3e
    28  a0cb 2089a1                     jsr audiomix_set2coefficients
    29                          
    30  a0ce 205aa1                     jsr audio_set_stereo
    31                          
    32                          	;; Set OPL / FM / SFX / Adlib volume to max on all channels
    33  a0d1 a90c               	lda #$0c
    34                          fmvolloop:
    35  a0d3 aa                 	tax
    36  a0d4 a9ff               	lda #$ff
    37  a0d6 2089a1             	jsr audiomix_set2coefficients
    38  a0d9 8a                 	txa
    39  a0da 18                 	clc
    40  a0db 6920               	adc #$20
    41  a0dd 90f4               	bcc fmvolloop
    42                          	
    43                          
    44                          audio_set_mono:
    45                                  ;; Left and right SID volume levels
    46                                  ;; for stereo operation
    47  a0df a9be                       lda #$be
    48  a0e1 a2c0                       ldx #$c0
    49  a0e3 2081a1                     jsr audiomix_set4coefficients
    50  a0e6 a2d0                       ldx #$d0
    51  a0e8 2081a1                     jsr audiomix_set4coefficients
    52  a0eb a2f0                       ldx #$f0
    53  a0ed 2081a1                     jsr audiomix_set4coefficients
    54  a0f0 a2e0                       ldx #$e0
    55  a0f2 2081a1                     jsr audiomix_set4coefficients
    56  a0f5 a200                       ldx #$00
    57  a0f7 2081a1                     jsr audiomix_set4coefficients
    58  a0fa a210                       ldx #$10
    59  a0fc 2081a1                     jsr audiomix_set4coefficients
    60  a0ff a220                       ldx #$20
    61  a101 2081a1                     jsr audiomix_set4coefficients
    62  a104 a230                       ldx #$30
    63  a106 2081a1                     jsr audiomix_set4coefficients
    64  a109 60                         rts
    65                          
    66                          audiomix_set_sid_lr_coefficients:
    67  a10a a2c0                       ldx #$c0
    68  a10c 2089a1                     jsr audiomix_set2coefficients
    69  a10f a2d0                       ldx #$d0
    70  a111 2089a1                     jsr audiomix_set2coefficients
    71  a114 a2e2                       ldx #$e2
    72  a116 2089a1                     jsr audiomix_set2coefficients
    73  a119 a2f2                       ldx #$f2
    74  a11b 2089a1                     jsr audiomix_set2coefficients
    75  a11e a200                       ldx #$00
    76  a120 2089a1                     jsr audiomix_set2coefficients
    77  a123 a210                       ldx #$10
    78  a125 2089a1                     jsr audiomix_set2coefficients
    79  a128 a222                       ldx #$22
    80  a12a 2089a1                     jsr audiomix_set2coefficients
    81  a12d a232                       ldx #$32
    82  a12f 4c89a1                     jmp audiomix_set2coefficients
    83                          
    84                          audiomix_set_sid_rl_coefficients:	
    85  a132 a2c2                       ldx #$c2
    86  a134 2089a1                     jsr audiomix_set2coefficients
    87  a137 a2d2                       ldx #$d2
    88  a139 2089a1                     jsr audiomix_set2coefficients
    89  a13c a2e0                       ldx #$e0
    90  a13e 2089a1                     jsr audiomix_set2coefficients
    91  a141 a2f0                       ldx #$f0
    92  a143 2089a1                     jsr audiomix_set2coefficients
    93  a146 a202                       ldx #$02
    94  a148 2089a1                     jsr audiomix_set2coefficients
    95  a14b a212                       ldx #$12
    96  a14d 2089a1                     jsr audiomix_set2coefficients
    97  a150 a220                       ldx #$20
    98  a152 2089a1                     jsr audiomix_set2coefficients
    99  a155 a230                       ldx #$30
   100  a157 4c89a1                     jmp audiomix_set2coefficients        	
   101                          	
   102                          audio_set_stereo:
   103                                  ;; Left and right SID volume levels
   104                                  ;; for stereo operation
   105  a15a a9be                       lda #$be
   106  a15c 200aa1             	jsr audiomix_set_sid_lr_coefficients
   107  a15f a940                       lda #$40
   108  a161 4c32a1             	jmp audiomix_set_sid_rl_coefficients
   109                          
   110                          audio_set_stereomirrored:
   111                                  ;; Left and right SID volume levels
   112                                  ;; for stereo operation
   113  a164 a940                       lda #$40
   114  a166 200aa1             	jsr audiomix_set_sid_lr_coefficients
   115  a169 a9be                       lda #$be
   116  a16b 4c32a1             	jmp audiomix_set_sid_rl_coefficients
   117                          
   118                          audiomix_setcoefficient:
   119  a16e 8ef4d6                     stx audiomix_addr
   120                          
   121                                  ;; wait 17 cycles before writing (16 + start of read instruction)
   122                                  ;; to give time to audio mixer to fetch the 16-bit coefficient, before
   123                                  ;; we write to half of it (which requires the other half loaded, so that the
   124                                  ;; write to the 16-bit register gets the correct other half).
   125                                  ;; note that bit $1234 gets replaced in hyppo by monitor_load when doing
   126                                  ;; hot-patching, so we can't use that instruction for the delay
   127                          
   128                                  ;; simple solution: write to address register several times to spend the time.
   129                                  ;; 16 cycles here. then the sta of the data gives us 3 more cycles, so we are fine.
   130  a171 8ef4d6                     stx audiomix_addr
   131  a174 8ef4d6                     stx audiomix_addr
   132  a177 8ef4d6                     stx audiomix_addr
   133  a17a 8ef4d6                     stx audiomix_addr
   134                          
   135                                  ;; update coefficient
   136  a17d 8df5d6                     sta audiomix_data
   137  a180 60                         rts
   138                          
   139                          audiomix_set4coefficients:
   140  a181 206ea1                     jsr audiomix_setcoefficient
   141  a184 e8                         inx
   142  a185 206ea1                     jsr audiomix_setcoefficient
   143  a188 e8                         inx
   144                          audiomix_set2coefficients:
   145  a189 206ea1                     jsr audiomix_setcoefficient
   146  a18c e8                         inx
   147  a18d 4c6ea1                     jmp audiomix_setcoefficient

; ******** Source: src/hyppo/main.asm
   411                          
   412                          ;; /*  -------------------------------------------------------------------
   413                          ;;     Target-specific register setup
   414                          ;;     ---------------------------------------------------------------- */

; ******** Source: targetsetup.asm
     1                                  ;; Setup functions for MEGAphone.
     2                                  ;; Basically setup the I2C IO expanders with sensible values, turning
     3                                  ;; all peripherals on.
     4                          
     5                          targetspecific_setup:
     6                          
     7                          	;; Setup common I2C area 32-bit pointer
     8  a190 a900                       lda #<$7000
     9  a192 8d10bf                     sta zptempv32+0
    10  a195 a970                       lda #>$7000
    11  a197 8d11bf                     sta zptempv32+1
    12  a19a a9fd                       lda #<$0FFD
    13  a19c 8d12bf                     sta zptempv32+2
    14  a19f a90f                       lda #>$0FFD
    15  a1a1 8d13bf                     sta zptempv32+3
    16                          	
    17                          	;; Apply I2C settings based on target ID
    18  a1a4 ad29d6             	lda $d629
    19  a1a7 c903               	cmp #$03
    20  a1a9 f00a               	beq mega65r3_i2c_setup
    21  a1ab ad29d6             	lda $d629
    22  a1ae 29e0               	and #$e0
    23  a1b0 c920               	cmp #$20
    24  a1b2 f02b               	beq megaphone_i2c_setup
    25  a1b4 60                 	rts
    26                          	
    27                          mega65r3_i2c_setup:	
    28                          
    29  a1b5 a971                       lda #>$7100
    30  a1b7 8d11bf                     sta zptempv32+1
    31  a1ba a900                       lda #$00
    32  a1bc 8d20d0                     sta $d020
    33  a1bf a000                       ldy #$00
    34                          
    35                          mps3_loop:
    36  a1c1 b930a2                     lda mega65r3_i2c_settings,y
    37  a1c4 c9ff                       cmp #$ff
    38  a1c6 d003                       bne +
    39  a1c8 a300                       ldz #$00
    40                          
    41  a1ca 60                         rts
    42                          +
    43  a1cb 4b                         taz
    44  a1cc c8                         iny
    45  a1cd b930a2                     lda mega65r3_i2c_settings,y
    46  a1d0 c8                         iny
    47                          
    48                          
    49                                  ;; Keep writing it until it gets written
    50                          -
    51  a1d1 ea9210              	sta [<zptempv32],z
    52                          
    53  a1d4 ee20d0             	inc $d020	
    54  a1d7 ead210                     cmp [<zptempv32],z
    55  a1da d0f5                       bne -
    56                          
    57  a1dc 4cc1a1                     jmp mps3_loop
    58                          	
    59                          megaphone_i2c_setup:
    60                          
    61                                  ;; Start with backscreen very dim, to avoid inrush current
    62                                  ;; causing FGPA power rail to sag.
    63  a1df a901                       lda #$01
    64  a1e1 8df0d6                     sta $d6f0
    65                          	
    66  a1e4 a900                       lda #$00
    67  a1e6 8d20d0                     sta $d020
    68  a1e9 a000                       ldy #$00
    69                          mps_loop:
    70  a1eb b90ea2                     lda megaphone_i2c_settings,y
    71  a1ee c9ff                       cmp #$ff
    72  a1f0 d008                       bne +
    73  a1f2 a300                       ldz #$00
    74                          
    75                                  ;; Set full brightness on LCD on exit
    76  a1f4 a9ff                       lda #$ff
    77  a1f6 8df0d6                     sta $d6f0
    78                          
    79  a1f9 60                         rts
    80                          +
    81  a1fa 4b                         taz
    82  a1fb c8                         iny
    83  a1fc b90ea2                     lda megaphone_i2c_settings,y
    84  a1ff c8                         iny
    85                          
    86                          
    87                                  ;; Keep writing it until it gets written
    88                          -
    89  a200 ea9210                     sta [<zptempv32],z
    90                          
    91                                  ;; Wait for I2C register to get written
    92                          
    93  a203 ee20d0                     inc $d020
    94                          
    95  a206 ead210                     cmp [<zptempv32],z
    96  a209 d0f5                       bne -
    97                          
    98                          
    99  a20b 4ceba1                     jmp mps_loop
   100                          
   101                          
   102                          megaphone_i2c_settings:
   103                                  ;; LCD panel
   104  a20e 1640                       !8 $16,$40 ;; Port 0 to output, except LCD backlight line, that we now control via an FPGA pin
   105  a210 1700                       !8 $17,$00 ;; Port 1 to output
   106  a212 12bf                       !8 $12,$bf ;; Enable power to all sub-systems ($BF = $FF - $40)
   107  a214 1320                       !8 $13,$20 ;; Power up headphones amplifier
   108                          
   109                                  ;; Speaker amplifier configuration
   110  a216 35ff                       !8 $35,$FF   ;; Left volume initial mute
   111  a218 36ff                       !8 $36,$FF   ;; Right volume initial mute
   112  a21a 3020                       !8 $30,$20
   113  a21c 3100                       !8 $31,$00
   114  a21e 3202                       !8 $32,$02
   115  a220 3300                       !8 $33,$00
   116  a222 3410                       !8 $34,$10
   117  a224 3780                       !8 $37,$80
   118  a226 380c                       !8 $38,$0C
   119  a228 3999                       !8 $39,$99
   120  a22a 3560                       !8 $35,$60   ;; Left volume set ($FF = mute, $40 = full volume)
   121  a22c 3660                       !8 $36,$60   ;; Right volume set ($FF = mute, $40 = full volume)
   122                          
   123                          
   124  a22e ffff                       !8 $FF,$FF ;; End of list marker
   125                          
   126                          mega65r3_i2c_settings:	
   127                                  ;; Speaker amplifier configuration
   128  a230 e1ff                       !8 $e1,$FF   ;; Left volume initial mute
   129  a232 e2ff                       !8 $e2,$FF   ;; Right volume initial mute
   130  a234 dc20                       !8 $dc,$20
   131  a236 dd00                       !8 $dd,$00
   132  a238 de02                       !8 $de,$02
   133  a23a df00                       !8 $df,$00
   134  a23c e010                       !8 $e0,$10
   135  a23e e380                       !8 $e3,$80
   136  a240 e40c                       !8 $e4,$0C
   137  a242 e599                       !8 $e5,$99
   138  a244 e120                       !8 $e1,$20   ;; Left volume set ($FF = mute, $40 = full volume, $00 = +24dB)
   139  a246 e220                       !8 $e2,$20   ;; Right volume set ($FF = mute, $40 = full volume, $00 = +24dB)
   140                          
   141                          
   142  a248 ffff                       !8 $FF,$FF ;; End of list marker

; ******** Source: src/hyppo/main.asm
   416                          
   417                          ;; /*  -------------------------------------------------------------------
   418                          ;;     CPU Hypervisor Entry Point on reset
   419                          ;;     ---------------------------------------------------------------- */
   420                          
   421                          reset_machine_state:
   422                                  ;; get CPU state sensible
   423  a24a 78                         sei
   424  a24b d8                         cld
   425  a24c 03                         see
   426                          
   427                                  ;; ;; Disable reset watchdog (this happens simply by writing anything to
   428                                  ;; ;; this register)
   429                                  ;; ;; Enable /EXROM and /GAME from cartridge port (bit 0)
   430                                  ;; ;; enable flat 32-bit addressing (bit 1)
   431                                  ;; ;; do not engage ROM write protect (yet) (bit 2)
   432                                  ;; ;; do make ASC/DIN / CAPS LOCK control CPU speed (bit 3)
   433                                  ;; ;; do not force CPU to full speed (bit 4)
   434                                  ;; ;; also force 4502 CPU personality (6502 personality is still incomplete) (bit 5)
   435                                  ;; ;; and clear any pending IRQ or NMI event (bit 6)
   436                                  ;; ;;
   437                                  ;; ;; (The watchdog was added to catch reset problems where the machine
   438                                  ;; ;; would run off somewhere odd instead of resetting properly. Now it
   439                                  ;; ;; will auto-reset after 65535 cycles if the watchdog is not cleared).
   440                                  ;; ;;
   441                          
   442  a24d a96b                       lda #$6b    ;; 01101011
   443  a24f 8d7dd6                     sta hypervisor_feature_enables
   444                          
   445                          	;; Enable cartridge /EXROM and /GAME lines in CPU addressing
   446  a252 a902               	lda #$02
   447  a254 0cfbd7             	tsb $d7fb
   448                          	
   449                          	;; /EXROM and /GAME follow cartridge port
   450  a257 a93f                       lda #$3f
   451  a259 8dfdd7                     sta $d7fd
   452                          
   453  a25c 20ada0                     jsr audiomix_setup
   454                                  ;; enable audio amplifier
   455  a25f a901                       lda #$01
   456  a261 8dfed6                     sta audioamp_ctl
   457                          
   458                                  ;; Return keyboard LEDs to automatic control
   459  a264 a900               	lda #$00
   460  a266 8d1dd6             	sta $d61d
   461                          	;; Disable VIC-IV debug modes
   462  a269 8d66d0             	sta $d066
   463                                  ;; Clear system partition present flag
   464  a26c 8dfcbc                     sta syspart_present
   465                                  ;; disable IRQ/NMI sources
   466  a26f 8d1ad0                     sta $D01A
   467  a272 a97f                       lda #$7f
   468  a274 8d7fd0             	sta $d07f   		; Hide VIC-IV cross-hairs
   469  a277 8d0ddc                     sta $DC0D
   470  a27a 8d0ddd                     sta $DD0D
   471                          
   472  a27d 38                         sec
   473                                  ;; determine VIC mode and set it accordingly in VICIV_MAGIC
   474  a27e 20c4aa                     jsr enhanced_io
   475                          
   476                                  ;; clear UART interrupt status
   477  a281 ad06d6                     lda uart65_irq_flag
   478                          
   479                                  ;; switch to fast mode
   480                                  ;; 1. C65 fast-mode enable, and disable extended attributes
   481  a284 a940               	lda #$40
   482  a286 8d31d0                     sta $d031
   483                                  ;; 2. MEGA65 48MHz enable (requires C65 or C128 fast mode to truly enable, hence the above)
   484  a289 a9c5                       lda #$c5
   485  a28b 0c54d0                     tsb $d054
   486                          
   487                                  ;; Setup I2C peripherals on the MEGAphone platform
   488  a28e 2090a1                     jsr targetspecific_setup
   489                          
   490                                  ;; sprites off, and normal mode, 256-colour char data from chipram
   491  a291 a900                       lda #$00
   492  a293 8d15d0                     sta $d015
   493  a296 8d63d0             	sta $d063
   494  a299 8d55d0                     sta $d055
   495  a29c 8d6bd0                     sta $d06b
   496  a29f 8d57d0                     sta $d057
   497  a2a2 a9f0                       lda #$f0
   498  a2a4 aa                 	tax
   499  a2a5 1c49d0             	trb $d049
   500  a2a8 8a                 	txa
   501  a2a9 1c4bd0             	trb $d04b
   502  a2ac 8a                 	txa
   503  a2ad 1c4dd0             	trb $d04d
   504  a2b0 8a                 	txa
   505  a2b1 1c4fd0             	trb $d04f
   506                          
   507                                  ;; We DO NOT need to mess with $01, because
   508                                  ;; the 4510 starts up with hyppo mapped at $8000-$BFFF
   509                                  ;; enhanced ($FFD3xxx) IO page mapped at $D000,
   510                                  ;; and fast RAM elsewhere.
   511                          
   512                                  ;; Map SD card sector buffer to SD card, not floppy drive
   513  a2b4 a980                       lda #$80
   514  a2b6 8d89d6                     sta sd_buffer_ctrl
   515                          
   516                                  ;; Access cartridge IO area to force EXROM probe on R1 PCBs
   517                                  ;; XXX DONT READ $DExx ! This is a known crash causer for Action Replay
   518                                  ;; cartridges.  $DF00 should be okay, however.
   519                                  ;; XXX $DFxx can also be a problem for other cartridges, so we shouldn't do either.
   520                                  ;; this will mean cartridges don't work on the R1 PCB, but as that is no longer being
   521                                  ;; developed for, we can just ignore that now, and not touch anything.
   522                                  ;;lda $df00
   523                          
   524  a2b9 20d3a6                     jsr resetdisplay
   525  a2bc 201ea8                     jsr erasescreen
   526  a2bf 2039a7                     jsr resetpalette
   527                          
   528                                  ;; note that this first message does not get displayed correctly
   529                                  +Checkpoint "reset_machine_state"
   530                                  ;; but this second message does
   531                                  +Checkpoint "reset_machine_state"
   532                          
   533  a2c2 60                         rts
   534                          
   535                          ;; /*  -------------------------------------------------------------------
   536                          ;;     CPU Hypervisor reset/trap routines
   537                          ;;     ---------------------------------------------------------------- */
   538                          reset_entry:
   539  a2c3 78                         sei
   540                          
   541                           	;; Put ZP and stack back where they belong
   542  a2c4 a9bf               	lda #$bf
   543  a2c6 5b                 	tab
   544  a2c7 a0be               	ldy #$be
   545  a2c9 2b                 	tys
   546  a2ca a2ff               	ldx #$ff
   547  a2cc 9a                 	txs
   548                          
   549                          	;; Clear mapping of lower memory area
   550  a2cd a200               	ldx #$00
   551  a2cf a900               	lda #$00
   552  a2d1 a000               	ldy #$00
   553  a2d3 a33f               	ldz #$3f
   554  a2d5 5c                 	map
   555  a2d6 ea                 	eom
   556                          
   557                          !if DEBUG_HYPPO {
   558                                  !src "debugtests.asm"
   559                          }
   560                          
   561  a2d7 204aa2                     jsr reset_machine_state
   562                          
   563                          	;; If banner is in flash, load it _immediately_
   564  a2da 2030a5             	jsr tryloadbootlogofromflash
   565                          	
   566                                  ;; display welcome screen
   567                                  ;;
   568  a2dd a241                       ldx #<msg_hyppo
   569  a2df a0ae                       ldy #>msg_hyppo
   570  a2e1 20c8a8                     jsr printmessage
   571                          
   572                                  ;; leave a blank line below hyppo banner
   573                                  ;;
   574  a2e4 a2b2                       ldx #<msg_blankline
   575  a2e6 a0b2                       ldy #>msg_blankline
   576  a2e8 20c8a8                     jsr printmessage
   577                          
   578                                  ;; Display GIT commit
   579                                  ;;
   580  a2eb a292                       ldx #<msg_gitcommit
   581  a2ed a0b2                       ldy #>msg_gitcommit
   582  a2ef 20c8a8                     jsr printmessage
   583                          
   584                                  ;; Magic instruction used by monitor_load to work out where
   585                                  ;; to patch. Monitor_load changes bit to JMP when patching for
   586                                  ;; SD-cardless operation
   587  a2f2 2c68a9                     bit go64
   588  a2f5 2c3412                     bit $1234
   589                          	
   590                                  ;; Display help text
   591  a2f8 ad10a3             	lda first_boot_flag_instruction
   592  a2fb c94c               	cmp #$4c
   593  a2fd f00a               	beq not_first_boot_message
   594  a2ff a261                       ldx #<msg_hyppohelpfirst
   595  a301 a0ae                       ldy #>msg_hyppohelpfirst
   596  a303 20c8a8                     jsr printmessage
   597  a306 4c10a3             	jmp first_boot_flag_instruction
   598                          	
   599                          not_first_boot_message:	
   600  a309 a287                       ldx #<msg_hyppohelpnotfirst
   601  a30b a0ae                       ldy #>msg_hyppohelpnotfirst
   602  a30d 20c8a8                     jsr printmessage
   603                          	
   604                          	;; Work out if we are on first reset.  If so, then try switching to bitstream in 2nd slot.
   605                          
   606                          first_boot_flag_instruction:
   607                          try_flash_menu:	
   608                          	
   609                          	;; Use first boot code path only once
   610                          	;; WARNING: Self modifying code!
   611  a310 2c6ea3             	bit dont_launch_flash_menu
   612                          
   613                          	;; On first boot, we start the flash menu regardless
   614                          	;; (The flash menu will work out whether to switch bitstream or not)
   615  a313 4c27a3             	jmp launch_flash_menu
   616                          	
   617                          	;; On ALT or either joystick button, enter flash menu.
   618                          	;; But only on first boot, while flash menu program can still be relied upon to be in memory.
   619  a316 ad10d6             	lda $d610
   620  a319 c909               	cmp #$09
   621  a31b f00a               	beq launch_flash_menu
   622  a31d ad00dc             	lda $dc00
   623  a320 2d01dc             	and $dc01
   624  a323 2910               	and #$10
   625  a325 d047               	bne dont_launch_flash_menu
   626                          	
   627                          launch_flash_menu:
   628                          
   629                          	;; Disable digital audio when launching flash menu
   630  a327 2087ab             	jsr safe_video_mode
   631                          	
   632                          	;; Store where the flash menu should jump to if it doesn't need to do anything.
   633  a32a a937               	lda #<return_from_flashmenu
   634  a32c 8d80cf             	sta $cf80
   635  a32f a9a3               	lda #>return_from_flashmenu
   636  a331 8d81cf             	sta $cf81
   637                          	;; Then actually start it.
   638                          	;; NOTE: Flash menu runs in hypervisor mode, so can't use memory beyond $7FFF etc.
   639                          
   640  a334 4c6fac             	jmp flash_menu
   641                          
   642                          return_from_flashmenu:	
   643                          
   644                          	;; Here we have been given control back from the flash menu program.
   645                          	;; So we have to put some things back to continue the kickstart boot process.
   646                          
   647                          	;; Put ZP and stack back where they belong
   648  a337 a9bf               	lda #$bf
   649  a339 5b                 	tab
   650  a33a a0be               	ldy #$be
   651  a33c 2b                 	tys
   652  a33d a2ff               	ldx #$ff
   653  a33f 9a                 	txs
   654                          	
   655  a340 a9ff                       lda #$ff
   656  a342 8d02d7                     sta $d702
   657  a345 a9ff                       lda #$ff
   658  a347 8d04d7                     sta $d704  ;; dma list is in top MB of address space
   659                          
   660                          	;; Don't forget to reset colour RAM also
   661  a34a a901               	lda #$01
   662  a34c 0c30d0             	tsb $d030
   663  a34f a9a8                       lda #>erasescreendmalist
   664  a351 8d01d7                     sta $d701
   665                                  ;; set bottom 8 bits of address and trigger DMA.
   666                                  ;;
   667  a354 a9ad                       lda #<erasescreendmalist
   668  a356 8d05d7                     sta $d705
   669  a359 a901               	lda #$01
   670  a35b 1c30d0             	trb $d030
   671                          	
   672                          	;; And finally, the screen data
   673  a35e a9ac                       lda #>screenrestore_dmalist
   674  a360 8d01d7                     sta $d701
   675                                  ;; Trigger enhanced DMA
   676  a363 a9f2                       lda #<screenrestore_dmalist
   677  a365 8d05d7                     sta $d705
   678                          
   679  a368 20d3a6             	jsr resetdisplay
   680                          		
   681  a36b 4c6ea3             	jmp dont_launch_flash_menu
   682                          	
   683                          dont_launch_flash_menu:
   684  a36e ad10d6             	lda ascii_key_in
   685  a371 c909               	cmp #$09
   686  a373 d00d               	bne fpga_has_been_reconfigured
   687                          
   688                          	;; Tell user what to do if they can't access the flash menu
   689                          noflash_menu:
   690  a375 a204                       ldx #<msg_noflashmenu
   691  a377 a0ae                       ldy #>msg_noflashmenu
   692  a379 20c8a8                     jsr printmessage
   693  a37c ee20d0             	inc $d020
   694                          nfm1:
   695  a37f 4c7fa3             	jmp nfm1
   696                          	
   697                          
   698                          fpga_has_been_reconfigured:	
   699                          
   700                          	;; We can't trust that the flash menu is still in memory by this point, so do nothing.
   701                          	;; (This also means if you choose "safe mode" factory bitstream, and then reset, it
   702                          	;; won't try to run upgraded bitstream again.)
   703                          	
   704                                  ;; wait 0.1 msec for things to settle after power-up
   705  a382 20869f                     jsr sdwaitawhile
   706                          
   707                                  ;; check keyboard for 0-9 down to select alternate rom
   708                                  ;;
   709  a385 200eab                     jsr keyboardread
   710                          
   711                          ;;         ========================
   712                          
   713                          normalboot:
   714                          
   715                          !if DEBUG_HYPPO {
   716                                  jsr dump_disk_count        ;; debugging to Checkpoint
   717                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
   718                          }
   719                          
   720                                  ;; Try to read the MBR from the SD card to ensure SD card is happy
   721                                  ;;
   722  a388 a2ea                       ldx #<msg_tryingsdcard
   723  a38a a0ae                       ldy #>msg_tryingsdcard
   724  a38c 20c8a8                     jsr printmessage
   725                          
   726                                  ;; Work out if we are using primary or secondard SD card
   727                          
   728                                  ;; First try resetting card 1 (external)
   729                          	;; so that if you have an external card, it will be used in preference
   730  a38f a9c1                       lda #$c1
   731  a391 8d80d6                     sta $d680
   732  a394 a900                       lda #$00
   733  a396 8d80d6                     sta $d680
   734  a399 a901                       lda #$01
   735  a39b 8d80d6                     sta $d680
   736                          
   737  a39e a203                       ldx #$03
   738                          morewaiting:
   739  a3a0 20869f                     jsr sdwaitawhile
   740                          
   741  a3a3 ad80d6                     lda $d680
   742  a3a6 2903                       and #$03
   743  a3a8 d00c                       bne trybus0
   744                          
   745  a3aa da                         phx
   746                          
   747  a3ab a25b                       ldx #<msg_usingcard1
   748  a3ad a0b2                       ldy #>msg_usingcard1
   749  a3af 20c8a8                     jsr printmessage
   750                          
   751  a3b2 fa                         plx
   752                          
   753  a3b3 4ce3a3                     jmp tryreadmbr
   754                          trybus0:
   755  a3b6 ca                         dex
   756  a3b7 d0e7                       bne morewaiting
   757                          
   758  a3b9 a9c0                       lda #$c0
   759  a3bb 8d80d6                     sta $d680
   760                          
   761  a3be a247                       ldx #<msg_tryingcard0
   762  a3c0 a0b2                       ldy #>msg_tryingcard0
   763  a3c2 20c8a8                     jsr printmessage
   764                          
   765                                  ;; Try resetting card 0
   766  a3c5 a900                       lda #$00
   767  a3c7 8d80d6                     sta $d680
   768  a3ca a901                       lda #$01
   769  a3cc 8d80d6                     sta $d680
   770                          
   771  a3cf 20869f                     jsr sdwaitawhile
   772                          
   773  a3d2 ad80d6                     lda $d680
   774  a3d5 2903                       and #$03
   775  a3d7 f00a                       beq tryreadmbr
   776                          
   777                                  ;; No working SD card -- we can just try booting to BASIC, since we
   778                                  ;; now include our open-source ROM
   779  a3d9 a273                       ldx #<msg_nosdcard
   780  a3db a0af                       ldy #>msg_nosdcard
   781  a3dd 20c8a8                     jsr printmessage
   782  a3e0 4c68a9                     jmp go64
   783                          
   784                          tryreadmbr:
   785  a3e3 20f79e                     jsr readmbr
   786  a3e6 b01b                       bcs gotmbr
   787                          
   788                                  ;; check for keyboard input to jump to utility menu
   789  a3e8 20e2aa                     jsr scankeyboard
   790  a3eb b007                       bcs nokey2
   791  a3ed c920                       cmp #$20
   792  a3ef d003                       bne nokey2
   793  a3f1 4c92ab                     jmp utility_menu
   794                          nokey2:
   795                          
   796                                  ;; Oops, cant read MBR
   797                                  ;; display debug message to screen
   798                                  ;;
   799  a3f4 a22b                       ldx #<msg_retryreadmbr
   800  a3f6 a0ae                       ldy #>msg_retryreadmbr
   801  a3f8 20c8a8                     jsr printmessage
   802                          
   803                                  ;; put sd card sector buffer back after scanning
   804                                  ;; keyboard
   805  a3fb a981                       lda #$81
   806  a3fd 0c80d6                     tsb sd_ctrl
   807                          
   808                                  ;; display debug message to uart
   809                                  ;;
   810                                  +Checkpoint "re-try reading MBR of sdcard"
   811                          
   812  a400 4ce3a3                     jmp tryreadmbr
   813                          
   814                          ;;         ========================
   815                          
   816                          gotmbr:
   817                                  ;; good, was able to read the MBR
   818                          
   819                                  ;; Scan SD card for partitions and mount them.
   820                                  ;;
   821  a403 204193                     jsr dos_clearall
   822  a406 20de8f                     jsr dos_read_partitiontable
   823                          
   824                                  ;; then print out some useful information
   825                                  ;;
   826  a409 a2f8                       ldx #<msg_diskcount
   827  a40b a0af                       ldy #>msg_diskcount
   828  a40d 20c8a8                     jsr printmessage
   829                                  ;;
   830  a410 a000                       ldy #$00
   831  a412 ab01bc                     ldz dos_disk_count
   832  a415 2041a9                     jsr printhex
   833                                  ;;
   834  a418 a000                       ldy #$00
   835  a41a ab02bc                     ldz dos_default_disk
   836  a41d 2041a9                     jsr printhex
   837                          
   838                          !if DEBUG_HYPPO {
   839                                  jsr dump_disk_count     ;; debugging to Checkpoint
   840                                  jsr dumpcurrentfd       ;; debugging to Checkpoint
   841                          ;;             jsr print_disk_table        ; debugging to Screen
   842                          }
   843                          
   844                          ;;         ========================
   845                          
   846                                  ;; If we have no disks, offer the utility menu
   847  a420 ad01bc                     lda dos_disk_count
   848  a423 d003                       bne @thereIsADisk
   849  a425 4c92ab                     jmp utility_menu
   850                          @thereIsADisk:
   851                          
   852                                  ;; Go to root directory on default disk
   853  a428 20caa4                     jsr cdroot_and_complain_if_fails
   854                          
   855                          mountsystemdiskok:
   856                          	
   857                          loadbannerfromsd:	
   858                                  ;; Load and display boot logo
   859                          
   860  a42b 208aa5             	jsr setup_banner_load_pointer
   861                          	
   862  a42e a2f3                       ldx #<txt_BOOTLOGOM65
   863  a430 a0b2                       ldy #>txt_BOOTLOGOM65
   864  a432 204a99                     jsr dos_setname
   865                          
   866                                  ;; print debug message
   867                                  ;;
   868                                  +Checkpoint "  try-loading BOOTLOGO"
   869                          
   870  a435 204798                     jsr dos_readfileintomemory
   871  a438 b00f                       bcs logook
   872                          
   873                          ;;         ========================
   874                          
   875                                  ;; FAILED: print debug message
   876                                  ;;
   877                                  +Checkpoint "  FAILED-loading BOOTLOGO"
   878                          
   879                                  ;; print debug message
   880                                  ;;
   881  a43a a202                       ldx #<msg_nologo
   882  a43c a0b2                       ldy #>msg_nologo
   883  a43e 20c8a8                     jsr printmessage
   884  a441 a000                       ldy #$00
   885  a443 abfabc                     ldz dos_error_code
   886  a446 2041a9                     jsr printhex
   887                          
   888                                  +Checkpoint "FAILED loading BOOTLOGO"
   889                          
   890                          ;;         ========================
   891                          
   892                          logook:
   893                                  ;; Loaded banner, so copy palette into place
   894  a449 2082a8                     jsr setbannerpalette
   895                          
   896                                  ;; iterate through directory entries looking for ordinary file
   897                                  ;; HICKUP.M65 to load into hypervisor memory ...
   898                                  ;; ... but only if we are not running a hick-up'd hyppo now.
   899                                  ;;
   900  a44c ad7ed6                     lda hypervisor_hickedup_flag        ;; $d67e = register for hickup-state (00=virgin, else already-hicked)
   901  a44f 100a                       bpl allowhickup
   902                          
   903                                  ;; already hicked
   904                                  ;;
   905  a451 a2c8                       ldx #<msg_alreadyhicked
   906  a453 a0b1                       ldy #>msg_alreadyhicked
   907  a455 20c8a8                     jsr printmessage
   908                          
   909  a458 4ce5a4                     jmp posthickup
   910                          
   911                          ;;         ========================
   912                          
   913                          allowhickup:        ;; BG was label nextdirectoryentry3:
   914                          
   915                                  ;; Prepare 32-bit pointer for loading hickup @ $0004000
   916                                  ;;
   917                                  ;; We load it at $4000, which is mapped to first 64KB RAM, and then
   918                                  ;; have a routine also in RAM that we use to copy the loaded data
   919                                  ;; back onto the Hyppo "ROM" space, so that there are no problems
   920                                  ;; with the copying code being changed while it being replaced.
   921                                  ;;
   922  a45b a900                       lda #$00
   923  a45d 8518                       sta <dos_file_loadaddress+0
   924  a45f a940                       lda #$40
   925  a461 8519                       sta <dos_file_loadaddress+1
   926  a463 a900                       lda #$00
   927  a465 851a                       sta <dos_file_loadaddress+2
   928  a467 a900                       lda #$00
   929  a469 851b                       sta <dos_file_loadaddress+3
   930                          
   931  a46b a2e8                       ldx #<txt_HICKUPM65
   932  a46d a0b2                       ldy #>txt_HICKUPM65
   933  a46f 204a99                     jsr dos_setname
   934                          
   935                                  ;; print debug message
   936                                  ;;
   937                                  +Checkpoint "  try-loading HICKUP"
   938                          
   939  a472 204798                     jsr dos_readfileintomemory
   940  a475 906e                       bcc nohickup
   941                          
   942                          ;;         ========================
   943                          
   944                                  ;; We have loaded a hickup file, so jump into it.
   945                          
   946                                  ;; print debug message
   947                                  ;;
   948                                  +Checkpoint "  loaded OK HICKUP"
   949                          
   950                          ;;                 ldx #<msg_hickuploaded
   951                          ;;                 ldy #>msg_hickuploaded
   952                          ;;                 jsr printmessage
   953                          
   954  a477 a000                       ldy #$00
   955  a479 ab1300                     ldz <zptempv32+3        ;; BG what is in this register? Where is the data set?
   956  a47c 2041a9                     jsr printhex
   957  a47f ab1200                     ldz <zptempv32+2
   958  a482 2041a9                     jsr printhex
   959  a485 ab1100                     ldz <zptempv32+1
   960  a488 2041a9                     jsr printhex
   961  a48b ab1000                     ldz <zptempv32+0
   962  a48e 2041a9                     jsr printhex
   963                          
   964                          dohickup:
   965                                  ;; Use DMAgic to copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
   966                                  ;; (We have to copy the routine to do this to RAM, since we will
   967                                  ;; be replacing ourselves)
   968  a491 a200                       ldx #$00
   969  a493 bd9fa4             krc:        lda hickuproutine,x
   970  a496 9d0030                     sta $3000,x
   971  a499 e8                         inx
   972  a49a d0f7                       bne krc
   973  a49c 4c0030                     jmp $3000
   974                          
   975                          ;;         ========================
   976                          
   977                          hickuproutine:
   978                                  ;; The following routine gets copied as-is to $3000 and run from there.
   979                                  ;; The DMA list is still available in the hyppo ROM when it gets
   980                                  ;; called, so we can just use it there, instead of working out where
   981                                  ;; it gets copied to
   982                          
   983                                  ;; NOTE that only 256-bytes are copied, so the hickuproutine and hickupdmalist
   984                                  ;;      cannot exceed this limit, else revise the krc routine.
   985                          
   986                                  ;; Set bottom 22 bits of DMA list address as for C65
   987                                  ;; (8MB address range).  Hyppo ROM is at $FFF8000, so $FF goes
   988                                  ;; in high-byte area
   989                                  ;;
   990  a49f a9ff                       lda #$ff
   991  a4a1 8d02d7                     sta $d702
   992  a4a4 a9ff                       lda #$ff
   993  a4a6 8d04d7                     sta $d704  ;; dma list is in top MB of address space
   994  a4a9 a9a4                       lda #>hickupdmalist
   995  a4ab 8d01d7                     sta $d701
   996                                  ;; Trigger enhanced DMA
   997  a4ae a9b9                       lda #<hickupdmalist
   998  a4b0 8d05d7                     sta $d705
   999                          
  1000                                  ;; copy complete, so mark ourselves upgraded, and jump into hypervisor
  1001                                  ;; as though we were just reset.
  1002                          
  1003                                  ;; (it doesn't matter what gets written to this register, it is just the fact that it has been
  1004                                  ;; written to, that sets the flag).
  1005                                  ;;
  1006  a4b3 8d7ed6                     sta hypervisor_hickedup_flag        ;; mark ourselves as having hicked up, (00=virgin, else already-hicked)
  1007  a4b6 4c0081                     jmp $8100
  1008                          
  1009                          ;;         ========================
  1010                          
  1011                          hickupdmalist:
  1012                                  ;; MEGA65 Enhanced DMA options
  1013  a4b9 0a                         !8 $0A  ;; Request format is F018A
  1014  a4ba 8000                       !8 $80,$00 ;; Source is $00xxxxx
  1015  a4bc 81ff                       !8 $81,$FF ;; Destination is $FF
  1016  a4be 00                         !8 $00  ;; No more options
  1017                                  ;; copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
  1018                                  ;; F018A DMA list
  1019                                  ;; (MB offsets get set in routine)
  1020  a4bf 00                         !8 $00 ;; copy + last request in chain
  1021  a4c0 0040                       !16 $4000 ;; size of copy is 16KB
  1022  a4c2 0040                       !16 $4000 ;; starting at $4000
  1023  a4c4 00                         !8 $00   ;; of bank $0
  1024  a4c5 0080                       !16 $8000 ;; destination address is $8000
  1025  a4c7 0f                         !8 $0F   ;; of bank $F
  1026  a4c8 0000                       !16 $0000 ;; modulo (unused)
  1027                          
  1028                          ;;         ========================
  1029                          
  1030                          cdroot_and_complain_if_fails:
  1031                          	
  1032  a4ca ae02bc                     ldx dos_default_disk
  1033  a4cd 208d92                     jsr dos_cdroot
  1034  a4d0 b011                       bcs @cdroot_ok
  1035                          
  1036                                  ;; failed
  1037                                  ;;
  1038  a4d2 a227                       ldx #<msg_cdrootfailed
  1039  a4d4 a0b2                       ldy #>msg_cdrootfailed
  1040  a4d6 20c8a8                     jsr printmessage
  1041  a4d9 a000                       ldy #$00
  1042  a4db abfabc                     ldz dos_error_code
  1043  a4de 2041a9                     jsr printhex
  1044  a4e1 18                         clc
  1045  a4e2 60                         rts
  1046                          
  1047                                  +Checkpoint "FAILED CDROOT"
  1048                          @cdroot_ok:
  1049  a4e3 38                         sec
  1050  a4e4 60                         rts
  1051                          	
  1052                          couldntopenhickup:
  1053                          
  1054                          nohickup:
  1055                          ;;                 ldx #<msg_nohickup
  1056                          ;;                 ldy #>msg_nohickup
  1057                          ;;                 jsr printmessage
  1058                          
  1059                          posthickup:
  1060                          
  1061                                  ;; MILESTONE: Have file system properties.
  1062                          
  1063                                  ;; Look for MEGA65.D81 to mount for F011 emulation
  1064                          
  1065                                  ;; print debug message
  1066                                  ;;
  1067                          !if DEBUG_HYPPO {
  1068                                  +Checkpoint "  Here we are POST-HICKUP"
  1069                          
  1070                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
  1071                          }
  1072                          
  1073                                  ;; for now indicate that there is no disk in drive
  1074                                  ;; (unless we notice that floppy access has been virtualised)
  1075  a4e5 ad59d6                     lda hypervisor_hardware_virtualisation
  1076  a4e8 2901                       and #$01
  1077  a4ea d005                       bne f011Virtualised
  1078  a4ec a900                       lda #$00
  1079  a4ee 8d8bd6                     sta sd_f011_en        ;; f011 emulation
  1080                          f011Virtualised:
  1081                          
  1082                                  ;; Go to root directory on default disk
  1083                                  ;;
  1084  a4f1 20caa4             	jsr cdroot_and_complain_if_fails
  1085                          
  1086                                  ;; Re-set virtual screen row length after touching $D06F
  1087  a4f4 a950                       lda #80
  1088  a4f6 8d58d0                     sta $d058
  1089                          
  1090                          	;; Check internal drive / SD card status, and don't mount D81 if set to use internal drive
  1091                          	;; Not only would this be a waste of time, it also stomps the $D6A1 bit 0 that indicates
  1092                          	;; to use the internal drive.
  1093  a4f9 ada1d6             	lda $d6a1
  1094  a4fc 2901               	and #$01
  1095  a4fe d01b               	bne @dontMountD81
  1096                          	
  1097                                  ;; set name of file we are looking for
  1098                                  ;;
  1099  a500 a2d7                       ldx #<txt_MEGA65D81
  1100  a502 a0b2                       ldy #>txt_MEGA65D81
  1101  a504 204a99                     jsr dos_setname
  1102                          
  1103                                  ;; print debug message
  1104                                  ;;
  1105                                  +Checkpoint "  try-mounting MEGA65.D81"
  1106                          
  1107  a507 20b593                     jsr dos_findfile
  1108  a50a 9012                       bcc d81attachfail
  1109  a50c 205b93                     jsr dos_closefile
  1110                          
  1111  a50f 207b99                     jsr dos_d81attach0
  1112  a512 900a                       bcc d81attachfail
  1113                          
  1114  a514 a206                       ldx #<msg_d81mounted
  1115  a516 a0b1                       ldy #>msg_d81mounted
  1116  a518 20c8a8                     jsr printmessage
  1117                          
  1118                                  ;; print debug message
  1119                                  ;;
  1120                                  +Checkpoint "  mounted MEGA65.D81"
  1121                          
  1122                          @dontMountD81:
  1123                                  ;; all done, move on to loading the ROM
  1124                                  ;;
  1125  a51b 4ce5a5                     jmp loadrom
  1126                          
  1127                          ;;         ========================
  1128                          
  1129                          d81attachfail:
  1130                                  ;; we couldn't find the D81 file, so tell the user
  1131                                  ;;
  1132  a51e a2e7                       ldx #<msg_nod81
  1133  a520 a0b0                       ldy #>msg_nod81
  1134  a522 20c8a8                     jsr printmessage
  1135  a525 a000                       ldy #$00
  1136  a527 abfabc                     ldz dos_error_code
  1137  a52a 2041a9                     jsr printhex
  1138                          
  1139                                  ;; debug
  1140                                  +Checkpoint "couldnt mount/attach MEGA65.D81"
  1141                          
  1142  a52d 4ce5a5             	jmp loadrom
  1143                          	
  1144                          ;;         ========================
  1145                          
  1146                          tryloadbootlogofromflash:
  1147                          
  1148  a530 208aa5             	jsr setup_banner_load_pointer
  1149  a533 20c39f             	jsr sd_map_sectorbuffer
  1150                          
  1151                          	;;  Check if we have BANNER.M65 embedded in flash.
  1152                          	
  1153                          	;; Load first sector of flash to check for banner present
  1154                          	;; byte.
  1155  a536 a900               	lda #$00
  1156  a538 a203               	ldx #3
  1157                          @zoop:
  1158  a53a 9d81d6             	sta $d681,x
  1159  a53d ca                 	dex
  1160  a53e 10fa               	bpl @zoop
  1161  a540 a953               	lda #$53
  1162  a542 8d80d6             	sta $d680
  1163                          	;; Wait a little while for flash to read
  1164                          @zoop2:	
  1165  a545 ca                 	dex
  1166  a546 d0fd               	bne @zoop2
  1167  a548 ad71de             	lda $de71
  1168  a54b c901               	cmp #$01
  1169  a54d f003               	beq loadbannerfromflash
  1170  a54f 4ccf9f             	jmp sd_unmap_sectorbuffer
  1171                          
  1172                          loadbannerfromflash:
  1173                          	;; Load and display boot logo
  1174                          	;; Logo will be at $7F8000-$7FFFFF
  1175                          
  1176  a552 a980               	lda #$80
  1177  a554 8d82d6             	sta $d682
  1178  a557 a97f               	lda #$7f
  1179  a559 8d83d6             	sta $d683
  1180  a55c a900                       lda #$00
  1181  a55e 8d81d6             	sta $d681
  1182  a561 8d84d6             	sta $d684
  1183                          
  1184  a564 20c39f                     jsr sd_map_sectorbuffer
  1185                          
  1186                          nextflashbannersector:	
  1187                          	
  1188  a567 a953               	lda #$53
  1189  a569 8d80d6             	sta $d680
  1190                          	;; No need to wait long here, because our copy routine is so slow
  1191                          	;; Use the #$53 above
  1192                          @zzminus:
  1193  a56c 3a                 	dec
  1194  a56d 10fd               	bpl @zzminus
  1195                          	;; Leaves A=$00 which we use below for TAx/z to save bytes
  1196                          	
  1197                          stashbannersector:	
  1198                          
  1199                          	;;  Advance $100 bytes to next flash sector
  1200  a56f ee82d6             	inc $d682
  1201                          	
  1202  a572 a200               	ldx #0
  1203  a574 a300               	ldz #0
  1204                          
  1205                                  ;; Actually write the bytes to memory that have been loaded
  1206                          zdrfim_rr1:
  1207  a576 bd00de                     lda sd_sectorbuffer,x                ;; is $DE00
  1208  a579 ea9218                     sta [<dos_file_loadaddress],z
  1209  a57c 1b                         inz ;; dest offset
  1210  a57d e8                         inx ;; src offset
  1211  a57e d0f6               	bne zdrfim_rr1
  1212                          
  1213  a580 e619                       inc <dos_file_loadaddress+1
  1214  a582 d0e3               	bne nextflashbannersector
  1215                          
  1216  a584 20cf9f             	jsr sd_unmap_sectorbuffer
  1217                          	
  1218                          	;; Now display it
  1219  a587 4c82a8             	jmp setbannerpalette
  1220                          
  1221                          	
  1222                          setup_banner_load_pointer:	
  1223                          	
  1224                                  ;; Prepare 32-bit pointer for loading boot logo @ $0057D00
  1225                                  ;; (palette is $57D00-$57FFF, logo $58000-$5CFFF)
  1226  a58a a900                       lda #$00
  1227  a58c 8518                       sta <dos_file_loadaddress+0
  1228  a58e a97d                       lda #$7d
  1229  a590 8519                       sta <dos_file_loadaddress+1
  1230  a592 a905                       lda #$05
  1231  a594 851a                       sta <dos_file_loadaddress+2
  1232  a596 a900                       lda #$00
  1233  a598 851b                       sta <dos_file_loadaddress+3
  1234  a59a 60                 	rts
  1235                          	
  1236                          	
  1237                          attempt_loadcharrom:
  1238                                  ;; Load CHARROM.M65 into character ROM
  1239                                  ;;
  1240  a59b a2bf                       ldx #<txt_CHARROMM65
  1241  a59d a0b2                       ldy #>txt_CHARROMM65
  1242  a59f 204a99                     jsr dos_setname
  1243                          
  1244                                  ;; Prepare 32-bit pointer for loading whole ROM ($FF7E000)
  1245                                  ;;
  1246  a5a2 a900                       lda #$00
  1247  a5a4 8518                       sta <dos_file_loadaddress+0
  1248  a5a6 a9e0                       lda #$E0
  1249  a5a8 8519                       sta <dos_file_loadaddress+1
  1250  a5aa a9f7                       lda #$F7
  1251  a5ac 851a                       sta <dos_file_loadaddress+2
  1252  a5ae a90f                       lda #$0F
  1253  a5b0 851b                       sta <dos_file_loadaddress+3
  1254                          
  1255  a5b2 4c4798                     jmp dos_readfileintomemory
  1256                          
  1257                          attempt_loadc65rom:
  1258  a5b5 a2cb                       ldx #<txt_MEGA65ROM
  1259  a5b7 a0b2                       ldy #>txt_MEGA65ROM
  1260  a5b9 204a99                     jsr dos_setname
  1261                          
  1262                                  ;; Prepare 32-bit pointer for loading whole ROM ($0020000)
  1263                                  ;;
  1264  a5bc a900                       lda #$00
  1265  a5be 8518                       sta <dos_file_loadaddress+0
  1266  a5c0 8519                       sta <dos_file_loadaddress+1
  1267  a5c2 851b                       sta <dos_file_loadaddress+3
  1268  a5c4 a902                       lda #$02
  1269  a5c6 851a                       sta <dos_file_loadaddress+2
  1270                          
  1271  a5c8 4c4798                     jmp dos_readfileintomemory
  1272                          
  1273                          attempt_load1541rom:
  1274  a5cb a2b3                       ldx #<txt_1541ROM
  1275  a5cd a0b2                       ldy #>txt_1541ROM
  1276  a5cf 204a99                     jsr dos_setname
  1277                          
  1278                                  ;; Prepare 32-bit pointer for loading whole ROM ($FFDC000)
  1279                                  ;;
  1280  a5d2 a900                       lda #$00
  1281  a5d4 8518                       sta <dos_file_loadaddress+0
  1282  a5d6 a9c0                       lda #$C0
  1283  a5d8 8519                       sta <dos_file_loadaddress+1
  1284  a5da a9fd                       lda #$FD
  1285  a5dc 851a                       sta <dos_file_loadaddress+2
  1286  a5de a90f                       lda #$0F
  1287  a5e0 851b                       sta <dos_file_loadaddress+3
  1288                          
  1289  a5e2 4c4798                     jmp dos_readfileintomemory
  1290                          
  1291                          loadrom:
  1292                          
  1293                          !if DEBUG_HYPPO {
  1294                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
  1295                          }
  1296                          
  1297                                  ;; ROMs are not loaded, so try to load them, or prompt
  1298                                  ;; for user to insert SD card
  1299                                  ;;
  1300                          ;;                 ldx #<msg_rombad
  1301                          ;;                 ldy #>msg_rombad
  1302                          ;;                 jsr printmessage
  1303                          
  1304                                  ;; print debug message
  1305                                  ;;
  1306                                  +Checkpoint "  try-loading CHAR-ROM"
  1307                          
  1308  a5e5 209ba5                     jsr attempt_loadcharrom
  1309  a5e8 b003                       bcs loadedcharromok
  1310                          
  1311  a5ea 4cf4a5                     jmp loadc65rom
  1312                          
  1313                          ;;         ========================
  1314                          
  1315                          loadedcharromok:
  1316                          !if DEBUG_HYPPO {
  1317                                  ;; print debug message
  1318                                  ;;
  1319                                  +Checkpoint "  OK-loading CHARROM"
  1320                          
  1321                                  ;; prepare debug message
  1322                                  ;;
  1323                                  ldx dos_current_file_descriptor_offset
  1324                                  lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0,x
  1325                                  sta file_pagesread
  1326                                  lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1,x
  1327                                  sta file_pagesread+1
  1328                          }
  1329                          
  1330  a5ed a2c5                       ldx #<msg_charromloaded
  1331  a5ef a0ae                       ldy #>msg_charromloaded
  1332  a5f1 20c8a8                     jsr printmessage
  1333                          
  1334                          
  1335                          loadc65rom:
  1336                          
  1337                          !if DEBUG_HYPPO {
  1338                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
  1339                          }
  1340                          
  1341                                  ;; print debug message
  1342                                  ;;
  1343                                  +Checkpoint "  try-loading MEGA65-ROM"
  1344                          
  1345  a5f4 20b5a5                     jsr attempt_loadc65rom
  1346  a5f7 b021                       bcs loadedok
  1347                          
  1348                          ;;         ========================
  1349                          
  1350                                  ;; ROM not found: indicate which ROM we were looking for
  1351                                  ;;
  1352  a5f9 a20b                       ldx #$0b
  1353  a5fb bdcbb2             l17d:   lda txt_MEGA65ROM,x
  1354  a5fe 9d7eb1                     sta msg_romnotfound+19,x
  1355  a601 ca                         dex
  1356  a602 d0f7                       bne l17d
  1357  a604 a26b                       ldx #<msg_romnotfound
  1358  a606 a0b1                       ldy #>msg_romnotfound
  1359  a608 20c8a8                     jsr printmessage
  1360                          
  1361  a60b 20869f                     jsr sdwaitawhile
  1362  a60e 20869f                     jsr sdwaitawhile
  1363  a611 20869f                     jsr sdwaitawhile
  1364  a614 20869f                     jsr sdwaitawhile
  1365                          
  1366  a617 4cb9a6                     jmp sdcarderror
  1367                          
  1368                          ;;         ========================
  1369                          
  1370                                  ;; ROM was found and loaded
  1371                          loadedok:
  1372  a61a aef9bc                     ldx dos_current_file_descriptor_offset
  1373  a61d bdc5bc                     lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset +0,x
  1374  a620 8d25bf                     sta file_pagesread
  1375  a623 bdc6bc                     lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset +1,x
  1376  a626 8d26bf                     sta file_pagesread+1
  1377                          
  1378                                  ;; check the size of the loaded file
  1379                                  ;; i.e., that we have loaded $0200 x $100 = $20000 = 128KiB
  1380  a629 ad26bf                     lda file_pagesread+1
  1381  a62c c900                       cmp #$00
  1382  a62e d003                       bne @romFileNotTooShort
  1383                          @romFileIsTooShort:
  1384  a630 4ca5a6                     jmp romfiletooshort
  1385                          @romFileNotTooShort:
  1386  a633 c901                       cmp #$01
  1387  a635 f0f9                       beq @romFileIsTooShort
  1388  a637 c902                       cmp #$02
  1389  a639 d005                       bne @romFileIsTooLong
  1390  a63b ad25bf                     lda file_pagesread
  1391  a63e f003                       beq @romFileNotTooLong
  1392                          @romFileIsTooLong:
  1393  a640 4c98a6                     jmp romfiletoolong
  1394                          @romFileNotTooLong:
  1395                          
  1396                                  ;; the loaded ROM was OK in size
  1397                          
  1398  a643 20bf84                     jsr syspart_dmagic_autoset
  1399                          
  1400                                  ;; copy character ROM portion into place
  1401                                  ;; i.e., copy $2Dxxx to $FF7Exxx
  1402                          
  1403  a646 a9ff                       lda #$ff
  1404  a648 8d02d7                     sta $d702
  1405  a64b 8d04d7                     sta $d704
  1406  a64e a900                       lda #$00
  1407  a650 a9a6                       lda #>charromdmalist
  1408  a652 8d01d7                     sta $d701
  1409  a655 a95d                       lda #<charromdmalist
  1410  a657 8d05d7                     sta $d705
  1411                          
  1412  a65a 4c6ca6                     jmp loadedmegaromok
  1413                          
  1414                          charromdmalist:
  1415                                  ;; M65 DMA options
  1416  a65d 0a                         !8 $0A    ;; Request format is F018A
  1417  a65e 81ff                       !8 $81,$FF ;; destination is $FFxxxxx
  1418  a660 00                         !8 $00 ;; no more options
  1419                                  ;; F018A DMA list
  1420  a661 00                         !8 $00
  1421  a662 0010                       !16 $1000
  1422  a664 00d0                       !16 $D000
  1423  a666 02                         !8 $02
  1424  a667 00e0                       !16 $E000
  1425  a669 07                         !8 $07
  1426  a66a 0000                       !16 $0000
  1427                          
  1428                          loadedmegaromok:
  1429                          
  1430                          !if DEBUG_HYPPO {
  1431                                  ;; prepare debug message
  1432                                  ;;
  1433                                  ldx dos_current_file_descriptor_offset
  1434                                  lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0,x
  1435                                  sta file_pagesread
  1436                                  lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1,x
  1437                                  sta file_pagesread+1
  1438                          }
  1439                          
  1440  a66c a2d8                       ldx #<msg_megaromloaded
  1441  a66e a0ae                       ldy #>msg_megaromloaded
  1442  a670 20c8a8                     jsr printmessage
  1443                          
  1444                                  ;; ROM file loaded, transfer control
  1445                                  ;;
  1446  a673 a2ab                       ldx #<msg_romok
  1447  a675 a0ae                       ldy #>msg_romok
  1448  a677 20c8a8                     jsr printmessage
  1449                          
  1450                                  ;; print debug message
  1451                                  ;;
  1452                                  +Checkpoint "  OK-loaded MEGA65-ROM"
  1453                          
  1454  a67a 20cba5                     jsr attempt_load1541rom
  1455  a67d b007                       bcs loaded1541rom
  1456                          
  1457                                  +Checkpoint "  FAIL loading 1541 ROM"
  1458                          
  1459  a67f a2ad                       ldx #<msg_no1541rom
  1460  a681 a0b1                       ldy #>msg_no1541rom
  1461  a683 20c8a8                     jsr printmessage
  1462                          
  1463                          loaded1541rom:
  1464                          !if DEBUG_HYPPO {
  1465                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
  1466                          }
  1467                                  ;; check for keyboard input to jump to utility menu
  1468  a686 20eeaa                     jsr utility_menu_check
  1469  a689 20e2aa                     jsr scankeyboard
  1470  a68c b007                       bcs nokey4
  1471  a68e c920                       cmp #$20
  1472  a690 d003                       bne nokey4
  1473  a692 4c92ab                     jmp utility_menu
  1474                          nokey4:
  1475  a695 4c68a9                     jmp go64
  1476                          
  1477                          ;;         ========================
  1478                          
  1479                          romfiletoolong:
  1480  a698 a274                       ldx #<msg_romfilelongerror
  1481  a69a a0b0                       ldy #>msg_romfilelongerror
  1482  a69c 20c8a8                     jsr printmessage
  1483                          !if DEBUG_HYPPO {
  1484                                  ldz file_pagesread+1
  1485                                  jsr printhex
  1486                                  ldz file_pagesread
  1487                                  jsr printhex
  1488                          }
  1489  a69f 20869f                     jsr sdwaitawhile
  1490  a6a2 4cc3a2                     jmp reset_entry
  1491                          
  1492                          romfiletooshort:
  1493  a6a5 a294                       ldx #<msg_romfileshorterror
  1494  a6a7 a0b0                       ldy #>msg_romfileshorterror
  1495  a6a9 20c8a8                     jsr printmessage
  1496                          !if DEBUG_HYPPO {
  1497                                  ldz file_pagesread+1
  1498                                  jsr printhex
  1499                                  ldz file_pagesread
  1500                                  jsr printhex
  1501                          }
  1502  a6ac 20869f                     jsr sdwaitawhile
  1503  a6af 4cc3a2                     jmp reset_entry
  1504                          
  1505                          ;;         ========================
  1506                          
  1507                          fileopenerror:
  1508  a6b2 a23c                       ldx #<msg_fileopenerror
  1509  a6b4 a0b0                       ldy #>msg_fileopenerror
  1510  a6b6 20c8a8                     jsr printmessage
  1511                          
  1512                          sdcarderror:
  1513  a6b9 a246                       ldx #<msg_sdcarderror
  1514  a6bb a0af                       ldy #>msg_sdcarderror
  1515  a6bd 20c8a8                     jsr printmessage
  1516                          
  1517  a6c0 20869f                     jsr sdwaitawhile
  1518  a6c3 4cc3a2                     jmp reset_entry
  1519                          
  1520                          ;;         ========================
  1521                          
  1522                          badfs:
  1523  a6c6 a292                       ldx #<msg_badformat
  1524  a6c8 a0af                       ldy #>msg_badformat
  1525  a6ca 20c8a8                     jsr printmessage
  1526                          
  1527  a6cd 20869f                     jsr sdwaitawhile
  1528  a6d0 4cc3a2                     jmp reset_entry
  1529                          
  1530                          ;; /*  -------------------------------------------------------------------
  1531                          ;;     Display and basic IO routines
  1532                          ;;     ---------------------------------------------------------------- */
  1533                          
  1534                          resetdisplay:
  1535                                  ;; reset screen
  1536                                  ;;
  1537  a6d3 a940                       lda #$40        ;; 0100 0000 = choose charset
  1538  a6d5 8d30d0                     sta $d030        ;; VIC-III Control Register A
  1539                          
  1540  a6d8 ad31d0                     lda $d031        ;; VIC-III Control Register B
  1541  a6db 2940                       and #$40        ;; bit-6 is 4mhz
  1542  a6dd 8d31d0                     sta $d031
  1543                          
  1544  a6e0 a900                       lda #$00        ;; black
  1545  a6e2 8d20d0                     sta $D020       ;; border
  1546  a6e5 8d21d0                     sta $D021       ;; background
  1547  a6e8 8d11d7             	sta $D711 	;; Disable DMA audio
  1548                          
  1549                                  ;; Start in 60Hz mode, since most monitors support it
  1550                                  ;; (Also required to make sure matrix mode pixels aren't ragged on first boot).
  1551                          	;; The label here is used so that the syspartition settings can be used to
  1552                          	;; change the default video mode on reset.
  1553                          pal_ntsc_minus_1:	
  1554  a6eb a980                       lda #$80
  1555  a6ed 8d6fd0                     sta $d06f
  1556                          
  1557                                  ;; disable test pattern and various other strange video things that might be hanging around
  1558  a6f0 a980                       lda #$80
  1559  a6f2 1c66d0                     trb $d066
  1560  a6f5 a900                       lda #$00
  1561  a6f7 8d6ad0                     sta $d06a ;; bank# for screen address
  1562  a6fa 8d6bd0                     sta $d06b ;; 16-colour sprites
  1563  a6fd 8d78d0                     sta $d078 ;; sprite Y super MSBs
  1564  a700 8d5fd0                     sta $d05f ;; sprite X super MSBs
  1565  a703 a978                       lda #$78
  1566  a705 8d5ad0                     sta $d05a ;; correct horizontal scaling
  1567  a708 a9c0                       lda #$C0
  1568  a70a 8d5dd0                     sta $D05D ;; enable hot registers, raster delay
  1569  a70d a950                       lda #80
  1570  a70f 8d5cd0                     sta $D05C ;; Side border width LSB
  1571                          
  1572                                  ;; point VIC-IV to bottom 16KB of display memory
  1573                                  ;;
  1574  a712 a9ff                       lda #$ff
  1575  a714 8d01dd                     sta $DD01
  1576  a717 8d00dd                     sta $DD00
  1577                          
  1578                                  ;; We use VIC-II style registers as this resets video frame in
  1579                                  ;; least instructions, and 40 columns is fine for us.
  1580                                  ;;
  1581  a71a a914                       lda #$14        ;; 0001 0100
  1582  a71c 8d18d0                     sta $D018        ;; VIC-II Character/Screen location
  1583                          
  1584  a71f a91b                       lda #$1B        ;; 0001 1011
  1585  a721 8d11d0                     sta $D011        ;; VIC-II Control Register
  1586                          
  1587  a724 a9c8                       lda #$C8        ;; 1100 1000
  1588  a726 8d16d0                     sta $D016        ;; VIC-II Control Register
  1589                          
  1590                                  ;; Now switch to 16-bit text mode so that we can use proportional
  1591                                  ;; characters and full-colour characters for chars >$FF for the logo
  1592                          	;; Also enable CRT emulation by default.
  1593                                  ;;
  1594  a729 a9e5                       lda #$e5
  1595  a72b 8d54d0                     sta $d054        ;; VIC-IV Control Register C
  1596                          
  1597                                  ;; and 80 bytes (40 16-bit characters) per row.
  1598                                  ;;
  1599  a72e a950                       lda #<80
  1600  a730 8d58d0                     sta $d058
  1601  a733 a900                       lda #>80
  1602  a735 8d59d0                     sta $d059
  1603                          
  1604  a738 60                         rts
  1605                          
  1606                          ;;         ========================
  1607                          
  1608                          resetpalette:
  1609                                  ;; reset VIC-IV palette to sensible defaults.
  1610                                  ;; load C64 colours into palette bank 3 for use when
  1611                                  ;; PAL bit in $D030 is set.
  1612                                  ;;
  1613  a739 a904                       lda #$04
  1614  a73b 0c30d0                     tsb $D030        ;; enable PAL bit in $D030
  1615                          
  1616  a73e 2082a8             	jsr setbannerpalette
  1617                          	
  1618                                  ;; C64 colours designed to look like C65 colours on an
  1619                                  ;; RGBI screen.
  1620                                  ;;
  1621                                  ;; formatted in ASM to help visualise what each code is for.
  1622                                  ;;
  1623  a741 a900                       lda #$00
  1624  a743 8d00d1                         sta $D100
  1625  a746 8d00d2                         sta $D200
  1626  a749 8d00d3                         sta $D300
  1627                          
  1628  a74c a9ff                       lda #$ff
  1629  a74e 8d01d1                         sta $D101
  1630  a751 8d01d2                         sta $D201
  1631  a754 8d01d3                         sta $D301
  1632                          
  1633  a757 a9ba                       lda #$ba
  1634  a759 8d02d1                                 sta $D102
  1635  a75c a913                               lda #$13
  1636  a75e 8d02d2                                 sta $D202
  1637  a761 a962                               lda #$62
  1638  a763 8d02d3                                 sta $D302
  1639                          
  1640  a766 a966                               lda #$66
  1641  a768 8d03d1                                 sta $D103
  1642  a76b a9ad                               lda #$ad
  1643  a76d 8d03d2                                 sta $D203
  1644  a770 a9ff                               lda #$ff
  1645  a772 8d03d3                                 sta $D303
  1646                          
  1647  a775 a9bb                               lda #$bb
  1648  a777 8d04d1                                 sta $D104
  1649  a77a a9f3                               lda #$f3
  1650  a77c 8d04d2                                 sta $D204
  1651  a77f a98b                               lda #$8b
  1652  a781 8d04d3                                 sta $D304
  1653                          
  1654  a784 a955                               lda #$55
  1655  a786 8d05d1                                 sta $D105
  1656  a789 a9ec                               lda #$ec
  1657  a78b 8d05d2                                 sta $D205
  1658  a78e a985                               lda #$85
  1659  a790 8d05d3                                 sta $D305
  1660                          
  1661  a793 a9d1                               lda #$d1
  1662  a795 8d06d1                                 sta $D106
  1663  a798 a9e0                               lda #$e0
  1664  a79a 8d06d2                                 sta $D206
  1665  a79d a979                               lda #$79
  1666  a79f 8d06d3                                 sta $D306
  1667                          
  1668  a7a2 a9ae                               lda #$ae
  1669  a7a4 8d07d1                                 sta $D107
  1670  a7a7 a95f                               lda #$5f
  1671  a7a9 8d07d2                                 sta $D207
  1672  a7ac a9c7                               lda #$c7
  1673  a7ae 8d07d3                                 sta $D307
  1674                          
  1675  a7b1 a99b                               lda #$9b
  1676  a7b3 8d08d1                                 sta $D108
  1677  a7b6 a947                               lda #$47
  1678  a7b8 8d08d2                                 sta $D208
  1679  a7bb a981                               lda #$81
  1680  a7bd 8d08d3                                 sta $D308
  1681                          
  1682  a7c0 a987                               lda #$87
  1683  a7c2 8d09d1                                 sta $D109
  1684  a7c5 a937                               lda #$37
  1685  a7c7 8d09d2                                 sta $D209
  1686  a7ca a900                               lda #$00
  1687  a7cc 8d09d3                                 sta $D309
  1688                          
  1689  a7cf a9dd                               lda #$dd
  1690  a7d1 8d0ad1                                 sta $D10a
  1691  a7d4 a939                               lda #$39
  1692  a7d6 8d0ad2                                 sta $D20a
  1693  a7d9 a978                               lda #$78
  1694  a7db 8d0ad3                                 sta $D30a
  1695                          
  1696  a7de a9b5                               lda #$b5
  1697  a7e0 8d0bd1                                 sta $D10b
  1698  a7e3 8d0bd2                                 sta $D20b
  1699  a7e6 8d0bd3                                 sta $D30b
  1700                          
  1701  a7e9 a9b8                               lda #$b8
  1702  a7eb 8d0cd1                                 sta $D10c
  1703  a7ee 8d0cd2                                 sta $D20c
  1704  a7f1 8d0cd3                                 sta $D30c
  1705                          
  1706  a7f4 a90b                               lda #$0b
  1707  a7f6 8d0dd1                                 sta $D10d
  1708  a7f9 a94f                               lda #$4f
  1709  a7fb 8d0dd2                                 sta $D20d
  1710  a7fe a9ca                               lda #$ca
  1711  a800 8d0dd3                                 sta $D30d
  1712                          
  1713  a803 a9aa                               lda #$aa
  1714  a805 8d0ed1                                 sta $D10e
  1715  a808 a9d9                               lda #$d9
  1716  a80a 8d0ed2                                 sta $D20e
  1717  a80d a9fe                               lda #$fe
  1718  a80f 8d0ed3                                 sta $D30e
  1719                          
  1720  a812 a98b                               lda #$8b
  1721  a814 8d0fd1                                 sta $D10f
  1722  a817 8d0fd2                                 sta $D20f
  1723  a81a 8d0fd3                                 sta $D30f
  1724                          
  1725                          
  1726  a81d 60                     rts
  1727                          
  1728                          ;;         ========================
  1729                          
  1730                          ;; erase standard 40-column screen
  1731                          ;;
  1732                          erasescreen:
  1733                                  ;; bank in 2nd KB of colour RAM
  1734                                  ;;
  1735  a81e a901                       lda #$01
  1736  a820 0c30d0                     tsb $D030
  1737                          
  1738                                  ;; use DMA to clear screen and colour RAM
  1739                                  ;; The screen is in 16-bit bit mode, so we actually need to fill
  1740                                  ;; with $20,$00, ...
  1741                                  ;;
  1742                                  ;; We will cheat by setting the first four bytes, and then copying from
  1743                                  ;; there, and it will then read from the freshly written bytes.
  1744                                  ;; (two bytes might not be enough to allow the write from the last DMA
  1745                                  ;;  action to be avaialble for reading because of how the DMAgic is
  1746                                  ;;  pipelined).
  1747                                  ;;
  1748  a823 a920                       lda #$20
  1749  a825 8d0004                     sta $0400
  1750  a828 8d0204                     sta $0402
  1751  a82b a900                       lda #$00
  1752  a82d 8d0104                     sta $0401
  1753  a830 8d0304                     sta $0403
  1754                          
  1755                                  ;; Set bottom 22 bits of DMA list address as for C65
  1756                                  ;; (8MB address range)
  1757                                  ;;
  1758  a833 a9ff                       lda #$ff
  1759  a835 8d02d7                     sta $d702
  1760                          
  1761                                  ;; Hyppo ROM is at $FFFE000 - $FFFFFFF, so
  1762                                  ;; we need to tell DMAgic that DMA list is in $FFxxxxx.
  1763                                  ;; this has to be done AFTER writing to $d702, as $d702
  1764                                  ;; clears bits 27 - 22 of the DMA list address to help with
  1765                                  ;; compatibility.
  1766                                  ;;
  1767  a838 a9ff                       lda #$ff
  1768  a83a 8d04d7                     sta $d704
  1769                          
  1770  a83d a9a8                       lda #>erasescreendmalist
  1771  a83f 8d01d7                     sta $d701
  1772                          
  1773                                  ;; set bottom 8 bits of address and trigger DMA.
  1774                                  ;;
  1775  a842 a9ad                       lda #<erasescreendmalist
  1776  a844 8d05d7                     sta $d705
  1777                          
  1778                                  ;; bank 2nd KB of colour RAM back out
  1779                                  ;;
  1780  a847 a901                       lda #$01
  1781  a849 1c30d0                     trb $D030
  1782                          
  1783                          ;;         ========================
  1784                          
  1785                                  ;; move cursor back to top of the screen
  1786                                  ;; (but leave 8 rows for logo and banner text)
  1787                                  ;;
  1788  a84c a908                       lda #$08
  1789  a84e 8d20bf                     sta screenrow
  1790                          
  1791                                  ;; draw 40x8 char block for banner
  1792                                  ;;
  1793  a851 a000                       ldy #$00
  1794  a853 a900                       lda #$00
  1795                          logo1:
  1796  a855 990004                     sta $0400,y
  1797  a858 1a                         inc
  1798  a859 c8                         iny
  1799  a85a c8                         iny
  1800  a85b d0f8                       bne logo1
  1801                          logo1a:
  1802  a85d 990005                     sta $0500,y
  1803  a860 1a                         inc
  1804  a861 c8                         iny
  1805  a862 c8                         iny
  1806  a863 d0f8                       bne logo1a
  1807                          logo1b:
  1808  a865 990006                     sta $0600,y
  1809  a868 1a                         inc
  1810  a869 c8                         iny
  1811  a86a c8                         iny
  1812  a86b c080                       cpy #$80
  1813  a86d d0f6                       bne logo1b
  1814                          
  1815                                  ;; then write the high bytes for these (all $01, so char range will be
  1816                                  ;; $100-$140. $100 x $40 = $4000-$4FFF
  1817                                  ;;
  1818  a86f a200                       ldx #$00
  1819  a871 a916                       lda #$16     ;; $1600 x $40 = $58000 where banner tiles sit
  1820                          logo2:
  1821  a873 9d0104                     sta $0401,x
  1822  a876 1a                         inc
  1823  a877 9d8105                     sta $0581,x
  1824  a87a 3a                         dec
  1825  a87b 9d0105                     sta $0501,x
  1826  a87e e8                         inx
  1827  a87f e8                         inx
  1828  a880 d0f1                       bne logo2
  1829                          
  1830                                  ;; finally set palette for banner using contents of memory at $57D00-$57FFF
  1831                          setbannerpalette:
  1832  a882 a9ff                       lda #$ff
  1833  a884 8d70d0                     sta $D070        ;; select palette bank 3 for display and edit
  1834                          
  1835                          	;; Set DMA list address
  1836                                  ;;
  1837  a887 a9a8                       lda #>bannerpalettedmalist
  1838  a889 8d01d7                     sta $d701
  1839  a88c a90f                       lda #$0f
  1840  a88e 8d02d7                     sta $d702 ;; DMA list address is $xxFxxxx
  1841  a891 a9ff                       lda #$ff
  1842  a893 8d04d7                     sta $d704 ;; DMA list address is $FFxxxxx
  1843                          
  1844                                  ;; set bottom bits of DMA list address and trigger enhanced DMA
  1845                                  ;;
  1846  a896 a99c                       lda #<bannerpalettedmalist
  1847  a898 8d05d7                     sta $d705
  1848                          
  1849  a89b 60                         rts
  1850                          
  1851                          bannerpalettedmalist:
  1852                                  ;; MEGA65 enhanced DMA options
  1853  a89c 0a                         !8 $0A      ;; Request format is F018A
  1854  a89d 800081ff                   !8 $80,$00,$81,$FF ;; src = $00xxxxx, dst=$FFxxxxx
  1855  a8a1 00                         !8 $00 ;; no more options
  1856                                  ;; F018A DMA list
  1857  a8a2 00                         !8 $00   ;; COPY + no chained request
  1858  a8a3 0003                       !16 $0300
  1859  a8a5 007d                       !16 $7D00 ;;
  1860  a8a7 05                         !8 $05   ;; source bank 05
  1861  a8a8 0031                       !16 $3100 ;; ; $xxx3100
  1862  a8aa 0d                         !8 $0D   ;; ; $xxDxxxx
  1863  a8ab 0000                       !16 $0000 ;; modulo (unused)
  1864                          
  1865                          
  1866                          
  1867                          ;;         ========================
  1868                          
  1869                          erasescreendmalist:
  1870                                  ;; Clear screen RAM
  1871                                  ;;
  1872                                  ;; MEGA65 enhanced DMA options
  1873  a8ad 0a                         !8 $0A      ;; Request format is F018A
  1874  a8ae 00                         !8 $00 ;; no more options
  1875                                  ;; F018A DMA list
  1876  a8af 04                         !8 $04   ;; COPY + chained request
  1877  a8b0 cc07                       !16 1996  ;; 40x25x2-4 = 1996
  1878  a8b2 0004                       !16 $0400 ;; copy from start of screen at $0400
  1879  a8b4 00                         !8 $00   ;; source bank 00
  1880  a8b5 0404                       !16 $0404 ;; ... to screen at $0402
  1881  a8b7 00                         !8 $00   ;; screen is in bank $00
  1882  a8b8 0000                       !16 $0000 ;; modulo (unused)
  1883                          
  1884                                  ;; Clear colour RAM
  1885                                  ;;
  1886                                  ;; MEGA65 DMA options
  1887  a8ba 81ff                       !8 $81,$FF ;; Destination is $FFxxxxx
  1888  a8bc 00                         !8 $00     ;; no more options
  1889                                  ;; F018A dma list
  1890  a8bd 03                         !8 $03     ;; FILL + no more chained requests
  1891  a8be d007                       !16 2000    ;; 40x25x2 = 2000
  1892  a8c0 01                         !8 $01     ;; fill with white = $01
  1893  a8c1 0000                       !8 $00,$00 ;; rest of source address is ignored in fill
  1894  a8c3 0000                       !16 $0000   ;; destination address
  1895  a8c5 08                         !8 $08     ;; destination bank
  1896  a8c6 0000                       !16 $0000   ;; modulo (unused)
  1897                          
  1898                          
  1899                          ;;         ========================
  1900                          
  1901                          printmessage:        ;; HELPER routine
  1902                                  ;;
  1903                                  ;; This subroutine takes inputs from the X and Y registers,
  1904                                  ;; so set these registers before calling this subroutine,
  1905                                  ;; The X and Y registers need to point to a message as shown below:
  1906                                  ;;
  1907                                  ;;         ldx #<msg_foundsdcard
  1908                                  ;;         ldy #>msg_foundsdcard
  1909                                  ;;         jsr printmessage
  1910                                  ;;
  1911                                  ;; Ie: the X is the high-byte of the 16-bit address, and
  1912                                  ;;     the Y is the low-byte  of the 16-bit address.
  1913                          
  1914  a8c8 860c                       stx <zptempp        ;; zptempp is 16-bit pointer to message
  1915  a8ca 840d                       sty <zptempp+1
  1916                          
  1917  a8cc a900                       lda #$00
  1918  a8ce 850e                       sta <zptempp2        ;; zptempp2 is 16-bit pointer to screen
  1919  a8d0 a904                       lda #$04
  1920  a8d2 850f                       sta <zptempp2+1
  1921                          
  1922  a8d4 ae20bf                     ldx screenrow
  1923                          
  1924                                  ;; Makesure we can't accidentally write on row zero
  1925  a8d7 d002                       bne pm22
  1926  a8d9 a208                       ldx #$08
  1927                          pm22:
  1928                                  ;; if we have reached the bottom of the screen, start writing again
  1929                                  ;; from the top of the screen (but don't touch the top 8 rows for
  1930                                  ;; logo and banner)
  1931  a8db e019                       cpx #25
  1932  a8dd d008                       bne pm2
  1933                          
  1934  a8df 2002ad             	jsr scroll_screen
  1935  a8e2 a218               	ldx #24
  1936  a8e4 8e20bf             	stx screenrow
  1937                          
  1938                                  ;; work out the screen address
  1939                                  ;;
  1940                          pm2:
  1941  a8e7 e000               	cpx #$00
  1942  a8e9 f010                       beq pm1
  1943                          	
  1944  a8eb 18                         clc
  1945  a8ec a50e                       lda <zptempp2
  1946  a8ee 6950                       adc #$50          ;; 40 columns x 16 bit
  1947  a8f0 850e                       sta <zptempp2
  1948  a8f2 a50f                       lda <zptempp2+1
  1949  a8f4 6900                       adc #$00
  1950  a8f6 850f                       sta <zptempp2+1
  1951                          
  1952  a8f8 ca                 pm5:    dex
  1953  a8f9 d0ec                       bne pm2
  1954                          pm1:
  1955                          
  1956                                  ;; Clear line (16-bit chars, so write #$0020 to each word
  1957                                  ;;
  1958  a8fb a000                       ldy #$00
  1959  a8fd a920               pm1b:   lda #$20
  1960  a8ff 910e                       sta (<zptempp2),y
  1961  a901 c8                         iny
  1962  a902 a900                       lda #$00
  1963  a904 910e                       sta (<zptempp2),y
  1964  a906 c8                         iny
  1965  a907 c050                       cpy #$50
  1966  a909 d0f2                       bne pm1b
  1967                          
  1968                          writestring:
  1969  a90b db                         phz
  1970  a90c a000                       ldy #$00
  1971  a90e a300                       ldz #$00
  1972  a910 b10c               pm3:    lda (<zptempp),y
  1973  a912 f013                       beq endofmessage
  1974                          
  1975                                  ;; convert ASCII/PETSCII to screen codes
  1976                                  ;;
  1977  a914 c940                       cmp #$40
  1978  a916 9002                       bcc pm4
  1979  a918 291f                       and #$1f
  1980                          
  1981                          pm4:                ;; write 16-bit character code
  1982                                  ;;
  1983  a91a 920e                       sta (<zptempp2),z
  1984  a91c 1b                         inz
  1985  a91d 48                         pha
  1986  a91e a900                       lda #$00
  1987  a920 920e                       sta (<zptempp2),z
  1988  a922 68                         pla
  1989  a923 c8                         iny
  1990  a924 1b                         inz
  1991  a925 d0e9                       bne pm3
  1992                          endofmessage:
  1993  a927 ee20bf                     inc screenrow
  1994                          
  1995                          !if DEBUG_HYPPO {
  1996                          	;; XXX DEBUG
  1997                          	;; Require key press after each line displayed.
  1998                          ;;	jsr debug_wait_on_key
  1999                          }
  2000                          
  2001  a92a fb                 	plz
  2002  a92b 60                 	rts
  2003                          
  2004                          printbanner:
  2005  a92c 860c                       stx <zptempp
  2006  a92e 840d                       sty <zptempp+1
  2007  a930 a904                       lda #<$0504
  2008  a932 8d0ebf                     sta zptempp2
  2009  a935 a905                       lda #>$0504
  2010  a937 8d0fbf                     sta zptempp2+1
  2011  a93a 200ba9                     jsr writestring
  2012  a93d ce20bf                     dec screenrow
  2013  a940 60                         rts
  2014                          
  2015                          ;;         ========================
  2016                          
  2017                          printhex:
  2018                                  ;; helper function
  2019                                  ;;
  2020                                  ;; seems to want to print the value if the z-reg onto the previous line written to the screen,
  2021                                  ;; so currently the screen consists of say "mounted $$ images"
  2022                                  ;; and this routine will go and change the "$$" to the value in the z-reg
  2023                                  ;;
  2024                                  ;; BG: surely this can be replaced with updating the "$$" before printing the string
  2025                                  ;;
  2026                                  ;; INPUT: .Y, BG seems to be an offset, should be set to zero?
  2027                                  ;; INPUT: .Z, value in Z-reg to be displayed omn the screen
  2028                                  ;;
  2029  a941 6b                         tza
  2030  a942 4a                         lsr
  2031  a943 4a                         lsr
  2032  a944 4a                         lsr
  2033  a945 4a                         lsr
  2034  a946 204ca9                     jsr printhexdigit
  2035  a949 6b                         tza
  2036  a94a 290f                       and #$0f
  2037                          printhexdigit:
  2038                                  ;; find next $ sign to replace with hex digit
  2039                                  ;;
  2040  a94c aa                         tax
  2041  a94d b10e               phd3:   lda (<zptempp2),y
  2042  a94f c924                       cmp #$24
  2043  a951 f007                       beq phd2
  2044  a953 c8                         iny
  2045  a954 c8                         iny
  2046  a955 c050                       cpy #$50
  2047  a957 90f4                       bcc phd3
  2048  a959 60                         rts
  2049                          
  2050  a95a 8a                 phd2:   txa
  2051  a95b 0930                       ora #$30
  2052  a95d c93a                       cmp #$3a
  2053  a95f 9002                       bcc phd1
  2054  a961 e939                       sbc #$39
  2055  a963 910e               phd1:   sta (<zptempp2),y
  2056  a965 c8                         iny
  2057  a966 c8                         iny
  2058  a967 60                         rts
  2059                          
  2060                          ;;         ========================
  2061                          
  2062                          go64:
  2063                          
  2064                          ;; Transfer control to C64 kernel.
  2065                          ;; (This also allows entry to C65 mode, because the
  2066                          ;;  C64-mode kernel on the C65 checks if C65 mode
  2067                          ;;  should be entered.)
  2068                          
  2069                          	;; Prevent utility menu from being launched
  2070  a968 a94c               	lda #$4c
  2071  a96a 8d92ab             	sta utility_menu
  2072                          
  2073                          	;; Prevent flash menu from being launched
  2074  a96d a94c               	lda #$4c
  2075  a96f 8d10a3             	sta first_boot_flag_instruction
  2076                          
  2077                          	;; Warn user if dipswitch 3 is on
  2078  a972 ad9dd6             	lda $d69d
  2079  a975 2904               	and #$04
  2080  a977 f014               	beq l41
  2081  a979 a244                       ldx #<msg_dipswitch3on
  2082  a97b a0b1                       ldy #>msg_dipswitch3on
  2083  a97d 20c8a8                     jsr printmessage
  2084                          l40a:
  2085                          	;; Wait for user to press RUN/STOP to continue booting
  2086  a980 ad10d6             	lda $d610
  2087  a983 c903               	cmp #$03
  2088  a985 f006               	beq l41
  2089  a987 ee20d0             	inc $d020
  2090  a98a 4c80a9             	jmp l40a
  2091                          l41:
  2092                          	;; remove RUN/STOP from key queue
  2093  a98d 8d10d6             	sta $d610
  2094                          	
  2095                                  ;; Check if hold boot switch is set (control-key)
  2096                                  ;;
  2097  a990 ad11d6             	lda buckykey_status
  2098  a993 2914                       and #$14
  2099  a995 f011                       beq l42      ;; no, so continue
  2100                          
  2101                                  ;; yes, display message
  2102                                  ;;
  2103  a997 a21f                       ldx #<msg_releasectrl
  2104  a999 a0b1                       ldy #>msg_releasectrl
  2105  a99b 20c8a8                     jsr printmessage
  2106                          
  2107                          l41a:
  2108                                  ;; check for ALT key to jump to utility menu
  2109  a99e 20eeaa                     jsr utility_menu_check
  2110                          
  2111                                  ;; and otherwise wait until CTRL is released
  2112  a9a1 ad11d6                     lda buckykey_status
  2113  a9a4 2904                       and #$04
  2114  a9a6 d0f6                       bne l41a
  2115                          l42:
  2116                                  ;; unmap sector buffer so C64 can see CIAs
  2117                                  ;;
  2118  a9a8 a982                       lda #$82
  2119  a9aa 8d80d6                     sta sd_ctrl
  2120                          
  2121                                  ;; copy routine to stack to switch to
  2122                                  ;; C64 memory map and enter via reset
  2123                                  ;; vector.
  2124                          
  2125                                  ;; erase hyppo ROM copy from RAM
  2126                                  ;; (well, at least enough so that BASIC doesn't get upset)
  2127                                  ;; XXX - use DMA
  2128                                  ;;
  2129  a9ad a200                       ldx #$00
  2130  a9af 8a                         txa
  2131  a9b0 9d0008             g61:    sta $0800,x
  2132  a9b3 e8                         inx
  2133  a9b4 d0fa                       bne g61
  2134                          
  2135  a9b6 a928                       lda #<40
  2136  a9b8 8d58d0                     sta $d058
  2137  a9bb a900                       lda #>40
  2138  a9bd 8d59d0                     sta $d059
  2139                          
  2140                                  ;; write protect ROM RAM
  2141  a9c0 a904                       lda #$04
  2142  a9c2 0c7dd6                     tsb hypervisor_feature_enables
  2143                          
  2144  a9c5 20669d                     jsr task_set_c64_memorymap
  2145  a9c8 20db9d                     jsr task_set_pc_to_reset_vector
  2146  a9cb 20ff9d                     jsr task_dummy_nmi_vector
  2147                          
  2148                                  ;; This must happen last, so that the ultimax cartridge
  2149                                  ;; reset vector is used, instead of the one in the loaded ROM
  2150  a9ce 20fda9                     jsr setup_for_ultimax_cartridge
  2151                          
  2152                                  ;; Apply RESET to cartridge for a little while so that cartridges
  2153                                  ;; with capacitors tied to EXROM or GAME are visible.
  2154                                  ;; Do this last, because some cartridges remain visible for as little
  2155                                  ;; as 512 usec.
  2156  a9d1 20d7a9                     jsr reset_cartridge
  2157                          
  2158                          go64_exit_hypervisor:	
  2159                                  ;; exit from hypervisor to start machine
  2160  a9d4 8d7fd6                     sta hypervisor_enterexit_trigger
  2161                          

; ******** Source: ultimax.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          reset_cartridge:
     6  a9d7 a300                       ldz #$00
     7  a9d9 a900                       lda #<$0000
     8  a9db 8d10bf                     sta zptempv32+0
     9  a9de 8d11bf                     sta zptempv32+1
    10  a9e1 a901                       lda #<$0701
    11  a9e3 8d12bf                     sta zptempv32+2
    12  a9e6 a907                       lda #>$0701
    13  a9e8 8d13bf                     sta zptempv32+3
    14  a9eb a920                       lda #$20
    15  a9ed ea9210                     sta [<zptempv32],z
    16  a9f0 a000                       ldy #$00
    17                          charge_delay:
    18  a9f2 1b                         inz
    19  a9f3 d0fd                       bne charge_delay
    20  a9f5 c8                         iny
    21  a9f6 d0fa                       bne charge_delay
    22  a9f8 6b                         tza
    23  a9f9 ea9210                     sta [<zptempv32],z
    24  a9fc 60                         rts
    25                          
    26                          setup_for_ultimax_cartridge:
    27  a9fd ad7ed6                     lda hypervisor_cartridge_flags
    28  aa00 2960                       and #$60
    29  aa02 c940                       cmp #$40
    30  aa04 f001                       beq is_ultimax_cartridge
    31  aa06 60                         rts
    32                          
    33                          is_ultimax_cartridge:
    34                                  ;; It's an ultimax cartridge, so we have a couple of things to
    35                                  ;; handle differently.
    36                                  ;;
    37                                  ;; 1. Read reset vector directly from $FFFx, where it will be
    38                                  ;;    currently visible.
    39                                  ;; 2. Copy $F000-$FFFF to $3xxx, $7xxx, $Bxxx and $Fxxx in 1st
    40                                  ;;    64KB of RAM to simulate the way that a C64 makes the top
    41                                  ;;    4KB of Ultimax mode ROMs visible to the VIC-II at these
    42                                  ;;    locations.
    43                                  ;;
    44                                  ;; This means copying from $701Fxxx to $000{3,7,B,F}xxx, as DMA
    45                                  ;; doesn't see mapped ROMs.
    46                                  ;;
    47                                  ;; (We  use one list 4x with different destination, as it uses
    48                                  ;; less bytes than a chained DMA list with all four.)
    49  aa07 adfcff                     lda reset_vector
    50  aa0a 8d48d6                     sta hypervisor_pcl
    51  aa0d adfdff                     lda reset_vector+1
    52  aa10 8d49d6                     sta hypervisor_pch
    53                          
    54                                  ;; Use DMA to quickly do the copy
    55  aa13 a9aa                       lda #>ultimaxsetup_dmalist
    56  aa15 8d01d7                     sta $d701
    57  aa18 a90f                       lda #$0f
    58  aa1a 8d02d7                     sta $d702 ;; DMA list is $xxFxxxx
    59  aa1d a9ff                       lda #$ff
    60  aa1f 8d04d7                     sta $d704 ;; DMA list address is $FFxxxxx
    61                          
    62                                  ;; Run list 4 times with different destination addresses
    63  aa22 a930                       lda #$30
    64  aa24 a234                       ldx #<ultimaxsetup_dmalist
    65                          ultimax_setup_loop:
    66  aa26 8d40aa                     sta ultimaxsetup_destination+1
    67                          
    68                                  ;; Trigger MEGA65 enhanced DMA
    69  aa29 8e05d7                     stx $d705
    70  aa2c 18                         clc
    71  aa2d 6940                       adc #$40
    72  aa2f c930                       cmp #$30
    73  aa31 d0f3                       bne ultimax_setup_loop
    74                          
    75  aa33 60                         rts
    76                          
    77                          ultimaxsetup_dmalist:
    78                                  ;; MEGA65 Enhanced DMA options
    79  aa34 8070                       !8 $80,$70   ;; copy from $70xxxxx
    80  aa36 8100                       !8 $81,$00   ;; copy to $01xxxxx
    81  aa38 00                         !8 $00       ;; end of options
    82                          
    83                                  ;; F018A dma list
    84  aa39 00                         !8 $00       ;; COPY, no chain
    85  aa3a 0010                       !16 $1000     ;; 4KB
    86                          
    87                                  ;; source address
    88  aa3c 00f0                       !16 $F000     ;; source is $xxxF000
    89  aa3e 01                         !8 $01       ;; source is $xx1xxxx
    90                          
    91                          ultimaxsetup_destination:
    92  aa3f 0030                       !16 $3000     ;; destination is $xxx3000 (gets changed by routine above)
    93  aa41 00                         !8 $00       ;; destination is $xx03000
    94  aa42 0000                       !8 $00,00    ;; Modulo

; ******** Source: src/hyppo/main.asm
  2163                          
  2164                          ;;         ========================
  2165                          
  2166                          ;; BG: the longpeek subroutine does not get called from hyppo,
  2167                          ;;     it gets called only from the hyppo_task file,
  2168                          ;;     so i suggest moving this subroutine to that file.
  2169                          
  2170                          longpeek:
  2171                                  ;; Use DMAgic to read any byte of RAM in 28bit address space.
  2172                                  ;; Value gets read into $BC00 (hyppo_scratchbyte0)
  2173                                  ;; ($FFFBC00 - $FFFBDFF)
  2174                          
  2175                                  ;; Patch DMA list
  2176                                  ;;
  2177  aa44 8e6eaa                     stx longpeekdmalist_src_lsb
  2178  aa47 8c6faa                     sty longpeekdmalist_src_2sb
  2179  aa4a 9c70aa                     stz longpeekdmalist_src_msb
  2180  aa4d 8d67aa                     sta longpeekdmalist_src_mb
  2181                          
  2182                                  ;; Set DMA list address
  2183                                  ;;
  2184  aa50 a9aa                       lda #>longpeekdmalist
  2185  aa52 8d01d7                     sta $d701
  2186  aa55 a90f                       lda #$0f
  2187  aa57 8d02d7                     sta $d702 ;; DMA list address is $xxFxxxx
  2188  aa5a a9ff                       lda #$ff
  2189  aa5c 8d04d7                     sta $d704 ;; DMA list address is $FFxxxxx
  2190                          
  2191                                  ;; set bottom bits of DMA list address and trigger enhanced DMA
  2192                                  ;;
  2193  aa5f a965                       lda #<longpeekdmalist
  2194  aa61 8d05d7                     sta $d705
  2195  aa64 60                         rts
  2196                          
  2197                          longpeekdmalist:
  2198                                  ;; MEGA65 Enhanced DMA options
  2199  aa65 0a                         !8 $0A      ;; Request format is F018A
  2200  aa66 80                         !8 $80
  2201                          longpeekdmalist_src_mb:
  2202  aa67 ff                         !8 $FF
  2203  aa68 81ff                       !8 $81,$FF ;; destination is always $FFxxxxx
  2204  aa6a 00                         !8 $00 ;; end of options marker
  2205                                  ;; F018A format request follows
  2206  aa6b 00                         !8 $00 ;; COPY, no chain
  2207                                  ;; 1 byte
  2208  aa6c 0100                       !16 $0001
  2209                                  ;; source address
  2210                          longpeekdmalist_src_lsb:
  2211  aa6e 00                         !8 $00
  2212                          longpeekdmalist_src_2sb:
  2213  aa6f 00                         !8 $00
  2214                          longpeekdmalist_src_msb:
  2215  aa70 00                         !8 $00
  2216                                  ;; destination address ($xxFBC00)
  2217  aa71 00bc                       !16 hyppo_scratchbyte0
  2218  aa73 0f                         !8 $0F
  2219  aa74 0000                       !8 $00,00 ;; Modulo
  2220                          
  2221                          longpoke:
  2222                                  ;; Use DMAgic to write any byte of RAM in C65 1MB address space.
  2223                                  ;; A = value
  2224                                  ;; X = Address LSB
  2225                                  ;; Y = Address MidB
  2226                                  ;; Z = Address Bank
  2227                          
  2228                                  ;; Patch DMA list
  2229                                  ;;
  2230  aa76 8dabaa                     sta longpokevalue
  2231  aa79 8eaeaa                     stx longpokeaddress+0
  2232  aa7c 8cafaa                     sty longpokeaddress+1
  2233  aa7f 9cb0aa                     stz longpokeaddress+2
  2234  aa82 6b                         tza
  2235  aa83 4a                         lsr
  2236  aa84 4a                         lsr
  2237  aa85 4a                         lsr
  2238  aa86 4a                         lsr
  2239  aa87 8da6aa                     sta longpokedmalist_dest_mb ;; DMAgic destination MB
  2240                                  ;; and enable F108B enhanced mode by default
  2241  aa8a a901                       lda #$01
  2242  aa8c 8d03d7                     sta $d703
  2243                          
  2244                                  ;; Set DMA list address
  2245                                  ;;
  2246  aa8f a9aa                       lda #>longpokedmalist
  2247  aa91 8d01d7                     sta $d701
  2248  aa94 a90f                       lda #$0f
  2249  aa96 8d02d7                     sta $d702 ;; DMA list address is $xxFxxxx
  2250  aa99 a9ff                       lda #$ff
  2251  aa9b 8d04d7                     sta $d704 ;; DMA list address is $FFxxxxx
  2252                          
  2253                                  ;; set bottom bits of DMA list address and trigger enhhanced DMA
  2254                                  ;;
  2255                          
  2256  aa9e a9a4                       lda #<longpokedmalist
  2257  aaa0 8d05d7                     sta $d705
  2258  aaa3 60                         rts
  2259                          
  2260                          longpokedmalist:
  2261                                  ;; MEGA65 Enhanced DMA option list
  2262  aaa4 0a                         !8 $0A      ;; Request format is F018A
  2263  aaa5 81                         !8 $81
  2264                          longpokedmalist_dest_mb:
  2265  aaa6 00                         !8 $00
  2266  aaa7 00                         !8 $00 ;; no more enhanced DMA options
  2267                                  ;; F018A dma list
  2268  aaa8 03                         !8 $03 ;; FILL, no chain
  2269                                  ;; 1 byte
  2270  aaa9 0100                       !16 $0001
  2271                                  ;; source address (LSB = fill value)
  2272                          longpokevalue:
  2273  aaab 00                         !8 $00
  2274  aaac 0000                       !16 $0000
  2275                                  ;; destination address
  2276                          longpokeaddress:
  2277  aaae 0000                       !16 $0000
  2278  aab0 0f                         !8 $0F
  2279  aab1 0000                       !8 $00,00 ;; Modulo
  2280                          
  2281                          
  2282                          ;;         ========================
  2283                          
  2284                          ;; reset memory map to default
  2285                          resetmemmap:
  2286                                  ;; clear memory MAP MB offset register
  2287                                  ;;
  2288  aab3 a900                       lda #$00
  2289  aab5 a20f                       ldx #$0f
  2290  aab7 a000                       ldy #$00   ;; keep hyppo mapped at $8000-$BFFF
  2291  aab9 a33f                       ldz #$3f
  2292                          
  2293  aabb 5c                         map
  2294                          
  2295                                  ;; and clear all mapping
  2296                                  ;;
  2297  aabc aa                         tax
  2298  aabd a000                       ldy #$00   ;; keep hyppo mapped at $8000-$BFFF
  2299  aabf a33f                       ldz #$3f
  2300                          
  2301  aac1 5c                         map
  2302  aac2 ea                         eom
  2303                          
  2304  aac3 60                         rts
  2305                          
  2306                          ;;         ========================
  2307                          
  2308                          enhanced_io:
  2309                          
  2310                                  ;; If C=1, enable enhanced IO bank,
  2311                                  ;;   else, return to C64 standard IO map.
  2312                                  ;;
  2313                          
  2314  aac4 b006                       bcs l1
  2315                                  ;; Return to VIC-II / C64 IO
  2316                                  ;;
  2317  aac6 a900                       lda #$00
  2318  aac8 8d2fd0                     sta viciv_magic
  2319  aacb 60                         rts
  2320                          
  2321                          l1:                ;; Enable VIC-IV / MEGA65 IO
  2322                                  ;;
  2323  aacc a947                       lda #$47
  2324  aace 8d2fd0                     sta viciv_magic
  2325  aad1 a953                       lda #$53
  2326  aad3 8d2fd0                     sta viciv_magic
  2327  aad6 60                         rts
  2328                          
  2329                          
  2330                          ;;         ========================

; ******** Source: keyboard.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          peekkeyboard:
     7                                  ;; We now use hardware-accelerated keyboard reading
     8  aad7 ad10d6                     lda ascii_key_in
     9  aada c900                       cmp #$00
    10  aadc f002                       beq nokey
    11  aade 18                         clc
    12  aadf 60                         rts
    13                          nokey:  ;; no key currently down, so set carry and return
    14  aae0 38                         sec
    15  aae1 60                         rts
    16                          
    17                          scankeyboard:
    18  aae2 20d7aa                     jsr peekkeyboard
    19  aae5 c900                       cmp #$00
    20  aae7 f0f7                       beq nokey
    21                                  ;; clear key from buffer
    22  aae9 8d10d6             yeskey: sta ascii_key_in
    23  aaec 18                         clc
    24  aaed 60                         rts

; ******** Source: src/hyppo/main.asm
  2332                          
  2333                          utility_menu_check:
  2334  aaee ad11d6                     lda buckykey_status
  2335  aaf1 c920               	cmp #$20
  2336  aaf3 f00c               	beq @startFlashMenu	
  2337  aaf5 c903                       cmp #$03
  2338  aaf7 f005                       beq @startUtilMenu
  2339  aaf9 2910                       and #$10
  2340  aafb d001                       bne @startUtilMenu
  2341                          @menuCheckDone:
  2342  aafd 60                         rts
  2343                          @startUtilMenu:
  2344  aafe 4c92ab                     jmp utility_menu
  2345                          @startFlashMenu:
  2346                          	;; ... but only if available
  2347  ab01 ad10a3             	lda first_boot_flag_instruction
  2348  ab04 c94c               	cmp #$4c
  2349  ab06 f003               	beq @flashMenuNoAvail
  2350  ab08 4c27a3             	jmp launch_flash_menu
  2351                          @flashMenuNoAvail:
  2352  ab0b 4c75a3             	jmp noflash_menu
  2353                          
  2354                          keyboardread:
  2355                          
  2356                          ;; Check for keyboard activity, and change which ROM we intend to read
  2357                          ;; based on that, i.e., holding any key down during boot will load MEGA65<that character>.ROM instead of MEGA65.ROM
  2358                          
  2359  ab0e 20eeaa                     jsr utility_menu_check
  2360                                  
  2361  ab11 a201                       ldx #$01
  2362  ab13 ad29d6                     lda $d629
  2363  ab16 2940                       and #$40
  2364  ab18 f002                       beq @startscan
  2365  ab1a a2ff                       ldx #$ff    ;; for nexys-range of boards, repeat check for keyboard input in a short loop
  2366                          
  2367                          @startscan:
  2368  ab1c 20e2aa                     jsr scankeyboard
  2369  ab1f 9006                       bcc @checkkey
  2370                                  
  2371  ab21 ca                         dex     ;; no key pressed yet
  2372  ab22 d0f8                       bne @startscan
  2373  ab24 4c36ab                     jmp kr2  ;; no key was pressed, despite looping for a while to wait for it
  2374                                  
  2375                          @checkkey:
  2376  ab27 c920                       cmp #$20
  2377  ab29 d003                       bne @notUtilMenu
  2378  ab2b 4c92ab                     jmp utility_menu
  2379                          @notUtilMenu:
  2380  ab2e c930                       cmp #$30
  2381  ab30 9004                       bcc kr2
  2382  ab32 c939                       cmp #$39
  2383  ab34 9002                       bcc kr1
  2384  ab36 a920               kr2:        lda #$20 ;; default to space
  2385                          kr1:
  2386                                  ;; put character into 6th byte position of ROM file name.
  2387                                  ;; so no key looks for MEGA65.ROM, where as 0-9 will look
  2388                                  ;; for MEGA65x.ROM, where x is the number.
  2389  ab38 a206                       ldx #6
  2390  ab3a c920                       cmp #$20
  2391  ab3c f004                       beq default_rom
  2392  ab3e 9dcbb2                     sta txt_MEGA65ROM,x
  2393  ab41 e8                         inx
  2394                          default_rom:
  2395  ab42 a92e                       lda #'.'
  2396  ab44 9dcbb2                     sta txt_MEGA65ROM,x
  2397  ab47 e8                         inx
  2398  ab48 a952                       lda #'R'
  2399  ab4a 9dcbb2                     sta txt_MEGA65ROM,x
  2400  ab4d e8                         inx
  2401  ab4e a94f                       lda #'O'
  2402  ab50 9dcbb2                     sta txt_MEGA65ROM,x
  2403  ab53 e8                         inx
  2404  ab54 a94d                       lda #'M'
  2405  ab56 9dcbb2                     sta txt_MEGA65ROM,x
  2406  ab59 e8                         inx
  2407  ab5a a900                       lda #0
  2408  ab5c 9dcbb2                     sta txt_MEGA65ROM,x
  2409                          
  2410  ab5f 60                         rts
  2411                          
  2412                          ;;         ========================
  2413                          
  2414                          hypervisor_nmi:
  2415                          hypervisor_irq:
  2416                                  ;; Default interrupt handlers for hypervisor: for now just mask the
  2417                                  ;; interrupt source.  Later we can have raster splits in the boot
  2418                                  ;; display if we so choose.
  2419  ab60 78                         sei
  2420  ab61 40                         rti
  2421                          
  2422                          hypervisor_setup_copy_region:
  2423                                  ;; Hypervisor copy region sit entirely within the first 32KB of
  2424                                  ;; mapped address space. Since we allow a 256 byte copy region,
  2425                                  ;; we limit the start address to the range $0000-$7EFF
  2426                                  ;; XXX - We should also return an error if there is an IO
  2427                                  ;; region mapped there, so that the hypervisor can't be tricked
  2428                                  ;; into doing privileged IO operations as part of the copy-back
  2429                          
  2430  ab62 ad42d6                     lda hypervisor_y
  2431  ab65 300e                       bmi hscr1
  2432  ab67 c97f                       cmp #$7f
  2433  ab69 f00a                       beq hscr1
  2434  ab6b 8d07bf                     sta hypervisor_userspace_copy_vector +1
  2435  ab6e a900                       lda #$00
  2436  ab70 8d06bf                     sta hypervisor_userspace_copy_vector +0
  2437                          
  2438                                  +Checkpoint "hypervisor_setup_copy_region <success>"
  2439                          
  2440  ab73 38                         sec
  2441  ab74 60                         rts
  2442                          
  2443                          hscr1:
  2444                                  +Checkpoint "hypervisor_setup_copy_region <failure>"
  2445                          
  2446  ab75 a910                       lda #dos_errorcode_invalid_address
  2447  ab77 4c6e92                     jmp dos_return_error
  2448                          
  2449                          ;;         ========================
  2450                          
  2451                          !if DEBUG_HYPPO {
  2452                          
  2453                          checkpoint:
  2454                          
  2455                                  ;; Routine to record the progress of code through the hypervisor for
  2456                                  ;; debugging problems in the hypervisor.
  2457                                  ;; If the JSR checkpoint is followed by $00, then a text string describing the
  2458                                  ;; checkpoint is inserted into the checkpoint log.
  2459                                  ;; Checkpoint data is recorded in the 2nd 16KB of colour RAM.
  2460                          
  2461                                  ;; Save all registers and CPU flags
  2462                                  sta checkpoint_a
  2463                                  stx checkpoint_x
  2464                                  sty checkpoint_y
  2465                                  stz checkpoint_z
  2466                                  php
  2467                                  pla
  2468                                  sta checkpoint_p
  2469                          
  2470                                  ;; pull PC return address from stack
  2471                                  ;; (JSR pushes return_address-1, so add one)
  2472                                  pla
  2473                                  clc
  2474                                  adc #$01
  2475                                  sta checkpoint_pcl
  2476                                  pla
  2477                                  adc #$00
  2478                                  sta checkpoint_pch
  2479                          
  2480                                  ;; Only do checkpoints visibly if shift held during boot
  2481                                  lda buckykey_status
  2482                                  and #$03
  2483                                  beq cp9
  2484                          
  2485                                  ;; Write checkpoint byte values out as hex into message template
  2486                                  ldx checkpoint_a
  2487                                  jsr checkpoint_bytetohex
  2488                                  sty msg_checkpoint_a+0
  2489                                  stx msg_checkpoint_a+1
  2490                          
  2491                                  ldx checkpoint_x
  2492                                  jsr checkpoint_bytetohex
  2493                                  sty msg_checkpoint_x+0
  2494                                  stx msg_checkpoint_x+1
  2495                          
  2496                                  ldx checkpoint_y
  2497                                  jsr checkpoint_bytetohex
  2498                                  sty msg_checkpoint_y+0
  2499                                  stx msg_checkpoint_y+1
  2500                          
  2501                                  ldx checkpoint_z
  2502                                  jsr checkpoint_bytetohex
  2503                                  sty msg_checkpoint_z+0
  2504                                  stx msg_checkpoint_z+1
  2505                          
  2506                                  ldx checkpoint_p
  2507                                  jsr checkpoint_bytetohex
  2508                                  sty msg_checkpoint_p+0
  2509                                  stx msg_checkpoint_p+1
  2510                          
  2511                                  ldx checkpoint_pch
  2512                                  jsr checkpoint_bytetohex
  2513                                  sty msg_checkpoint_pc+0
  2514                                  stx msg_checkpoint_pc+1
  2515                          
  2516                                  ldx checkpoint_pcl
  2517                                  jsr checkpoint_bytetohex
  2518                                  sty msg_checkpoint_pc+2
  2519                                  stx msg_checkpoint_pc+3
  2520                          
  2521                                  ;; Clear out checkpoint message
  2522                                  ldx #59
  2523                                  lda #$20
  2524                          cp4:    sta msg_checkpointmsg,x
  2525                                  dex
  2526                                  bpl cp4
  2527                          cp9:
  2528                                  ;; Read next byte following the return address to see if it is $00,
  2529                                  ;; if so, then also store the $00-terminated text message that follows.
  2530                                  ;; e.g.:
  2531                                  ;;
  2532                                  ;; jsr checkpoint
  2533                                  ;; !8 0,"OPEN DIRECTORY",0
  2534                                  ;;
  2535                                  ;; to record a checkpoint with the string "OPEN DIRECTORY"
  2536                          
  2537                                  ldy #$00
  2538                                  lda (<checkpoint_pcl),y
  2539                          
  2540                                  bne nocheckpointmessage
  2541                          
  2542                                  ;; Copy null-terminated checkpoint string
  2543                                  ldx #$00
  2544                                  iny
  2545                          cp3:    lda (<checkpoint_pcl),y
  2546                                  beq endofcheckpointmessage
  2547                                  sta msg_checkpointmsg,x
  2548                                  inx
  2549                                  iny
  2550                                  cpy #60
  2551                                  bne cp3
  2552                          
  2553                                  ;; flush out any excess bytes at end of message
  2554                          cp44:   lda (<checkpoint_pcl),y
  2555                                  beq endofcheckpointmessage
  2556                                  iny
  2557                                  bra cp44
  2558                          
  2559                          endofcheckpointmessage:
  2560                                  ;; Skip $00 at end of message
  2561                                  iny
  2562                          
  2563                          nocheckpointmessage:
  2564                          
  2565                                  ;; Advance return address following any checkpoint message
  2566                                  tya
  2567                                  clc
  2568                                  adc checkpoint_pcl
  2569                                  sta checkpoint_pcl
  2570                                  lda checkpoint_pch
  2571                                  adc #$00
  2572                                  sta checkpoint_pch
  2573                          
  2574                                  ;; Only do checkpoints visibly if shift key held
  2575                                  lda buckykey_status
  2576                                  and #$03
  2577                                  beq checkpoint_return
  2578                          
  2579                                  ;; output checkpoint message to serial monitor
  2580                                  ldx #0
  2581                                  ;; do not adjust x-reg until label "checkpoint_return"
  2582                          cp5:
  2583                                  ;; wait for uart to be not busy
  2584                                  lda hypervisor_write_char_to_serial_monitor        ;; LSB is busy status
  2585                                  bne cp5                ;; branch if busy (LSB=1)
  2586                          
  2587                                  ;; uart is not busy, so write the char
  2588                                  lda msg_checkpoint,x
  2589                                  sta hypervisor_write_char_to_serial_monitor
  2590                                  inx
  2591                          
  2592                                  cmp #10                ;; compare A-reg with "LineFeed"
  2593                                  bne cp5
  2594                          
  2595                          checkpoint_return:
  2596                                  ;; restore registers
  2597                                  lda checkpoint_p
  2598                                  php
  2599                                  lda checkpoint_a
  2600                                  ldx checkpoint_x
  2601                                  ldy checkpoint_y
  2602                                  ldz checkpoint_z
  2603                                  plp
  2604                          
  2605                                  ;; return by jumping to the
  2606                                  jmp (checkpoint_pcl)
  2607                          
  2608                          ;;         ========================
  2609                          
  2610                          checkpoint_bytetohex:
  2611                          
  2612                                  ;; BG: this is a helper function to convert a HEX-byte to
  2613                                  ;;     its equivalent two-byte char representation
  2614                                  ;;
  2615                                  ;;     input ".X", containing a HEX-byte to convert
  2616                                  ;;   outputs ".X" & ".Y", Y is MSB, X is LSB, print YX
  2617                                  txa
  2618                                  and #$f0
  2619                                  lsr
  2620                                  lsr
  2621                                  lsr
  2622                                  lsr
  2623                                  jsr checkpoint_nybltohex
  2624                                  tay
  2625                                  txa
  2626                                  and #$0f
  2627                                  jsr checkpoint_nybltohex
  2628                                  tax
  2629                                  rts
  2630                          
  2631                          ;;         ========================
  2632                          
  2633                          checkpoint_nybltohex:
  2634                          
  2635                                  and #$0f
  2636                                  ora #$30
  2637                                  cmp #$3a
  2638                                  bcs cpnth1
  2639                                  rts
  2640                          
  2641                          cpnth1: adc #$06
  2642                                  rts
  2643                          
  2644                          } ;; !if DEBUG_HYPPO
  2645                          
  2646                          
  2647                          ;;         ========================
  2648                          ;;       Scan the 32KB colour RAM looking for pre-loaded utilities.
  2649                          ;;       Offer for the user to be able to launch one of them
  2650                          
  2651                          	;; Tell user what to do if they can't access the utility menu
  2652                          noutility_menu:
  2653  ab7a a2dc                       ldx #<msg_noutilitymenu
  2654  ab7c a0ad                       ldy #>msg_noutilitymenu
  2655  ab7e 20c8a8                     jsr printmessage
  2656  ab81 ee20d0             	inc $d020
  2657                          num1:
  2658  ab84 4c84ab             	jmp num1
  2659                          
  2660                          safe_video_mode:
  2661                          	;; No digital audio, just pure DVI
  2662  ab87 a900               	lda #$00
  2663  ab89 8d1ad6             	sta $d61a
  2664                          	;; NTSC
  2665  ab8c a980               	lda #$80
  2666  ab8e 8d6fd0             	sta $d06f
  2667  ab91 60                 	rts
  2668                          	
  2669                          utility_menu:
  2670                          	;; Gets self-modified to prevent entering utility menu except on first boot
  2671  ab92 2c7aab             	bit noutility_menu
  2672                          
  2673                          	;; Disable digital audio when utility menu
  2674  ab95 2087ab             	jsr safe_video_mode
  2675                          	
  2676                                  ;; Display GIT commit again, so that it's easy to check commit of a build
  2677  ab98 a292                       ldx #<msg_gitcommit
  2678  ab9a a0b2                       ldy #>msg_gitcommit
  2679  ab9c 20c8a8                     jsr printmessage
  2680                          
  2681                          	;; Display utility menu message
  2682  ab9f a2c3               	ldx #<msg_utilitymenu
  2683  aba1 a0ad                       ldy #>msg_utilitymenu
  2684  aba3 20c8a8                     jsr printmessage
  2685                          
  2686                                  ;; First utility will be number 1
  2687  aba6 a930                       lda #$30
  2688  aba8 8d08bf                     sta zptempv
  2689                          
  2690  abab 20a7ad                     jsr utillist_rewind
  2691                          
  2692                          um1:
  2693  abae 206fad                     jsr utillist_validity_check
  2694  abb1 9030                       bcc utility_end_of_list
  2695                          	
  2696                                  ;; Display utility and assign number
  2697  abb3 a027                       ldy #39
  2698  abb5 a920                       lda #$20
  2699  abb7 9936ad             um2:    sta msg_utility_item,y
  2700  abba 88                         dey
  2701  abbb c002                       cpy #2
  2702  abbd d0f8                       bne um2
  2703  abbf c8                         iny
  2704  abc0 ee08bf                     inc zptempv
  2705  abc3 ad08bf                     lda zptempv
  2706  abc6 8d36ad                     sta msg_utility_item
  2707  abc9 a304                       ldz #4
  2708  abcb eab210             um4:    lda [<zptempv32],z
  2709  abce 9936ad                     sta msg_utility_item,y
  2710  abd1 f004                       beq um3
  2711  abd3 c8                         iny
  2712  abd4 1b                         inz
  2713  abd5 80f4                       bra um4
  2714  abd7 a236               um3:    ldx #<msg_utility_item
  2715  abd9 a0ad                       ldy #>msg_utility_item
  2716  abdb 20c8a8                     jsr printmessage
  2717                          
  2718  abde 205ead                     jsr utillist_next
  2719                          
  2720  abe1 80cb                       bra um1
  2721                          
  2722                          
  2723                          utility_end_of_list:
  2724                                  ;; XXX Get input from user (accept only numbers 1 - 9)
  2725  abe3 20e2aa                     jsr scankeyboard
  2726  abe6 c9ff                       cmp #$ff
  2727  abe8 f0f9                       beq utility_end_of_list
  2728  abea c931                       cmp #$31
  2729  abec 90f5                       bcc utility_end_of_list
  2730  abee c939                       cmp #$39
  2731  abf0 b0f1                       bcs utility_end_of_list
  2732                          
  2733                                  ;; XXX Based on input, find that utility
  2734  abf2 290f                       and #$f
  2735  abf4 aa                         tax
  2736  abf5 ca                         dex ;; input is 1-9, so subtract one for list beginning at 0
  2737  abf6 20a7ad                     jsr utillist_rewind
  2738  abf9 206fad             ueol2:  jsr utillist_validity_check
  2739                                  ;; Select again if first choice invalid
  2740  abfc 90e5                       bcc utility_end_of_list
  2741  abfe ca                         dex
  2742  abff 3005                       bmi ueol1
  2743  ac01 205ead                     jsr utillist_next
  2744  ac04 80f3                       bra ueol2
  2745                          ueol1:
  2746                          
  2747  ac06 ee21d0                     inc $d021
  2748                          
  2749                                  ;; XXX - Set hardware protection bits based on utility definition
  2750                                  ;;       (and check that utility memory has not been modified. If modified.
  2751                                  ;;        give an error instead of giving privileges, so that there is no
  2752                                  ;;        privilege escalation vulnerability here.)
  2753                                  ;; XXX - In fact, if the utility memory has been modified, we shouldn't even
  2754                                  ;;       offer the menu at all perhaps?
  2755                          
  2756                                  ;; Load selected utility into memory
  2757                                  ;; length @ offset 36
  2758  ac09 a324                       ldz #36
  2759  ac0b eab210                     lda [<zptempv32],z
  2760  ac0e 8d2cad                     sta utility_dmalist_length+0
  2761  ac11 1b                         inz
  2762  ac12 eab210                     lda [<zptempv32],z
  2763  ac15 8d2dad                     sta utility_dmalist_length+1
  2764  ac18 a510                       lda <zptempv32+0
  2765  ac1a 18                         clc
  2766  ac1b 692c                       adc #44 ;; length of header structure
  2767  ac1d 8d2ead                     sta utility_dmalist_srcaddr+0
  2768  ac20 a511                       lda <zptempv32+1
  2769  ac22 6900                       adc #0
  2770  ac24 8d2fad                     sta utility_dmalist_srcaddr+1
  2771                          
  2772                          	;; We have to call this before initialising OpenROM
  2773  ac27 2090ac             	jsr setup_for_openrom
  2774                          	
  2775                                  ;; load address is always $07FF (to skip $0801 header)
  2776                                  ;; start @ zptempv32 + 44
  2777                                  ;; DMA list is from Hypervisor ROM, so DMA list address MB also = $FF
  2778  ac2a a9ff                       lda #$ff
  2779  ac2c 8d02d7                     sta $d702
  2780  ac2f 8d04d7                     sta $d704
  2781  ac32 a9ad                       lda #>utility_dmalist
  2782  ac34 8d01d7                     sta $d701
  2783  ac37 a925                       lda #<utility_dmalist
  2784  ac39 8d05d7                     sta $d705       ;; Trigger enhanced DMA
  2785                          
  2786                                  ;; clear 16-bit char mode
  2787  ac3c a905                       lda #$05        ;; 0000 0101
  2788  ac3e 1c54d0                     trb $d054       ;; VIC-IV Control Register C
  2789                          
  2790                                  ;; and 40 bytes (40 8-bit characters) per row.
  2791  ac41 a928                       lda #<40
  2792  ac43 8d58d0                     sta $d058
  2793  ac46 a900                       lda #>40
  2794  ac48 8d59d0                     sta $d059
  2795                          
  2796                                  ;; screen at $0800 for debug
  2797  ac4b a925                       lda #$25
  2798  ac4d 8d18d0                     sta $d018
  2799                          
  2800                                  ;; Exit hypervisor, with PC set to entry point of utility
  2801  ac50 a326                       ldz #38
  2802  ac52 eab210                     lda [<zptempv32],z
  2803  ac55 8d48d6                     sta hypervisor_pcl
  2804  ac58 1b                         inz
  2805  ac59 eab210                     lda [<zptempv32],z
  2806  ac5c 8d49d6                     sta hypervisor_pch
  2807                          
  2808  ac5f 20669d                     jsr task_set_c64_memorymap
  2809  ac62 a93f                       lda #$3f
  2810  ac64 8d50d6                     sta hypervisor_cpuport00
  2811  ac67 a936                       lda #$36 ;; IO + Kernel ROM @ $E000 (will be OpenROM KERNAL)
  2812  ac69 8d51d6                     sta hypervisor_cpuport01
  2813                          
  2814                                  ;; Next instruction exits hypervisor to user mode
  2815  ac6c 8d7fd6                     sta hypervisor_enterexit_trigger
  2816                          
  2817                          flash_menu:
  2818                          
  2819                          	;; Run the flash menu which is pre-loaded into memory on first boot
  2820                          	;; (in the FPGA BRAM).
  2821                          	;; Also DMA copy our current screen safely somewhere for later restoration	
  2822                          
  2823  ac6f a9ff                       lda #$ff
  2824  ac71 8d02d7                     sta $d702
  2825                                  ;; lda #$ff
  2826  ac74 8d04d7                     sta $d704  ;; dma list is in top MB of address space
  2827  ac77 a9ac                       lda #>flashmenu_dmalist
  2828  ac79 8d01d7                     sta $d701
  2829                                  ;; Trigger enhanced DMA
  2830  ac7c a9d5                       lda #<flashmenu_dmalist
  2831  ac7e 8d05d7                     sta $d705
  2832                          
  2833                          	;; FALL THROUGH
  2834                          run_util_in_hypervisor_context:	
  2835                          	;; XXX Move Stack and ZP to normal places, before letting C64 KERNAL loose on
  2836                          	;; Hypervisor memory map!
  2837  ac81 a900               	lda #$00
  2838  ac83 5b                 	!8 $5B ;; tab
  2839  ac84 a001               	ldy #$01
  2840  ac86 2b                 	!8 $2B ;; tys
  2841                          		
  2842  ac87 2090ac             	jsr setup_for_openrom
  2843                          	;; XXX Work around bug in OpenROMs that erases our banner palette when we do this
  2844                          	;; by putting the palette back immediately.
  2845  ac8a 2082a8                     jsr setbannerpalette
  2846                          
  2847                          	;; Actually launch freeze menu
  2848  ac8d 4c0d08             	jmp $080d
  2849                          	
  2850                          setup_for_openrom:
  2851                          	
  2852                          	;; Bank in KERNAL ROM space so megaflash can run
  2853                          	;; Writing to $01 when ZP is relocated is a bit tricky, as
  2854                          	;; we have to mess about with the Base Register, or force
  2855                          	;; the assembler to do an absolute write.
  2856  ac90 a937               	lda #$37
  2857  ac92 8d0100             	!8 $8d,$01,$00 ;; ABS STA $0001
  2858                          
  2859                          	;; We should also reset video mode to normal
  2860  ac95 a997               	lda #$97
  2861  ac97 1c54d0             	trb $d054
  2862                          
  2863                          	;; Clear memory map at $4000-5FFF
  2864                          	;; (Why on earth do we even map some of the HyperRAM there, anyway???)
  2865  ac9a a900               	lda #0
  2866  ac9c aa                 	tax
  2867  ac9d a8                 	tay
  2868  ac9e a33f               	ldz #$3f
  2869  aca0 5c                 	map
  2870  aca1 ea                 	eom
  2871                          	;; And set MB low to $00, so that OpenROM doesn't jump into lala land
  2872  aca2 a900               	lda #0
  2873  aca4 a20f               	ldx #$0f
  2874  aca6 5c                 	map
  2875  aca7 ea                 	eom	
  2876                          
  2877                          	;; Tell KERNAL screen is at $0400
  2878  aca8 a904               	lda #>$0400
  2879  acaa 8d8802             	sta $0288
  2880                          
  2881  acad adf9ff             	lda $fff9
  2882  acb0 c9ff               	cmp #$ff
  2883  acb2 f003               	beq @notOpenROM
  2884                          	;; OpenROMs setup (XXX Won't work with Commodore C65 ROMs!)
  2885  acb4 22f8ff             	jsr ($fff8)
  2886                          @notOpenROM:
  2887                          	;; make sure not in quote mode etc
  2888  acb7 a900               	lda #$00
  2889  acb9 85d8               	sta $d8 ;; number of insertions outstanding = 0
  2890  acbb 850f               	sta $0f ;; clear quote mode
  2891                          
  2892                          	;; Clear common interrupt sources
  2893                          
  2894                          	;; CIAs
  2895                          ;;	lda #$ff
  2896                          ;;	sta $dc0d
  2897                          ;;	sta $dd0d
  2898                          ;;	lda $dc0d
  2899                          ;;	lda $dd0d
  2900                          
  2901                          	;; VIC-IV
  2902                          ;;	dec $d019
  2903                          ;;	lda #$00
  2904                          ;;	sta $d01a
  2905                          
  2906                          	;; Ethernet
  2907                          ;;	lda #$00
  2908                          ;;	sta $d6e1
  2909                          
  2910                          	;; C65 UART
  2911                          	;; XXX Actually it can't generate interrupts yet, so nothing to do :)
  2912                          
  2913                          	;; Finally, clear any pending interrupts by using MAP instruction
  2914                          ;;	tax
  2915                          ;;	tay
  2916                          ;;	taz
  2917                          ;;	map
  2918                          ;;	lda #0    ;; to give time to effect clearing irq_pending in CPU
  2919                          ;;	eom
  2920                          	
  2921                          	;; And ignore any queued NMI (these don't get cleared by the MAP trick)
  2922                          
  2923                          	;;  Clear pending NMI flag
  2924  acbd ad7dd6                     lda hypervisor_feature_enables
  2925  acc0 297f               	and #$7f
  2926  acc2 8d7dd6                     sta hypervisor_feature_enables
  2927                          
  2928                          	;; Set safety-net NMI handler
  2929  acc5 a940               	lda #$40
  2930  acc7 8d2004             	sta $0420
  2931  acca a920               	lda #<$0420
  2932  accc 8d1803             	sta $0318
  2933  accf a904               	lda #>$0420
  2934  acd1 8d1903             	sta $0319	
  2935  acd4 60                 	rts
  2936                          
  2937                          flashmenu_dmalist:
  2938                                  ;; copy $50000-$577FF to $00007FF-$0007FFFF
  2939                          
  2940                                  ;; MEGA65 Enhanced DMA options
  2941  acd5 0a                         !8 $0A      ;; Request format is F018A
  2942  acd6 8000                       !8 $80,$00  ;; Copy from $00xxxxx
  2943  acd8 8100                       !8 $81,$00  ;; Copy to $00xxxxx
  2944                          
  2945                          	;; Copy screen from $0400-$0BFF to $00009000
  2946  acda 00                         !8 $00 ;; no more options
  2947                                  ;; F018A DMA list
  2948  acdb 04                         !8 $04 ;; copy + chained
  2949  acdc 0008                       !16 $0800 ;; size of copy 
  2950  acde 0004                       !16 $0400 ;; starting addr 
  2951  ace0 00                         !8 $00   ;; of bank $0
  2952  ace1 0090                       !16 $9000 ;; destination address is $8000
  2953  ace3 00                         !8 $00   ;; of bank $5
  2954  ace4 0000                       !16 $0000 ;; modulo (unused)
  2955                          
  2956                          	;; Copy program down
  2957  ace6 00                         !8 $00 ;; no more options
  2958                          	;; F018A DMA list
  2959  ace7 00                         !8 $00 ;; copy + not chained request
  2960  ace8 ff77                       !16 $77FF ;; size of copy 
  2961  acea 0000                       !16 $0000 ;; starting addr 
  2962  acec 05                         !8 $05   ;; of bank $5
  2963  aced ff07                       !16 $07FF ;; destination address is $0801 - 2
  2964  acef 00                         !8 $00   ;; of bank $0
  2965  acf0 0000                       !16 $0000 ;; modulo (unused)
  2966                          
  2967                          screenrestore_dmalist:
  2968  acf2 8000                       !8 $80,$00  ;; Copy from $00xxxxx
  2969  acf4 8100                       !8 $81,$00  ;; Copy to $00xxxxx
  2970  acf6 00                         !8 $00 ;; no more options
  2971                                  ;; F018A DMA list
  2972  acf7 00                         !8 $00 ;; copy + last in chain
  2973  acf8 0008                       !16 $0800 ;; size of copy 
  2974  acfa 0090                       !16 $9000 ;; destination address is $0000
  2975  acfc 00                         !8 $00   ;; of bank $0
  2976  acfd 0004                       !16 $0400 ;; starting addr 
  2977  acff 00                         !8 $00   ;; of bank $5
  2978  ad00 0000                       !16 $0000 ;; modulo (unused)
  2979                          
  2980                          scroll_screen:
  2981                          	
  2982  ad02 a9ff                       lda #$ff
  2983  ad04 8d02d7                     sta $d702
  2984  ad07 8d04d7                     sta $d704  ;; dma list is in top MB of address space
  2985                          
  2986                          	;; Don't forget to reset colour RAM also
  2987  ad0a a9ad                       lda #>scrollscreen_dmalist
  2988  ad0c 8d01d7                     sta $d701
  2989                                  ;; set bottom 8 bits of address and trigger DMA.
  2990                                  ;;
  2991  ad0f a915                       lda #<scrollscreen_dmalist
  2992  ad11 8d05d7                     sta $d705
  2993                          
  2994  ad14 60                 	rts
  2995                          	
  2996                          scrollscreen_dmalist:
  2997  ad15 8000                       !8 $80,$00  ;; Copy from $00xxxxx
  2998  ad17 8100                       !8 $81,$00  ;; Copy to $00xxxxx
  2999  ad19 00                         !8 $00 ;; no more options
  3000                                  ;; F018A DMA list
  3001  ad1a 00                         !8 $00 ;; copy + last in chain
  3002  ad1b 0005                       !16 1280 ;; size of copy  ( (17-1) * 40 * 2 )
  3003  ad1d d006                       !16 1744 ;; src address is line 9 of screen
  3004  ad1f 00                         !8 $00   ;; of bank $0
  3005  ad20 8006                       !16 1664 ;; starting addr is line 8 of screen
  3006  ad22 00                         !8 $00   ;; of bank $0
  3007  ad23 0000                       !16 $0000 ;; modulo (unused)
  3008                          	
  3009                          	
  3010                          utility_dmalist:
  3011                                  ;; copy $FF8xxxx-$FF8yyyy to $00007FF-$000xxxx
  3012                          
  3013                                  ;; MEGA65 Enhanced DMA options
  3014  ad25 0a                         !8 $0A      ;; Request format is F018A
  3015  ad26 80ff                       !8 $80,$FF  ;; Copy from $FFxxxxx
  3016  ad28 8100                       !8 $81,$00  ;; Copy to $00xxxxx
  3017  ad2a 00                         !8 $00 ;; no more options
  3018                                  ;; F018A DMA list
  3019  ad2b 00                         !8 $00 ;; copy + last request in chain
  3020                          utility_dmalist_length:
  3021  ad2c ffff                       !16 $FFFF ;; size of copy  (gets overwritten)
  3022                          utility_dmalist_srcaddr:
  3023  ad2e ffff                       !16 $FFFF ;; starting addr (gets overwritten)
  3024  ad30 08                         !8 $08   ;; of bank $8
  3025  ad31 ff07                       !16 $07FF ;; destination address is $0801 - 2
  3026  ad33 00                         !8 $00   ;; of bank $0
  3027  ad34 0000                       !16 $0000 ;; modulo (unused)
  3028                          
  3029                          
  3030                          msg_utility_item:
  3031  ad36 312e203332204348...        !text "1. 32 CHARACTERS OF UTILITY NAME...    "
  3032  ad5d 00                         !8 0
  3033                          
  3034                          utillist_next:
  3035                          
  3036                                  ;; Advance pointer to the next pointer
  3037  ad5e a32a                       ldz #42
  3038  ad60 eab210                     lda [<zptempv32],z
  3039  ad63 da                         phx
  3040  ad64 aa                         tax
  3041  ad65 1b                         inz
  3042  ad66 eab210                     lda [<zptempv32],z
  3043                                  ;; XXX - Make sure it can't point earlier into the colour RAM here
  3044                          
  3045  ad69 8511                       sta <zptempv32+1
  3046  ad6b 8610                       stx <zptempv32
  3047  ad6d fa                         plx
  3048  ad6e 60                         rts
  3049                          
  3050                          utillist_validity_check:
  3051                                  ;; See if this is a valid utility entry
  3052  ad6f a300                       ldz #0
  3053                          
  3054                                  ;; Check for magic value
  3055  ad71 eab210                     lda [<zptempv32],z
  3056  ad74 c94d                       cmp #'M'
  3057  ad76 d02d                       bne ulvc_fail
  3058  ad78 1b                         inz
  3059  ad79 eab210                     lda [<zptempv32],z
  3060  ad7c c936                       cmp #'6'
  3061  ad7e d025                       bne ulvc_fail
  3062  ad80 1b                         inz
  3063  ad81 eab210                     lda [<zptempv32],z
  3064  ad84 c935                       cmp #'5'
  3065  ad86 d01d                       bne ulvc_fail
  3066  ad88 1b                         inz
  3067  ad89 eab210                     lda [<zptempv32],z
  3068  ad8c c955                       cmp #'U'
  3069  ad8e d015                       bne ulvc_fail
  3070                          
  3071                                  ;; Check self address
  3072  ad90 a328                       ldz #40
  3073  ad92 eab210                     lda [<zptempv32],z
  3074  ad95 cd10bf                     cmp zptempv32
  3075  ad98 d00b                       bne ulvc_fail
  3076  ad9a 1b                         inz
  3077  ad9b eab210                     lda [<zptempv32],z
  3078  ad9e cd11bf                     cmp zptempv32+1
  3079  ada1 d002                       bne ulvc_fail
  3080                          
  3081                                  ;; success
  3082  ada3 38                         sec
  3083  ada4 60                         rts
  3084                          
  3085                          ulvc_fail:
  3086  ada5 18                         clc
  3087  ada6 60                         rts
  3088                          
  3089                          utillist_rewind:
  3090                          
  3091                                  ;; Set pointer to first entry in colour RAM ($0850)
  3092  ada7 a950                       lda #<$0850
  3093  ada9 8510                       sta <zptempv32
  3094  adab a908                       lda #>$0850
  3095  adad 8511                       sta <(zptempv32+1)
  3096  adaf a9f8                       lda #<$0FF8
  3097  adb1 8512                       sta <(zptempv32+2)
  3098  adb3 a90f                       lda #>$0FF8
  3099  adb5 8513                       sta <(zptempv32+3)
  3100                          
  3101  adb7 60                         rts
  3102                          
  3103                          serialwrite:
  3104                                  ;; write character to serial port
  3105                          
  3106                          	;; First wait for it to go ready
  3107  adb8 ae7cd6             	ldx hypervisor_write_char_to_serial_monitor
  3108  adbb d0fb               	bne serialwrite
  3109                          	
  3110                                  ;; XXX - Have some kind of permission control on this
  3111                                  ;; XXX - $D67C should not work when matrix mode is enabled at all?
  3112  adbd 8d7cd6                     sta hypervisor_write_char_to_serial_monitor
  3113  adc0 8d7fd6                     sta hypervisor_enterexit_trigger
  3114                          
  3115                          ;;         ========================
  3116                          
  3117                          !if DEBUG_HYPPO {
  3118                          
  3119                          ;; checkpoint message
  3120                          
  3121                          msg_checkpoint:         !text "$"
  3122                          msg_checkpoint_pc:      !text "%%%% A:"
  3123                          msg_checkpoint_a:       !text "%%, X:"
  3124                          msg_checkpoint_x:       !text "%%, Y:"
  3125                          msg_checkpoint_y:       !text "%%, Z:"
  3126                          msg_checkpoint_z:       !text "%%, P:"
  3127                          msg_checkpoint_p:       !text "%% :"
  3128                          msg_checkpointmsg:      !text "                                                             " ;; END_OF_STRING
  3129                                                  !8 13,10  ;; CR/LF
  3130                          
  3131                          }
  3132                          
  3133                          ;;         ========================
  3134                          
  3135                          msg_checkpoint_eom:
  3136                          
  3137                          ;; messages all have to be <=40 bytes long
  3138                          
  3139                          msg_utilitymenu:
  3140  adc3 53454c4543542055...        !text "SELECT UTILITY TO LAUNCH"
  3141  addb 00                         !8 0
  3142                          
  3143                          msg_noutilitymenu:	
  3144  addc 484f4c4420414c54...		        !text "HOLD ALT + POWER CYCLE FOR UTILITY MENU"
  3145  ae03 00                 	                !8 0
  3146                          	
  3147                          msg_noflashmenu:	
  3148  ae04 484f4c44204e4f20...		        !text "HOLD NO SCROLL + POWER CYCLE FOR FLASH"
  3149  ae2a 00                 	                !8 0
  3150                          	
  3151  ae2b 52452d545259494e...msg_retryreadmbr:       !text "RE-TRYING TO READ MBR"
  3152  ae40 00                                         !8 0
  3153  ae41 4d4547413635204d...msg_hyppo:              !text "MEGA65 MEGAOS HYPERVISOR V00.16"
  3154  ae60 00                                         !8 0
  3155  ae61 4e4f205343524f4c...msg_hyppohelpfirst:     !text "NO SCROLL=FLASH, ALT=UTILS, CTRL=HOLD"
  3156  ae86 00                                         !8 0
  3157  ae87 504f574552204f46...msg_hyppohelpnotfirst:  !text "POWER OFF/ON FOR FLASH OR UTIL MENU"
  3158  aeaa 00                                         !8 0
  3159  aeab 524f4d2043484543...msg_romok:              !text "ROM CHECKSUM OK - BOOTING"
  3160  aec4 00                                         !8 0
  3161                          ;; msg_rombad:          !text "ROM CHECKSUM FAIL - LOADING ROMS"
  3162                          ;;                      !8 0
  3163                          ;; msg_charrombad:      !text "COULD NOT LOAD CHARROM.M65"
  3164                          ;;                      !8 0
  3165  aec5 4c4f414445442043...msg_charromloaded:      !text "LOADED CHARROM.M65"
  3166  aed7 00                                         !8 0
  3167  aed8 4c4f41444544204d...msg_megaromloaded:      !text "LOADED MEGA65.ROM"
  3168  aee9 00                                         !8 0
  3169  aeea 4c4f4f4b494e4720...msg_tryingsdcard:       !text "LOOKING FOR SDHC CARD >=4GB..."
  3170  af08 00                                         !8 0
  3171  af09 5344204341524420...msg_foundsdcard:        !text "SD CARD IS NOT SDHC. MUST BE SDHC."
  3172  af2b 00                                         !8 0
  3173  af2c 464f554e4420414e...msg_foundsdhccard:      !text "FOUND AND RESET SDHC CARD"
  3174  af45 00                                         !8 0
  3175  af46 4552524f52205245...msg_sdcarderror:        !text "ERROR READING FROM SD CARD"
  3176  af60 00                                         !8 0
  3177  af61 52452d5245414449...msg_sdredoread:         !text "RE-READING SDCARD"
  3178  af72 00                                         !8 0
  3179  af73 4e4f205344434152...msg_nosdcard:           !text "NO SDCARD, TRYING BUILT-IN ROM"
  3180  af91 00                                         !8 0
  3181  af92 424144204d425220...msg_badformat:          !text "BAD MBR OR DOS BOOT SECTOR."
  3182  afad 00                                         !8 0
  3183  afae 5245414420504152...msg_sdcardfound:        !text "READ PARTITION TABLE FROM SDCARD"
  3184  afce 00                                         !8 0
  3185  afcf 464f554e4420524f...msg_foundromfile:       !text "FOUND ROM FILE. START CLUSTER = $$$$$$$$"
  3186  aff7 00                                         !8 0
  3187  aff8 4449534b2d434f55...msg_diskcount:          !text "DISK-COUNT=$$, DEFAULT-DISK=$$"
  3188  b016 00                                         !8 0
  3189                          ;; msg_diskdata0:       !text "DISK-TABLE:"
  3190                          ;;                      !8 0
  3191                          ;; msg_diskdata:        !text "BB$$:$$.$$.$$.$$.$$.$$.$$.$$"
  3192                          ;;                      !8 0
  3193  b017 4c4f4f4b494e4720...msg_filelengths:        !text "LOOKING FOR $$ BYTES, I SEE $$ BYTES"
  3194  b03b 00                                         !8 0
  3195  b03c 434f554c44204e4f...msg_fileopenerror:      !text "COULD NOT OPEN ROM FILE FOR READING"
  3196  b05f 00                                         !8 0
  3197  b060 52454144494e4720...msg_readingfile:        !text "READING ROM FILE..."
  3198  b073 00                                         !8 0
  3199  b074 524f4d20544f4f20...msg_romfilelongerror:   !text "ROM TOO LONG: (READ $$$$ PAGES)"
  3200  b093 00                                         !8 0
  3201  b094 524f4d20544f4f20...msg_romfileshorterror:  !text "ROM TOO SHORT: (READ $$$$ PAGES)"
  3202  b0b4 00                                         !8 0
  3203  b0b5 43555252454e5420...msg_clusternumber:      !text "CURRENT CLUSTER=$$$$$$$$"
  3204  b0cd 00                                         !8 0
  3205  b0ce 43555252454e5420...msg_sectoraddress:      !text "CURRENT SECTOR= $$$$$$$$"
  3206  b0e6 00                                         !8 0
  3207  b0e7 43414e4e4f54204d...msg_nod81:              !text "CANNOT MOUNT D81 - (ERRNO: $$)"
  3208  b105 00                                         !8 0
  3209  b106 4438312053554343...msg_d81mounted:         !text "D81 SUCCESSFULLY MOUNTED"
  3210  b11e 00                                         !8 0
  3211  b11f 52454c4541534520...msg_releasectrl:        !text "RELEASE CONTROL TO CONTINUE BOOTING."
  3212  b143 00                                         !8 0
  3213  b144 535733204f464620...msg_dipswitch3on:       !text "SW3 OFF OR PRESS RUN/STOP TO CONTINUE."
  3214  b16a 00                                         !8 0
  3215  b16b 434f554c44204e4f...msg_romnotfound:        !text "COULD NOT FIND ROM MEGA65XXROM"
  3216  b189 00                                         !8 0
  3217  b18a 4c4f4144494e4720...msg_foundhickup:        !text "LOADING HICKUP.M65 INTO HYPERVISOR"
  3218  b1ac 00                                         !8 0
  3219  b1ad 434f554c44204e4f...msg_no1541rom:          !text "COULD NOT LOAD 1541ROM.M65"
  3220  b1c7 00                                         !8 0
  3221                          ;; msg_nohickup:        !text "NO HICKUP.M65 TO LOAD (OR BROKEN)"
  3222                          ;;                      !8 0
  3223                          ;; msg_hickuploaded:    !text "HICKUP LOADED TO 00004000 - $$$$$$$$"
  3224                          ;;                      !8 0
  3225  b1c8 52554e4e494e4720...msg_alreadyhicked:      !text "RUNNING HICKED HYPERVISOR"
  3226  b1e1 00                                         !8 0
  3227                          msg_lookingfornextsector:
  3228  b1e2 4c4f4f4b494e4720...                        !text "LOOKING FOR NEXT SECTOR OF FILE"
  3229  b201 00                                         !8 0
  3230  b202 434f554c44204e4f...msg_nologo:             !text "COULD NOT LOAD BANNER.M65 (ERRNO:$$)"
  3231  b226 00                                         !8 0
  3232  b227 434f554c44204e4f...msg_cdrootfailed:       !text "COULD NOT CHDIR TO / (ERRNO:$$)"
  3233  b246 00                                         !8 0
  3234  b247 545259494e472053...msg_tryingcard0:        !text "TRYING SDCARD BUS 0"
  3235  b25a 00                                         !8 0
  3236  b25b 5553494e47205344...msg_usingcard1:         !text "USING SDCARD BUS 1"
  3237  b26d 00                                         !8 0
  3238  b26e 444d414749432052...msg_dmagica:            !text "DMAGIC REV A MODE"
  3239  b27f 00                                         !8 0
  3240  b280 444d414749432052...msg_dmagicb:            !text "DMAGIC REV B MODE"
  3241  b291 00                                         !8 0
  3242                          	
  3243                          ;; Include the GIT Message as a string

; ******** Source: ../version.asm
     1                          msg_gitcommit:
     2  b292 4749543a206d6173...	!text "GIT: master,20220117.14,f7554a8"
     3  b2b1 00                 	!8 0

; ******** Source: src/hyppo/main.asm
  3245                          
  3246  b2b2 00                 msg_blankline:          !8 0
  3247                          
  3248                          ;;         ========================
  3249                                      ;; filename of 1541 ROM
  3250  b2b3 31353431524f4d2e...txt_1541ROM:            !text "1541ROM.M65"
  3251  b2be 00                                         !8 0
  3252                          
  3253                                      ;; filename of character ROM
  3254  b2bf 43484152524f4d2e...txt_CHARROMM65:         !text "CHARROM.M65"
  3255  b2ca 00                                         !8 0
  3256                          
  3257                                      ;; filename of ROM we want to load in FAT directory format
  3258                                      ;; (the two zero bytes are so that we can insert an extra digit after
  3259                                      ;; the 5, when a user presses a key, so that they can choose a
  3260                                      ;; different ROM to load).
  3261                                      ;;
  3262  b2cb 4d45474136352e52...txt_MEGA65ROM:          !text "MEGA65.ROM"
  3263  b2d5 0000                                       !8 0,0
  3264                          
  3265                                      ;; filename of 1581 disk image we mount by default
  3266                                      ;;
  3267  b2d7 4d45474136352e44...txt_MEGA65D81:          !text "MEGA65.D81"
  3268  b2e1 00000000000000                             !8 0,0,0,0,0,0,0
  3269                          
  3270                                      ;; filename of hyppo update file
  3271                                      ;;
  3272  b2e8 4849434b55502e4d...txt_HICKUPM65:          !text "HICKUP.M65"
  3273  b2f2 00                                         !8 0
  3274                          
  3275                                      ;; filename containing boot logo
  3276                                      ;;
  3277  b2f3 42414e4e45522e4d...txt_BOOTLOGOM65:        !text "BANNER.M65"
  3278  b2fd 00                                         !8 0
  3279                          
  3280                                      ;; filename containing freeze menu
  3281  b2fe 465245455a45522e...txt_FREEZER:            !text "FREEZER.M65"
  3282  b309 00                                         !8 0
  3283                          
  3284                                      ;; If this file is present, then machine starts up with video
  3285                                      ;; mode set to NTSC (60Hz), else as PAL (50Hz).
  3286                                      ;; This is to allow us to boot in PAL by default, except for
  3287                                      ;; those who have a monitor that cannot do 50Hz.
  3288  b30a 4e545343           txt_NTSC:               !text "NTSC"
  3289  b30e 00                                         !8 0
  3290                          
  3291                          ;;         ========================
  3292                          
  3293                          !if DEBUG_HYPPO {
  3294                                  !src "debug.asm"
  3295                          }
  3296                          
  3297                          ;;         ========================
  3298                          
  3299                                  ;; Table of available disks.
  3300                                  ;; Include native FAT32 disks, as well as (in the future at least)
  3301                                  ;; mounted .D41, .D71, .D81 and .DHD files using Commodore DOS filesystems.
  3302                                  ;; But for now, we are supporting only FAT32 as the filesystem.
  3303                                  ;; See hyppo_dos.asm for information on how the table is used.
  3304                                  ;; Entries are 32 bytes long, so we can have 6 of them.
  3305                                  ;;
  3306                                  dos_max_disks = 6
  3307                          
  3308                                  ;; .segment DOSDiskTable
  3309                                  * = DOSDiskTable_Start
  3310                          dos_disk_table:
  3311                          
  3312                                  ;; .segment SysPartStructure
  3313                                  * = SysPartStructure_Start
  3314                          
  3315                          syspart_structure:
  3316                          
  3317                          syspart_start_sector:
  3318  bbc0 00000000                   !8 0,0,0,0
  3319                          syspart_size_in_sectors:
  3320  bbc4 00000000                   !8 0,0,0,0
  3321                          syspart_reserved:
  3322  bbc8 0000000000000000           !8 0,0,0,0,0,0,0,0
  3323                          
  3324                          ;; For fast freezing/unfreezing, we have a number of contiguous
  3325                          ;; freeze slots that can each store the state of the machine
  3326                          ;; We note where the area begins, how big it is, how many slots
  3327                          ;; it has, and how many sectors are used at the start of the area
  3328                          ;; to hold a directory with 128 bytes per slot, the contains info
  3329                          ;; about the frozen program.
  3330                          syspart_freeze_area_start:
  3331  bbd0 00000000                   !8 0,0,0,0
  3332                          syspart_freeze_area_size_in_sectors:
  3333  bbd4 00000000                   !8 0,0,0,0
  3334                          syspart_freeze_slot_size_in_sectors:
  3335  bbd8 00000000                   !8 0,0,0,0
  3336                          syspart_freeze_slot_count:
  3337  bbdc 0000                       !8 0,0
  3338                          syspart_freeze_directory_sector_count:
  3339  bbde 0000                       !8 0,0
  3340                          
  3341                                  ;; The first 64 freeze slots are reserved for various purposes
  3342                                 syspart_freeze_slots_reserved  = 64
  3343                                  ;; Freeze slot 0 is used when the hypervisor needs to
  3344                                  ;; temporarily shove all or part of the active process out
  3345                                  ;; the way to do something
  3346                                 freeze_slot_temporary = 0
  3347                          
  3348                                  ;; Freeze slots 1 - 63 are currently reserved
  3349                                  ;; They will likely get used for a service call-stack
  3350                                  ;; among other purposes.
  3351                          
  3352                                  ;; We then have a similar area for system services, which are stored
  3353                                  ;; using much the same representation, but are used as helper
  3354                                  ;; programs.
  3355                          syspart_service_area_start:
  3356  bbe0 00000000                   !8 0,0,0,0
  3357                          syspart_service_area_size_in_bytes:
  3358  bbe4 00000000                   !8 0,0,0,0
  3359                          syspart_service_slot_size_in_bytes:
  3360  bbe8 00000000                   !8 0,0,0,0
  3361                          syspart_service_slot_count:
  3362  bbec 0000                       !8 0,0
  3363                          syspart_service_directory_sector_count:
  3364  bbee 0000                       !8 0,0
  3365                          
  3366                          ;; /*  -------------------------------------------------------------------
  3367                          ;;     Hypervisor DOS work area and scratch pad at $BC00-$BCFF
  3368                          ;;     ---------------------------------------------------------------- */
  3369                          
  3370                                  ;; .segment DOSWorkArea
  3371                                  * = DOSWorkArea_Start
  3372                          
  3373                          hyppo_scratchbyte0:
  3374  bc00 00                         !8 $00
  3375                          
  3376                                  ;; The number of disks we have
  3377                                  ;;
  3378                          dos_disk_count:
  3379  bc01 00                         !8 $00
  3380                          
  3381                                  ;; The default disk
  3382                                  ;;
  3383                          dos_default_disk:
  3384  bc02 00                         !8 $00
  3385                          
  3386                                  ;; The current disk
  3387                                  ;;
  3388                          dos_disk_current_disk:
  3389  bc03 00                         !8 $00
  3390                          
  3391                                  ;; Offset of current disk entry in disk table
  3392                                  ;;
  3393                          dos_disk_table_offset:
  3394  bc04 00                         !8 $00
  3395                          
  3396                                  ;; cluster of current directory of current disk
  3397                                  ;;
  3398                          dos_disk_cwd_cluster:
  3399  bc05 00000000                   !8 0,0,0,0
  3400                          
  3401                          ;;         ========================
  3402                          
  3403                                  ;; Current point in open directory
  3404                                  ;;
  3405                          dos_opendir_cluster:
  3406  bc09 00000000                   !8 0,0,0,0
  3407                          dos_opendir_sector:
  3408  bc0d 00                         !8 0
  3409                          dos_opendir_entry:
  3410  bc0e 00                         !8 0
  3411                          
  3412                          ;;         ========================
  3413                          
  3414                                  ;; WARNING: dos_readdir_read_next_entry uses carnal knowledge about the following
  3415                                  ;;          structure, particularly the length as calculated here:
  3416                                  ;;
  3417                                  dos_dirent_structure_length = dos_dirent_struct_end - dos_dirent_struct_start
  3418                          
  3419                                  ;; Current long filename (max 64 bytes)
  3420                                  ;;
  3421                          dos_dirent_struct_start:	
  3422                          dos_dirent_longfilename:
  3423  bc0f 56656e657a75616c...        !text "Venezualen casaba melon productio" ;; 33-chars
  3424  bc30 6e20737461746973...        !text "n statistics (2012-2015).txt  "    ;; 30-chars
  3425  bc4e 00                         !8 0
  3426                          
  3427                          dos_dirent_longfilename_length:
  3428  bc4f 00                         !8 0
  3429                          
  3430                          dos_dirent_shortfilename:
  3431  bc50 46494c454e414d45...        !text "FILENAME.EXT"
  3432  bc5c 00                         !8 0
  3433                          
  3434                          dos_dirent_cluster:
  3435  bc5d 00000000                   !8 0,0,0,0
  3436                          
  3437                          dos_dirent_length:
  3438  bc61 00000000                   !8 0,0,0,0
  3439                          
  3440                          dos_dirent_type_and_attribs:
  3441  bc65 00                         !8 0
  3442                          dos_dirent_struct_end:	
  3443                          
  3444                          ;;         ========================
  3445                          
  3446                                  ;; Requested file name and length
  3447                                  ;;
  3448                          dos_requested_filename_len:
  3449  bc66 00                         !8 0
  3450                          
  3451                          dos_requested_filename:
  3452  bc67 56656e657a75616c...        !text "Venezualen casaba melon productio"
  3453  bc88 6e20737461746973...        !text "n statistics (2007-2011).txt     "
  3454                          
  3455                          ;;         ========================
  3456                          
  3457                                  ;; Details about current DOS request
  3458                                  ;;
  3459  bca9 0000               dos_sectorsread:                !16 0
  3460  bcab 00000000           dos_bytes_remaining:            !16 0,0
  3461  bcaf 00000000           dos_current_sector:             !16 0,0
  3462  bcb3 00000000           dos_current_cluster:            !16 0,0
  3463  bcb7 00                 dos_current_sector_in_cluster:  !8 0
  3464                          
  3465                          ;; Current file descriptors
  3466                          ;; Each descriptor has:
  3467                          ;;   disk id : 1 byte ($00-$07 = file open, $FF = file closed)
  3468                          ;;   access mode : 1 byte ($00 = read only)
  3469                          ;;   start cluster : 4 bytes
  3470                          ;;   current cluster : 4 bytes
  3471                          ;;   current sector in cluster : 1 byte
  3472                          ;;   offset in sector: 2 bytes
  3473                          ;;   file offset / $100 : 3 bytes
  3474                          ;;
  3475                                  dos_filedescriptor_max = 4
  3476                                  dos_filedescriptor_offset_diskid = 0
  3477                                  dos_filedescriptor_offset_mode = 1
  3478                                  dos_filedescriptor_offset_startcluster = 2
  3479                                  dos_filedescriptor_offset_currentcluster = 6
  3480                          ;;
  3481                          ;; These last three fields must be contiguous, as dos_open_current_file
  3482                          ;; relies on it.
  3483                          ;;
  3484                                  dos_filedescriptor_offset_sectorincluster = 10
  3485                                  dos_filedescriptor_offset_offsetinsector = 11
  3486                                  dos_filedescriptor_offset_fileoffset = 13
  3487                          
  3488                          dos_file_descriptors:
  3489  bcb8 ff00000000000000...        !8 $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        ;; each is 16 bytes
  3490  bcc8 ff00000000000000...        !8 $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  3491  bcd8 ff00000000000000...        !8 $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  3492  bce8 ff00000000000000...        !8 $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  3493                          
  3494                              ;; The current file descriptor
  3495                              ;;
  3496                          dos_current_file_descriptor:
  3497  bcf8 00                         !8 0
  3498                          
  3499                              ;; Offset of current file descriptor
  3500                              ;;
  3501                          dos_current_file_descriptor_offset:
  3502  bcf9 00                         !8 0
  3503                          
  3504                          ;;         ========================
  3505                          
  3506                              ;; For providing feedback on why DOS calls have failed
  3507                              ;; There is a set of error codes defined in hyppo_dos.asm
  3508                          dos_error_code:
  3509  bcfa 00                         !8 $00
  3510                          
  3511                              ;; Similarly for system partition related errors
  3512                          syspart_error_code:
  3513  bcfb 00                         !8 $00
  3514                          
  3515                              ;; Non-zero if there is a valid system partition
  3516                          syspart_present:
  3517  bcfc 00                         !8 $00
  3518                          
  3519                          ;; /*  -------------------------------------------------------------------
  3520                          ;;     Reserved space for Hypervisor Process work area $BD00-$BDFF
  3521                          ;;     ---------------------------------------------------------------- */
  3522                                  ;; .segment ProcessDescriptors
  3523                                  * = ProcessDescriptors_Start
  3524                          

; ******** Source: process_descriptor.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                  ;; Process descriptor block (fixed 256 bytes)
     7                                  ;;
     8                                  ;; This needs to have information about the current running task,
     9                                  ;; and also hold information about the current open files, if any.
    10                          
    11                                  ;; Process description (first 128 bytes)
    12                          
    13                          	start = *
    14                          currenttask_block:
    15                          
    16                                  ;; Tasks are idenfied by what amounts to an 8-bit process id.
    17                                  ;; Process ID #$FF is special, and indicates that it is the operating system/hypervisor
    18                                  ;; that is active.  This affects how results are return from system calls, so that they
    19                          
    20                          currenttask_id:
    21  bd00 ff                         !8 $FF
    22                          
    23                                  ;; Name of task (16 characters, unused characters should be null)
    24                          
    25                          currenttask_name:
    26  bd01 4f5045524154494e...        !text "OPERATING SYSTEM"
    27                          
    28                          currenttask_d81_image0_flags:
    29  bd11 00                         !8 0
    30                          currenttask_d81_image1_flags:
    31  bd12 00                         !8 0
    32                          
    33                                  ;; File names of currently mounted disk images (32 character max length)
    34                          currenttask_d81_image0_namelen:
    35  bd13 00                         !8 0
    36                          currenttask_d81_image1_namelen:
    37  bd14 00                         !8 0
    38                          currenttask_d81_image0_name:
    39  bd15 2020202020202020...        !text "                                "
    40                          currenttask_d81_image1_name:
    41  bd35 2020202020202020...        !text "                                "
    42                          
    43                          	;; DOS work area is full, so some things over-flow here:
    44                          	
    45                          	;; Used to temporarily stash the currently read SD card sector.
    46                          	;; (mostly to hide when we have to read a FAT sector during file
    47                          	;; access)
    48                          dos_stashed_sd_sector_number:
    49  bd55 00000000           	!8 0,0,0,0
    50                          	
    51                          	
    52                                  ;; Make sure we don't over-flow the available space
    53                                  * = start + $80
    54                          
    55                                  ;; Now we have file control blocks for the open files/directories.
    56                                  ;; We have only 128 bytes for these, so not many files can be open at a time!
    57                                  ;; This also means that we don't keep much information about a file in here.
    58                                  ;; For example, name, permissions/attributes and so on must be requested seprately
    59                                  ;; using trap_dos_fstat.  As a result, we can fit a few more open files in here, to
    60                                  ;; make life easy for programmers.  128 bytes / 32 bytes = 4 open files, which seems
    61                                  ;; a fairly minimal number.
    62                          
    63                          currenttask_filedescriptor0:
    64                                  ;; Which logical drive the file resides on
    65                                  ;; (or $FF for a free descriptor block = closed file.
    66                                  ;;  we put this in the first byte for convience for checking
    67                                  ;;  if a file descriptor is free).
    68                          currenttask_filedescriptor0_drivenumber:
    69  bd80 00                         !8 $00
    70                          
    71                                  ;; Starting cluster in file system
    72                                  ;; (used so that we can seek around in the file)
    73                          currenttask_filedescriptor0_startcluster:
    74  bd81 00000000                   !8 $00,$00,$00,$00
    75                          
    76                                  ;; Current cluster in file system
    77                          currenttask_filedescriptor0_currentcluster:
    78  bd85 00000000                   !8 $00,$00,$00,$00
    79                          
    80                                  ;; Current sector within current cluster
    81                          currenttask_filedescriptor0_sectorincluster:
    82  bd89 00                         !8 $00
    83                          
    84                                  ;; Length of file
    85                          currenttask_filedescriptor0_filelength:
    86  bd8a 00000000                   !8 $00,$00,$00,$00
    87                          
    88                                  ;; Position in file indicated by the buffer
    89                          currenttask_filedescriptor0_bufferposition:
    90  bd8e 00000000                   !8 $00,$00,$00,$00
    91                          
    92                                  ;; Cluster of the directory in which this file resides
    93                          currenttask_filedescriptor0_directorycluster:
    94  bd92 00000000                   !8 $00,$00,$00,$00
    95                          
    96                                  ;; Which entry this file is within the containing directory
    97                          currenttask_filedescriptor0_entryindirectory:
    98  bd96 0000                       !16 $0000
    99                          
   100                                  ;; Buffer address in target task used for this file
   101                                  ;; (32-bit virtual address, so that the buffer can be paged out)
   102                          currenttask_filedescriptor0_bufferaddress:
   103  bd98 00000000                   !8 $00,$00,$00,$00
   104                          
   105                                  ;; bytes loaded into buffer
   106                          currenttask_filedescriptor0_bytesinbuffer:
   107  bd9c 0000                       !16 $0000
   108                          
   109                                  ;; current offset within buffer
   110                          currenttask_filedescriptor0_offsetinbuffer:
   111  bd9e 0000                       !16 $0000
   112                          
   113                                  ;; The other three file descriptors follow the same format as the first
   114                          
   115                                  * = start + $a0
   116                          currenttask_filedescriptor1:
   117                          
   118                                  * = start + $c0
   119                          currenttask_filedescriptor2:
   120                          
   121                                  * = start + $e0
   122                          currenttask_filedescriptor3:
   123                          
   124                                  * = start + $100
   125                          

; ******** Source: src/hyppo/main.asm
  3526                          
  3527                          
  3528                          
  3529                          ;; /*  -------------------------------------------------------------------
  3530                          ;;     Reserved space for Hyppo ZP at $BF00-$BFFF
  3531                          ;;     ---------------------------------------------------------------- */
  3532                                  ;; .segment HyppoZP
  3533                                  * = HyppoZP_Start
  3534                          
  3535                                  ;; Temporary vector storage for DOS
  3536                                  ;;
  3537                          dos_scratch_vector:
  3538  bf00 00000000                   !16 0,0
  3539                          dos_scratch_byte_1:
  3540  bf04 00                         !8 0
  3541                          dos_scratch_byte_2:
  3542  bf05 00                         !8 0
  3543                          
  3544                                  ;; Vectors for copying data between hypervisor and user-space
  3545                                  ;;
  3546                          hypervisor_userspace_copy_vector:
  3547  bf06 0000                       !16 0
  3548                          
  3549                                  ;; general hyppo temporary variables
  3550                                  ;;
  3551                          zptempv:
  3552  bf08 0000                       !16 0
  3553                          zptempv2:
  3554  bf0a 0000                       !16 0
  3555                          zptempp:
  3556  bf0c 0000                       !16 0
  3557                          zptempp2:
  3558  bf0e 0000                       !16 0
  3559                          zptempv32:
  3560  bf10 00000000                   !16 0,0
  3561                          zptempv32b:
  3562  bf14 00000000                   !16 0,0
  3563                          dos_file_loadaddress:
  3564  bf18 00000000                   !16 0,0
  3565                          
  3566                          !if DEBUG_HYPPO {
  3567                                  ;; Used for checkpoint debug system of hypervisor
  3568                                  ;;
  3569                          checkpoint_a:
  3570                                  !8 0
  3571                          checkpoint_x:
  3572                                  !8 0
  3573                          checkpoint_y:
  3574                                  !8 0
  3575                          checkpoint_z:
  3576                                  !8 0
  3577                          checkpoint_p:
  3578                                  !8 0
  3579                          checkpoint_pcl:
  3580                                  !8 0
  3581                          checkpoint_pch:
  3582                                  !8 0
  3583                          }
  3584                          
  3585                                  ;; SD card timeout handling
  3586                                  ;;
  3587                          sdcounter:
  3588  bf1c 000000                     !8 0,0,0
  3589                          
  3590                          ;; /*  -------------------------------------------------------------------
  3591                          ;;     Scratch space in ZP space usually used by kernel
  3592                          ;;     we try to use address space not normally used by C64 kernel, so
  3593                          ;;     that it is possible to make calls to hyppo after boot. Eventually
  3594                          ;;     the desire is to have an SYS call that brings up a menu that lets
  3595                          ;;     you choose a disk image from a list.
  3596                          ;;     ---------------------------------------------------------------- */
  3597                          
  3598                          romslab:
  3599  bf1f 00                         !8 0
  3600                          screenrow:
  3601  bf20 00                         !8 0
  3602                          checksum:
  3603  bf21 00000000                   !32 0
  3604                          file_pagesread:
  3605  bf25 0000                       !16 0
  3606                          
  3607                                  ;; Variables for testing of D81 boot image
  3608                          d81_clusternumber:
  3609  bf27 00000000                   !32 0
  3610                          d81_clustersneeded:
  3611  bf2b 0000                       !16 0
  3612                          d81_clustercount:
  3613  bf2d 0000                       !16 0
  3614                          
  3615                          	;; Make sure we pad to full size
  3616                          	* = Hyppo_End
  3617  bfff 00                 	!8 0
