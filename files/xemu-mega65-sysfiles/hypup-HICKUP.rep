
; ******** Source: src/hyppo/main.asm
     1                            ;; -------------------------------------------------------------------
     2                            ;;   MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                            ;;   Paul Gardner-Stephen, 2014-2024.
     4                            ;;   -------------------------------------------------------------------
     5                            ;;   Purpose:
     6                            ;;   1. Verify checksum of ROM area of slow RAM.
     7                            ;;   2. If checksum fails, load complete ROM from SD card.
     8                            ;;   3. Select default disk image for F011 emulation.
     9                          
    10                            ;;   The hyppo ROM is 16KB in length, and maps at $8000-$BFFF
    11                            ;;   in hypervisor mode.
    12                          
    13                            ;;   Hyppo modifies RAM from $0000-$07FFF (ZP, stack, 40-column
    14                            ;;   screen, 16-bit text mode) during normal boot.
    15                          
    16                            ;;   BG: is the below true still, I dont think so.
    17                            ;;   If Hyppo needs to load the ROM from SD card, then it may
    18                            ;;   modify the first 64KB of fast ram.
    19                          
    20                            ;;   We will use the convention of C=0 means failure, ie CLC/RTS,
    21                            ;;                             and C=1 means success, ie SEC/RTS.
    22                          
    23                          
    24                            ;;   This included file defines many of the alias used throughout
    25                            ;;   it also suggests some memory-map definitions
    26                            ;;   ----------------------------------------------------------------
    27                          

; ******** Source: constants.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                  os_version = $0102
     7                                  dos_version = $0103
     8                                  constant_partition_type_fat32_chs = $0b
     9                                  constant_partition_type_fat32_lba = $0c
    10                                  constant_partition_type_megea65_sys = $41
    11                          
    12                                  ;; DOS error codes
    13                                  ;;
    14                                  dos_errorcode_partition_not_interesting = $01
    15                                  dos_errorcode_bad_signature = $02
    16                                  dos_errorcode_is_small_fat = $03
    17                                  dos_errorcode_too_many_reserved_clusters = $04
    18                                  dos_errorcode_not_two_fats = $05
    19                                  dos_errorcode_too_few_clusters = $06
    20                                  dos_errorcode_readwrite_timeout = $07
    21                                  dos_errorcode_partition_error = $08
    22                                  dos_errorcode_invalid_address = $10
    23                                  dos_errorcode_illegal_value = $11
    24                                  dos_errorcode_read_error = $20
    25                                  dos_errorcode_write_error = $21
    26                                  dos_errorcode_no_such_disk = $80
    27                                  dos_errorcode_name_too_long = $81
    28                                  dos_errorcode_not_implemented = $82
    29                                  dos_errorcode_file_too_long = $83
    30                                  dos_errorcode_too_many_open_files = $84
    31                                  dos_errorcode_invalid_cluster = $85
    32                                  dos_errorcode_is_a_directory = $86
    33                                  dos_errorcode_not_a_directory = $87
    34                                  dos_errorcode_file_not_found = $88
    35                                  dos_errorcode_invalid_file_descriptor = $89
    36                                  dos_errorcode_image_wrong_length = $8A
    37                                  dos_errorcode_image_fragmented = $8B
    38                                  dos_errorcode_no_space = $8C
    39                                  dos_errorcode_file_exists = $8D
    40                                  dos_errorcode_directory_full = $8E
    41                                  dos_errorcode_double_attach = $8F
    42                                  dos_errorcode_eof = $FF
    43                          
    44                                  ;; FAT directory entry constants
    45                                  ;;
    46                                  ;; these seem to be offsets into the STANDARD FAT32 header (DO NOT CHANGE)
    47                                  ;;
    48                                  fs_fat32_dirent_offset_attributes = 11
    49                                  fs_fat32_dirent_offset_shortname = 0
    50                                  fs_fat32_dirent_offset_create_tenthsofseconds = 13
    51                                  fs_fat32_dirent_offset_create_time = 14
    52                                  fs_fat32_dirent_offset_create_date = 16
    53                                  fs_fat32_dirent_offset_access_date = 18
    54                                  fs_fat32_dirent_offset_clusters_high = 20
    55                                  fs_fat32_dirent_offset_modify_time = 22
    56                                  fs_fat32_dirent_offset_modify_date = 24
    57                                  fs_fat32_dirent_offset_clusters_low = 26
    58                                  fs_fat32_dirent_offset_file_length = 28
    59                          
    60                                  ;; VFAT long file name entry constants
    61                                  ;;
    62                                  ;; These are the offsets of the various fields in a directory entry, when
    63                                  ;; used to store a long-file-name fragment.
    64                                  ;;
    65                                  fs_fat32_dirent_offset_lfn_part_number = 0
    66                                  fs_fat32_dirent_offset_lfn_type = 12 ;; $0C
    67                                  fs_fat32_dirent_offset_lfn_checksum = 13
    68                                  fs_fat32_dirent_offset_lfn_part1_chars = 5
    69                                  fs_fat32_dirent_offset_lfn_part1_start = 1
    70                                  fs_fat32_dirent_offset_lfn_part2_chars = 6
    71                                  fs_fat32_dirent_offset_lfn_part2_start = 14
    72                                  fs_fat32_dirent_offset_lfn_part3_chars = 2
    73                                  fs_fat32_dirent_offset_lfn_part3_start = 28
    74                          
    75                                  fs_fat32_attribute_isreadonly = $01
    76                                  fs_fat32_attribute_ishidden = $02
    77                                  fs_fat32_attribute_issystem = $04
    78                                  fs_fat32_attribute_isvolumelabel = $08
    79                                  fs_fat32_attribute_isdirectory = $10
    80                                  fs_fat32_attribute_archiveset = $20
    81                          
    82                                  ;; Possible file modes
    83                                  ;;
    84                                  dos_filemode_directoryaccess = $80
    85                                  dos_filemode_end_of_directory = $81
    86                                  dos_filemode_readonly = 0
    87                                  dos_filemode_readwrite = 1
    88                          
    89                                  ;; 256-byte fixed size records for REL emulaton
    90                                  ;;
    91                                  dos_filemode_relative = 2
    92                          
    93                                  ;; Each disk entry consists of;
    94                                  ;;
    95                                  ;; Offset $00 - starting sector (4 bytes)
    96                                  fs_start_sector = $00
    97                          
    98                                  ;; Offset $04 - sector count (4 bytes)
    99                                  fs_sector_count = $04
   100                          
   101                                  ;; Offset $08 - Filesystem type & media source ($0x = FAT32, $xF = SD card, others reserved for now)
   102                                  fs_type_and_source = $08
   103                          
   104                                  ;; Remaining bytes are filesystem dependent:
   105                                  ;; For FAT32:
   106                                  ;;
   107                                  ;; Offset $09 - length of fat (4 bytes) (FAT starts at fs_fat32_system_sectors)
   108                                  fs_fat32_length_of_fat = $09
   109                          
   110                                  ;; Offset $0D - system sectors (2 bytes)
   111                                  fs_fat32_system_sectors = $0D
   112                          
   113                                  ;; Offset $0F - reserved clusters (1 byte)
   114                                  fs_fat32_reserved_clusters = $0F
   115                          
   116                                  ;; Offset $10 - root dir cluster (2 bytes)
   117                                  fs_fat32_root_dir_cluster = $10
   118                          
   119                                  ;; Offset $12 - cluster count (4 bytes)
   120                                  fs_fat32_cluster_count = $12
   121                          
   122                                  ;; Offset $16 - sectors per cluster
   123                                  fs_fat32_sectors_per_cluster = $16
   124                          
   125                                  ;; Offset $17 - copies of FAT
   126                                  fs_fat32_fat_copies = $17
   127                          
   128                                  ;; Offset $18 - first sector of cluster zero (4 bytes)
   129                                  fs_fat32_cluster0_sector = $18
   130                          
   131                                  ;; Offset $1C - Four spare bytes.
   132                          
   133                                  freeze_prep_none = 0
   134                                  freeze_prep_palette0 = 2
   135                                  freeze_prep_palette1 = 4
   136                                  freeze_prep_palette2 = 6
   137                                  freeze_prep_palette3 = 8
   138                                  freeze_prep_stash_sd_buffer_and_regs = 10
   139                                  freeze_prep_thumbnail = 12
   140                                  freeze_prep_viciv = 14
   141                                  freeze_prep_hyperregs = 16
   142                          
   143                                  ;; this is for all types of images, not only D81
   144                                  d81_image_max_namelen = 32
   145                                  d81_image_flag_mounted =  %00000001     ; enable drive virtualisation
   146                                  d81_image_flag_write_en = %00000100     ; enable write access to image
   147                                  d81_image_flag_noreal   = %01000000     ; don't attach real drive
   148                          
   149                                  syspart_error_readerror = $01
   150                                  syspart_error_badslotnum = $02
   151                                  syspart_error_badmagic = $42
   152                                  syspart_error_nosyspart = $ff

; ******** Source: src/hyppo/main.asm

; ******** Source: macros.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          
     7                          ;; Convenient macro for checkpoints. Uncomment the body to activate it
     8                          !macro Checkpoint .text {
     9                          ;;jsr checkpoint
    10                          ;;!8 0
    11                          ;;!text .text
    12                          ;;!8 0
    13                          }

; ******** Source: src/hyppo/main.asm

; ******** Source: machine.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          !addr reset_vector = $fffc
     7                          !addr irq_vector = $fffe
     8                          !addr nmi_vector = $fffa
     9                          
    10                                  ;; UART IO block (contains many other peripherals)
    11                          !addr uart65_irq_flag = $d606
    12                          !addr ascii_key_in = $d610
    13                          !addr buckykey_status = $d611
    14                          !addr mouse_detect_ctrl = $d61b
    15                          
    16                                  ;; Hypervisor regisger block $d640-$d67f
    17                          !addr hypervisor_a = $d640
    18                          !addr hypervisor_x = $d641
    19                          !addr hypervisor_y = $d642
    20                          !addr hypervisor_z = $d643
    21                          !addr hypervisor_b = $d644
    22                          !addr hypervisor_spl = $d645
    23                          !addr hypervisor_sph = $d646
    24                          !addr hypervisor_flags = $d647
    25                          !addr hypervisor_pcl = $d648
    26                          !addr hypervisor_pch = $d649
    27                          !addr hypervisor_maplohi = $d64a
    28                          !addr hypervisor_maplolo = $d64b
    29                          !addr hypervisor_maphihi = $d64c
    30                          !addr hypervisor_maphilo = $d64d
    31                          !addr hypervisor_maplomb = $d64e
    32                          !addr hypervisor_maphimb = $d64f
    33                          !addr hypervisor_cpuport00 = $d650
    34                          !addr hypervisor_cpuport01 = $d651
    35                          !addr hypervisor_iomode = $d652
    36                          !addr hypervisor_dmagic_srcmb = $d653
    37                          !addr hypervisor_dmagic_dstmb = $d654
    38                          !addr hypervisor_dmagic_list0 = $d655
    39                          !addr hypervisor_dmagic_list1 = $d656
    40                          !addr hypervisor_dmagic_list2 = $d657
    41                          !addr hypervisor_dmagic_list3 = $d658
    42                          !addr hypervisor_hardware_virtualisation = $d659
    43                          
    44                                  ;; d65a
    45                                  ;; d65b
    46                                  ;; d65c
    47                          
    48                          !addr hypervisor_vm_currentpage_lo = $d65d
    49                          !addr hypervisor_vm_currentpage_mid = $d65e
    50                          !addr hypervisor_vm_currentpage_hi = $d65f
    51                          
    52                          !addr hypervisor_vm_pagetable = $d660
    53                          !addr hypervisor_vm_pagetable0_logicalpage_lo = $d660
    54                          !addr hypervisor_vm_pagetable0_logicalpage_hi = $d661
    55                          !addr hypervisor_vm_pagetable0_physicalpage_lo = $d662
    56                          !addr hypervisor_vm_pagetable0_physicalpage_hi = $d663
    57                          !addr hypervisor_vm_pagetable1_logicalpage_lo = $d664
    58                          !addr hypervisor_vm_pagetable1_logicalpage_hi = $d665
    59                          !addr hypervisor_vm_pagetable1_physicalpage_lo = $d666
    60                          !addr hypervisor_vm_pagetable1_physicalpage_hi = $d667
    61                          !addr hypervisor_vm_pagetable2_logicalpage_lo = $d668
    62                          !addr hypervisor_vm_pagetable2_logicalpage_hi = $d669
    63                          !addr hypervisor_vm_pagetable2_physicalpage_lo = $d66a
    64                          !addr hypervisor_vm_pagetable2_physicalpage_hi = $d66b
    65                          !addr hypervisor_vm_pagetable3_logicalpage_lo = $d66c
    66                          !addr hypervisor_vm_pagetable3_logicalpage_hi = $d66d
    67                          !addr hypervisor_vm_pagetable3_physicalpage_lo = $d66e
    68                          !addr hypervisor_vm_pagetable3_physicalpage_hi = $d66f
    69                          
    70                          !addr hypervisor_georam_base_mb = $d670
    71                          !addr hypervsior_georam_block_mask = $d671
    72                          
    73                                  ;; d672 110 010
    74                          !addr hypervisor_secure_mode_flags = $d672
    75                          
    76                                  ;; d673
    77                                  ;; d674
    78                                  ;; d675
    79                                  ;; d676
    80                                  ;; d677
    81                                  ;; d678
    82                                  ;; d679
    83                                  ;; d67a
    84                                  ;; d67b
    85                          
    86                          !addr hypervisor_write_char_to_serial_monitor = $d67c
    87                          
    88                          !addr hypervisor_feature_enables = $d67d
    89                          !addr hypervisor_hickedup_flag = $d67e
    90                          !addr hypervisor_cartridge_flags = $d67e
    91                          !addr hypervisor_enterexit_trigger = $d67f
    92                          
    93                                  ;; Where sector buffer maps (over $DE00-$DFFF IO expansion space)
    94                          !addr sd_sectorbuffer = $DE00
    95                          !addr sd_ctrl = $d680
    96                          !addr sd_address_byte0 = $D681
    97                          !addr sd_address_byte1 = $D682
    98                          !addr sd_address_byte2 = $D683
    99                          !addr sd_address_byte3 = $D684
   100                          !addr sd_buffer_ctrl = $d689
   101                          !addr sd_f011_en = $d68b
   102                          !addr sd_fdc_select = $d6a1
   103                          !addr fdc_mfm_speed = $d6a2
   104                          !addr f011_flag_stomp  = $d6af
   105                          
   106                          !addr fpga_switches_low = $d6dc
   107                          !addr fpga_switches_high = $d6dd
   108                          
   109                                  ;; $D6Ex - Ethernet controller
   110                          !addr mac_addr_0 = $d6e9
   111                          !addr mac_addr_1 = $d6ea
   112                          !addr mac_addr_2 = $d6eb
   113                          !addr mac_addr_3 = $d6ec
   114                          !addr mac_addr_4 = $d6ed
   115                          !addr mac_addr_5 = $d6ee
   116                          
   117                                  ;; $D6Fx - mostly audio interfaces
   118                          !addr audiomix_addr = $d6f4
   119                          !addr audiomix_data = $d6f5
   120                          !addr audioamp_ctl = $d6fe
   121                          
   122                                  ;; Hardware 25(d) x 18(e) multiplier
   123                          !addr mult48_d0 = $d770
   124                          !addr mult48_d1 = $d771
   125                          !addr mult48_d2 = $d772
   126                          !addr mult48_d3 = $d773
   127                          !addr mult48_e0 = $d774
   128                          !addr mult48_e1 = $d775
   129                          !addr mult48_e2 = $d776
   130                          !addr mult48_e3 = $d777
   131                          !addr mult48_result0 = $d778
   132                          !addr mult48_result1 = $d779
   133                          !addr mult48_result2 = $d77a
   134                          !addr mult48_result3 = $d77b
   135                          !addr mult48_result4 = $d77c
   136                          !addr mult48_result5 = $d77d
   137                          !addr mult48_result6 = $d77e
   138                          !addr mult48_result7 = $d77f

; ******** Source: src/hyppo/main.asm
    31                          
    32                          !addr TrapEntryPoints_Start        = $8000
    33                          !addr RelocatedCPUVectors_Start    = $81f8
    34                          !addr Traps_Start                  = $8200
    35                          !addr DOSDiskTable_Start           = $bb00
    36                          !addr SysPartStructure_Start       = $bbc0
    37                          !addr DOSWorkArea_Start            = $bc00
    38                          !addr ProcessDescriptors_Start     = $bd00
    39                          !addr HyppoStack_Start             = $be00
    40                          !addr HyppoZP_Start                = $bf00
    41                          !addr Hyppo_End                    = $bfff
    42                          
    43                          ;; .file [name="../../bin/HICKUP.M65", type="bin", segments="TrapEntryPoints,RelocatedCPUVectors,Traps,DOSDiskTable,SysPartStructure,DOSWorkArea,ProcessDescriptors,HyppoStack,HyppoZP"]
    44                                  !to "bin/HICKUP.M65", plain
    45                          
    46                          ;; .segmentdef TrapEntryPoints        [min=TrapEntryPoints_Start,     max=RelocatedCPUVectors_Start-1                         ]
    47                          ;; .segmentdef RelocatedCPUVectors    [min=RelocatedCPUVectors_Start, max=Traps_Start-1                                       ]
    48                          ;; .segmentdef Traps                  [min=Traps_Start,               max=DOSDiskTable_Start-1                                ]
    49                          ;; .segmentdef DOSDiskTable           [min=DOSDiskTable_Start,        max=SysPartStructure_Start-1,                           ]
    50                          ;; .segmentdef SysPartStructure       [min=SysPartStructure_Start,    max=DOSWorkArea_Start-1                                 ]
    51                          ;; .segmentdef DOSWorkArea            [min=DOSWorkArea_Start,         max=ProcessDescriptors_Start-1                          ]
    52                          ;; .segmentdef ProcessDescriptors     [min=ProcessDescriptors_Start,  max=HyppoStack_Start-1                                  ]
    53                          ;; .segmentdef HyppoStack             [min=HyppoStack_Start,          max=HyppoZP_Start-1,            fill, fillByte=$3e      ]
    54                          ;; .segmentdef HyppoZP                [min=HyppoZP_Start,             max=Hyppo_End,                  fill, fillByte=$3f      ]
    55                          ;; .segmentdef Data                   [min=Data_Start,                max=$ffff                                               ]
    56                          
    57                          ;;         .segment TrapEntryPoints
    58                                  * = TrapEntryPoints_Start
    59                          
    60                          ;; /*  -------------------------------------------------------------------
    61                          ;;     CPU Hypervisor Trap entry points.
    62                          ;;     64 x 4 byte entries for user-land traps.
    63                          ;;     some more x 4 byte entries for system traps (reset, page fault etc)
    64                          ;;     ---------------------------------------------------------------- */
    65                          
    66                          trap_entry_points:
    67                          
    68                                  ;; Traps $00-$07 (user callable)
    69                                  ;;
    70  8000 4c048c                     jmp dos_and_process_trap                ;; Trap #$00 (unsure what to call it)
    71  8003 ea                         eom                                     ;; refer: hyppo_dos.asm
    72  8004 4cb29e                     jmp memory_trap                         ;; Trap #$01
    73  8007 ea                         eom                                     ;; refer: hyppo_mem.asm
    74  8008 4c0886                     jmp syspart_trap                        ;; Trap #$02
    75  800b ea                         eom                                     ;; refer: hyppo_syspart.asm
    76  800c 4c96af                     jmp serialwrite                         ;; Trap #$03
    77  800f ea                         eom                                     ;; refer serialwrite in this file
    78  8010 4c0082                     jmp emulatortrap                        ;; Trap #$04
    79  8013 ea                         eom                                     ;; Reserved for Xemu to use
    80  8014 4c0082                     jmp nosuchtrap
    81  8017 ea                         eom
    82  8018 4c0082                     jmp nosuchtrap
    83  801b ea                         eom
    84  801c 4c0082                     jmp nosuchtrap
    85  801f ea                         eom
    86                          
    87                                  ;; Traps $08-$0F (user callable)
    88                                  ;;
    89  8020 4c0082                     jmp nosuchtrap
    90  8023 ea                         eom
    91  8024 4c0082                     jmp nosuchtrap
    92  8027 ea                         eom
    93  8028 4c0082                     jmp nosuchtrap
    94  802b ea                         eom
    95  802c 4c0082                     jmp nosuchtrap
    96  802f ea                         eom
    97  8030 4c0082                     jmp nosuchtrap
    98  8033 ea                         eom
    99  8034 4c0082                     jmp nosuchtrap
   100  8037 ea                         eom
   101  8038 4c0082                     jmp nosuchtrap
   102  803b ea                         eom
   103  803c 4c0082                     jmp nosuchtrap
   104  803f ea                         eom
   105                          
   106                                  ;; Traps $10-$17 (user callable)
   107                                  ;;
   108  8040 4c0082                     jmp nosuchtrap
   109  8043 ea                         eom
   110  8044 4c29a1                     jmp securemode_trap
   111  8047 ea                         eom
   112  8048 4c36a1                     jmp leave_securemode_trap
   113  804b ea                         eom
   114  804c 4c0082                     jmp nosuchtrap
   115  804f ea                         eom
   116  8050 4c0082                     jmp nosuchtrap
   117  8053 ea                         eom
   118  8054 4c0082                     jmp nosuchtrap
   119  8057 ea                         eom
   120  8058 4c0082                     jmp nosuchtrap
   121  805b ea                         eom
   122  805c 4c0082                     jmp nosuchtrap
   123  805f ea                         eom
   124                          
   125                                  ;; Traps $18-$1F (user callable)
   126                                  ;;
   127  8060 4c0082                     jmp nosuchtrap
   128  8063 ea                         eom
   129  8064 4c0082                     jmp nosuchtrap
   130  8067 ea                         eom
   131  8068 4c0082                     jmp nosuchtrap
   132  806b ea                         eom
   133  806c 4c0082                     jmp nosuchtrap
   134  806f ea                         eom
   135  8070 4c0082                     jmp nosuchtrap
   136  8073 ea                         eom
   137  8074 4c0082                     jmp nosuchtrap
   138  8077 ea                         eom
   139  8078 4c0082                     jmp nosuchtrap
   140  807b ea                         eom
   141  807c 4c0082                     jmp nosuchtrap
   142  807f ea                         eom
   143                          
   144                                  ;; Traps $20-$27 (user callable)
   145                                  ;;
   146  8080 4c0082                     jmp nosuchtrap
   147  8083 ea                         eom
   148  8084 4c0082                     jmp nosuchtrap
   149  8087 ea                         eom
   150  8088 4c0082                     jmp nosuchtrap
   151  808b ea                         eom
   152  808c 4c0082                     jmp nosuchtrap
   153  808f ea                         eom
   154  8090 4c0082                     jmp nosuchtrap
   155  8093 ea                         eom
   156  8094 4c0082                     jmp nosuchtrap
   157  8097 ea                         eom
   158  8098 4c0082                     jmp nosuchtrap
   159  809b ea                         eom
   160  809c 4c0082                     jmp nosuchtrap
   161  809f ea                         eom
   162                          
   163                                  ;; Traps $28-$2F (user callable)
   164                                  ;;
   165  80a0 4c0082                     jmp nosuchtrap
   166  80a3 ea                         eom
   167  80a4 4c0082                     jmp nosuchtrap
   168  80a7 ea                         eom
   169  80a8 4c0082                     jmp nosuchtrap
   170  80ab ea                         eom
   171  80ac 4c0082                     jmp nosuchtrap
   172  80af ea                         eom
   173  80b0 4c0082                     jmp nosuchtrap
   174  80b3 ea                         eom
   175  80b4 4c0082                     jmp nosuchtrap
   176  80b7 ea                         eom
   177  80b8 4c0082                     jmp nosuchtrap
   178  80bb ea                         eom
   179  80bc 4c0082                     jmp nosuchtrap
   180  80bf ea                         eom
   181                          
   182                                  ;; Traps $30-$37
   183                                  ;;
   184  80c0 4c0082                     jmp nosuchtrap
   185  80c3 ea                         eom
   186  80c4 4c0082                     jmp nosuchtrap
   187  80c7 ea                         eom
   188                          
   189  80c8 4c15a1                     jmp protected_hardware_config           ;; Trap #$32 (Protected Hardware Configuration)
   190  80cb ea                         eom                                     ;; refer: hyppo_task
   191                          
   192                          
   193  80cc 4c0082                     jmp nosuchtrap
   194  80cf ea                         eom
   195  80d0 4c0082                     jmp nosuchtrap
   196  80d3 ea                         eom
   197  80d4 4c0082                     jmp nosuchtrap
   198  80d7 ea                         eom
   199  80d8 4c0082                     jmp nosuchtrap
   200  80db ea                         eom
   201  80dc 4c0082                     jmp nosuchtrap
   202  80df ea                         eom
   203                          
   204                                  ;; Traps $38-$3F (user callable)
   205                                  ;;
   206  80e0 4c0082                     jmp nosuchtrap
   207  80e3 ea                         eom
   208  80e4 4c0082                     jmp nosuchtrap
   209  80e7 ea                         eom
   210  80e8 4c0082                     jmp nosuchtrap
   211  80eb ea                         eom
   212  80ec 4c0082                     jmp nosuchtrap
   213  80ef ea                         eom
   214  80f0 4c0082                     jmp nosuchtrap
   215  80f3 ea                         eom
   216  80f4 4c0082                     jmp nosuchtrap
   217  80f7 ea                         eom
   218  80f8 4c0082                     jmp nosuchtrap
   219  80fb ea                         eom
   220                                  ;; Writing to $D67F shall trap to freezer, as though user had triggered it.
   221  80fc 4c79a0                     jmp restore_press_trap
   222  80ff ea                         eom
   223                          
   224                                  ;; Traps $40-$4F (reset, page fault and other system-generated traps)
   225  8100 4c2ba5                     jmp reset_entry                         ;; Trap #$40 (power on / reset)
   226  8103 ea                         eom                                     ;; refer: below in this file
   227                          
   228  8104 4c5a9e                     jmp page_fault                          ;; Trap #$41 (page fault)
   229  8107 ea                         eom                                     ;; refer: hyppo_mem
   230                          
   231  8108 4c79a0                     jmp restore_press_trap                  ;; Trap #$42 (press RESTORE for 0.5 - 1.99 seconds)
   232  810b ea                         eom                                     ;; refer: hyppo_task "1000010" x"42"
   233                          
   234  810c 4c1ea1                     jmp matrix_mode_toggle                  ;; Trap #$43 (C= + TAB combination)
   235  810f ea                         eom                                     ;; refer: hyppo_task
   236                          
   237  8110 4c82a2                     jmp f011_virtual_read                   ;; Trap #$44 (virtualised F011 sector read)
   238  8113 ea                         eom
   239                          
   240  8114 4cc5a2                     jmp f011_virtual_write                  ;; Trap #$45 (virtualised F011 sector write)
   241  8117 ea                         eom
   242                          
   243  8118 4c79a0                     jmp unstable_illegal_opcode_trap        ;; Trap #$46 (6502 unstable illegal opcode)
   244  811b ea                         eom
   245  811c 4c79a0                     jmp kill_opcode_trap                    ;; Trap #$47 (6502 KIL instruction)
   246  811f ea                         eom
   247  8120 4c24a0                     jmp ethernet_remote_trap                ;; Trap #$48 (Ethernet remote control trap)
   248  8123 ea                         eom
   249  8124 4c0082                     jmp nosuchtrap
   250  8127 ea                         eom
   251  8128 4c0082                     jmp nosuchtrap
   252  812b ea                         eom
   253  812c 4c0082                     jmp nosuchtrap
   254  812f ea                         eom
   255  8130 4c0082                     jmp nosuchtrap
   256  8133 ea                         eom
   257  8134 4c0082                     jmp nosuchtrap
   258  8137 ea                         eom
   259  8138 4c0082                     jmp nosuchtrap
   260  813b ea                         eom
   261  813c 4c0082                     jmp nosuchtrap
   262  813f ea                         eom
   263                          
   264                                  ;; Leave room for relocated cpu vectors below
   265                                  ;;
   266                                  ;; .segment RelocatedCPUVectors
   267                                  * = RelocatedCPUVectors_Start
   268                          
   269                                  ;; Then we have relocated CPU vectors at $81F8-$81FF
   270                                  ;; (which are 2-byte vectors for interrupts, not 4-byte
   271                                  ;; trap addresses).
   272                                  ;; These are used to catch interrupts in hypervisor mode
   273                                  ;; (although the need for them may have since been removed)
   274  81f8 2ba5                       !16 reset_entry    ;; unused vector
   275  81fa 3ead                       !16 hypervisor_nmi ;; NMI
   276  81fc 2ba5                       !16 reset_entry    ;; RESET
   277  81fe 3ead                       !16 hypervisor_irq ;; IRQ
   278                          
   279                          
   280                                  ;; .segment Traps
   281                                  * = Traps_Start
   282                          
   283                          ;; /*  -------------------------------------------------------------------
   284                          ;;     Hypervisor traps
   285                          ;;     ---------------------------------------------------------------- */
   286                          
   287                          ;; /*  -------------------------------------------------------------------
   288                          ;;     Illegal trap / trap sub-function handlers
   289                          
   290                          ;;     Traps are triggered by writing to $D640-$D67F
   291                          ;;     and trap to $8000+((address & $3F)*4) in the hypervisor
   292                          
   293                          ;;     Routine for unimplemented/reserved traps
   294                          ;;     (Consider replacing with trap to hypervisor error screen with option
   295                          ;;     to return?)
   296                          ;;     ---------------------------------------------------------------- */
   297                          emulatortrap:
   298                                  ;; FALL-THROUGH -- return failure on real hardware
   299                                  ;; Xemu will intercept it itself
   300                          nosuchtrap:
   301                          
   302                                  ;; Clear C flag for caller to indicate failure
   303                                  ;;
   304  8200 ad47d6                     lda hypervisor_flags
   305  8203 29fe                       and #$FE   ;; C flag is bit 0
   306  8205 8d47d6                     sta hypervisor_flags
   307                          
   308                                  ;; set A to $FF
   309                                  ;;
   310  8208 a9ff                       lda #$ff
   311  820a 8d40d6                     sta hypervisor_a
   312                          
   313                                  ;; return from hypervisor
   314                                  ;;
   315  820d 8d7fd6                     sta hypervisor_enterexit_trigger
   316                          
   317                          ;;         ========================
   318                          
   319                          return_from_trap_with_success_and_file_descriptor_in_a:
   320                          
   321  8210 adf9bc                     lda dos_current_file_descriptor
   322  8213 8d40d6                     sta hypervisor_a
   323                                  ;; FALL THROUGH to return_from_trap_with_success
   324                          
   325                          ;;         ========================
   326                          
   327                          return_from_trap_with_success:
   328                          
   329                                  ;; Return from trap with C flag clear to indicate success
   330                          
   331  8216 2024a2                     jsr sd_unmap_sectorbuffer
   332                          
   333                                  ;; set C flag for caller to indicate success
   334                                  ;;
   335  8219 ad47d6                     lda hypervisor_flags
   336  821c 0901                       ora #$01   ;; C flag is bit 0
   337  821e 8d47d6                     sta hypervisor_flags
   338                          
   339                                  +Checkpoint "return_from_trap_with_success"
   340                          
   341                                  ;; DO NOT Clear A on return
   342                                  ;; (else traps can't return anything in A register)
   343                          
   344                                  ;; return from hypervisor
   345  8221 8d7fd6                     sta hypervisor_enterexit_trigger
   346                          
   347                          ;;         ========================
   348                          
   349                          return_from_trap_with_failure:
   350                          
   351  8224 2024a2                     jsr sd_unmap_sectorbuffer
   352                          
   353                                  ;; report error in A
   354                                  ;;
   355  8227 8d40d6                     sta hypervisor_a
   356  822a ad47d6                     lda hypervisor_flags
   357  822d 29fe                       and #$fe   ;; C flag is bit 0 (ie clear bit-0)
   358  822f 8d47d6                     sta hypervisor_flags
   359                          
   360                                  +Checkpoint "return_from_trap_with_failure"
   361                          
   362                                  ;; return from hypervisor
   363  8232 8d7fd6                     sta hypervisor_enterexit_trigger
   364                          
   365                          ;;         ========================
   366                          
   367                          invalid_subfunction:
   368                          
   369  8235 4c0082                     jmp nosuchtrap
   370                          
   371                          ;;         ========================
   372                          
   373                          ;; /*  -------------------------------------------------------------------
   374                          ;;     System Partition functions
   375                          ;;     ---------------------------------------------------------------- */
   376                          

; ******** Source: syspart.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          
     5                          ;;    MEGA65 System Partition functions
     6                          
     7                          ;;     The system partition (type = $41 = 65) holds several major data
     8                          ;;     areas:
     9                          
    10                          ;;     1. Header, that identifies the version and structure of the system
    11                          ;;        partition.
    12                          
    13                          ;;     2. Frozen programs for task switching.
    14                          ;;        (Some of which may be reserved by the operating system, e.g., for
    15                          ;;         alarms and other special purposes.)
    16                          
    17                          ;;     3. Installed services that can be requested via the Hypervisor.
    18                          ;;        These are internally just frozen programs with a valid service
    19                          ;;        description header.
    20                          
    21                          ;;     HEADER - First sector of partition
    22                          
    23                          ;;     $000-$00A "MEGA65SYS00" - Magic string and version indication
    24                          ;;     $010-$017 Start and size (in sectors) of frozen program area
    25                          ;;     $018-$01b Size of each frozen program slot
    26                          ;;     $01c-$01d Number of frozen program slots
    27                          ;;     $01e-$01f Number of sectors used for frozen program directory
    28                          ;;     $020-$027 Start and size (in sectors) or installed services
    29                          ;;     $028-$02b Size of each installed service slot
    30                          ;;     $02c-$02d Number of service slots
    31                          ;;     $02e-$02f Number of sectors used for slot directory
    32                          ;;     $030-$1ff RESERVED
    33                          
    34                          ;;     Basically we have two main areas in the system partition for frozen
    35                          ;;     programs, and for each we have a directory that allows for quick
    36                          ;;     scanning of the lists. Thee goal is to reduce the number of random
    37                          ;;     seeks (which still have a cost on SD cards, because commencing a
    38                          ;;     read is much slower than continuing one), and also the amount of
    39                          ;;     data required. To this end the directory entries consist of a 64
    40                          ;;     byte name field and a 64 byte reserved field, so that each is 128
    41                          ;;     bytes in total, allowing 4 per 512 byte sector.
    42                          
    43                          ;;     If the first byte of a directory is $00, then the entry is assumed
    44                          ;;     to be free.
    45                          ;;     ---------------------------------------------------------------- */
    46                          
    47                          onboarding_dmalist:
    48                                  ;; MEGA65 Enhanced DMA options
    49  8238 0a                         !8 $0A      ;; Request format is F018A
    50  8239 8000                       !8 $80,$00  ;; Copy from $00xxxxx
    51  823b 8100                       !8 $81,$00  ;; Copy to $00xxxxx
    52                          
    53                                  ;; Copy program down
    54  823d 00                         !8 $00 ;; no more options
    55                                  ;; F018A DMA list
    56  823e 00                         !8 $00 ;; copy + not chained request
    57  823f ff77                       !16 $77FF ;; size of copy
    58  8241 0000                       !16 $0000 ;; starting addr
    59  8243 04                         !8 $04   ;; of bank $5
    60  8244 ff07                       !16 $07FF ;; destination address is $0801 - 2
    61  8246 00                         !8 $00   ;; of bank $0
    62  8247 0000                       !16 $0000 ;; modulo (unused)
    63                          
    64                          
    65                          
    66                          launch_onboarding:
    67                          
    68                                  ;; DMA copy the onboarding utility into place
    69  8249 a9ff                       lda #$ff
    70  824b 8d02d7                     sta $d702
    71                                  ;; lda #$ff
    72  824e 8d04d7                     sta $d704  ;; dma list is in top MB of address space
    73  8251 a982                       lda #>onboarding_dmalist
    74  8253 8d01d7                     sta $d701
    75                                  ;; Trigger enhanced DMA
    76  8256 a938                       lda #<onboarding_dmalist
    77  8258 8d05d7                     sta $d705
    78                          
    79                                  ;; Run util from in hypervisor context, similarly to how we run the flash menu
    80                                  ;; this means the whole thing must be less than ~29KB in size, to not run over
    81                                  ;; $8000-$BFFF where the hypervisor is mapped
    82  825b 4c5fae                     jmp run_util_in_hypervisor_context
    83                          
    84                          syspart_open:
    85                                  ;; Open a system partition.
    86                                  ;; At this point, only syspart_start_sector and
    87                                  ;; syspart_size_in_sectors have been initialised.
    88                          
    89                                  ;; Read First sector of system partition
    90  825e a203                       ldx #$03
    91  8260 bdc0bb             spo1:   lda syspart_start_sector,x
    92  8263 9d81d6                     sta $d681,x
    93  8266 ca                         dex
    94  8267 10f7                       bpl spo1
    95                          
    96  8269 a901                       lda #syspart_error_readerror
    97  826b 8dfdbc                     sta syspart_error_code
    98  826e 202da2                     jsr sd_readsector
    99  8271 907f                       bcc syspart_openerror
   100                          
   101                                  ;; Got First sector of system partition.
   102                          
   103                                  ;; Check magic string
   104  8273 a942                       lda #syspart_error_badmagic
   105  8275 8dfdbc                     sta syspart_error_code
   106  8278 a20a                       ldx #10
   107  827a bd00de             spo2:        lda $de00,x
   108  827d dd7d85                     cmp syspart_magic,x
   109  8280 d070                       bne syspart_openerror
   110  8282 ca                         dex
   111  8283 10f5                       bpl spo2
   112                          
   113  8285 a900                       lda #$00
   114  8287 8dfdbc                     sta syspart_error_code
   115                          
   116                                  ;; Copy bytes from offset $10 - $2F into syspart_structure
   117                                  ;; XXX It is assumed that these fields are aligned with each other
   118  828a a210                       ldx #$10
   119  828c bd00de             spo3:        lda $de00,x
   120  828f 9dc0bb                     sta syspart_structure,x
   121  8292 e8                         inx
   122  8293 e030                       cpx #$30
   123  8295 d0f5                       bne spo3
   124                          
   125                                  ;; Display info about # of freeze and service slots
   126  8297 a2c0                       ldx #<msg_syspart_info
   127  8299 a085                       ldy #>msg_syspart_info
   128  829b 20bcaa                     jsr printmessage
   129  829e a000                       ldy #$00
   130  82a0 abddbb                     ldz syspart_freeze_slot_count+1
   131  82a3 2035ab                     jsr printhex
   132  82a6 abdcbb                     ldz syspart_freeze_slot_count+0
   133  82a9 2035ab                     jsr printhex
   134  82ac abedbb                     ldz syspart_service_slot_count+1
   135  82af 2035ab                     jsr printhex
   136  82b2 abecbb                     ldz syspart_service_slot_count+0
   137  82b5 2035ab                     jsr printhex
   138                          
   139                                  ;; Show size of freeze slots
   140  82b8 abdbbb                     ldz syspart_freeze_slot_size_in_sectors+3
   141  82bb 2035ab                     jsr printhex
   142  82be abdabb                     ldz syspart_freeze_slot_size_in_sectors+2
   143  82c1 2035ab                     jsr printhex
   144  82c4 abd9bb                     ldz syspart_freeze_slot_size_in_sectors+1
   145  82c7 2035ab                     jsr printhex
   146  82ca abd8bb                     ldz syspart_freeze_slot_size_in_sectors+0
   147  82cd 2035ab                     jsr printhex
   148                          
   149  82d0 a901                       lda #$01
   150  82d2 8dfebc                     sta syspart_present
   151                          
   152  82d5 a2ac                       ldx #<msg_syspart_ok
   153  82d7 a085                       ldy #>msg_syspart_ok
   154  82d9 20bcaa                     jsr printmessage
   155                          
   156  82dc 200484                     jsr syspart_configsector_read
   157  82df ad0ede                     lda $de0e
   158  82e2 1021                       bpl do_launch_onboarding
   159                          no_onboarding:
   160  82e4 201484                     jsr syspart_configsector_apply
   161  82e7 b007                       bcs spo4
   162                          
   163  82e9 a2e4                       ldx #<msg_syspart_config_invalid
   164  82eb a085                       ldy #>msg_syspart_config_invalid
   165  82ed 20bcaa                     jsr printmessage
   166                          
   167  82f0 38                 spo4:        sec
   168  82f1 60                         rts
   169                          
   170                          syspart_openerror:
   171                          
   172                                  ;; Report error opening system partition
   173  82f2 a288                       ldx #<msg_syspart_open_error
   174  82f4 a085                       ldy #>msg_syspart_open_error
   175  82f6 20bcaa                     jsr printmessage
   176  82f9 a000                       ldy #$00
   177  82fb abfdbc                     ldz syspart_error_code
   178  82fe 2035ab                     jsr printhex
   179  8301 a300                       ldz #$00
   180                          
   181  8303 18                         clc
   182  8304 60                         rts
   183                          
   184                          do_launch_onboarding:
   185                                  ;; Only try onboarding on first boot
   186  8305 ad78a5                     lda first_boot_flag_instruction
   187  8308 c94c                       cmp #$4c
   188  830a f0d8                       beq no_onboarding
   189  830c 4c4982                     jmp launch_onboarding
   190                          
   191                                  ;; XXX These should return success/failure indication
   192                          syspart_configsector_read_trap:
   193  830f 200484                     jsr syspart_configsector_read
   194  8312 8d7fd6                     sta hypervisor_enterexit_trigger
   195                          
   196                          syspart_configsector_write_trap:
   197  8315 200a84                     jsr syspart_configsector_write
   198  8318 8d7fd6                     sta hypervisor_enterexit_trigger
   199                          
   200                          syspart_configsector_set_trap:
   201  831b 20f783                     jsr syspart_configsector_set
   202  831e 8d7fd6                     sta hypervisor_enterexit_trigger
   203                          
   204                          syspart_configsector_apply_trap:
   205  8321 201484                     jsr syspart_configsector_apply
   206  8324 8d7fd6                     sta hypervisor_enterexit_trigger
   207                          
   208                          syspart_unfreeze_from_slot_trap:
   209  8327 ae41d6                     ldx hypervisor_x
   210  832a 206483                     jsr syspart_locate_freezeslot
   211  832d 20b186                     jsr unfreeze_load_from_sdcard_immediate
   212                          
   213                                  ;; Set task ID to $00 if it was $ff, so that you can't unfreeze something,
   214                                  ;; and have the hypervisor think that it loaded it
   215  8330 ad00bd                     lda currenttask_id
   216  8333 c9ff                       cmp #$ff
   217  8335 d005                       bne wasnt_ff
   218  8337 a900                       lda #$00
   219  8339 8d00bd                     sta currenttask_id
   220                          wasnt_ff:
   221                          
   222                                  ;;  Make sure we resume a frozen program on the same raster line as
   223                                  ;; it entered the freezer.  This might need a bit of tuning to get
   224                                  ;; perfect, but it should already be accurate to within one raster line.
   225                          
   226                          
   227  833c a9ff                       lda #$ff
   228                          @unfreezesyncwait:
   229  833e cd12d0                     cmp $d012
   230  8341 d0fb                       bne @unfreezesyncwait
   231                                  ;; Clear any pending raster interrupt, to avoid problems.
   232  8343 ce19d0                     dec $d019
   233  8346 8d7fd6                     sta hypervisor_enterexit_trigger
   234                          
   235                          syspart_get_slot_count_trap:
   236  8349 aedcbb                     ldx syspart_freeze_slot_count+0
   237  834c 8e41d6                     stx hypervisor_x
   238  834f acddbb                     ldy syspart_freeze_slot_count+1
   239  8352 8c42d6                     sty hypervisor_y
   240  8355 4c1682                     jmp return_from_trap_with_success
   241                          
   242                          syspart_locate_freezeslot_trap:
   243  8358 ae41d6                     ldx hypervisor_x
   244  835b ac42d6                     ldy hypervisor_y
   245  835e 206483                     jsr syspart_locate_freezeslot
   246  8361 8d7fd6                     sta hypervisor_enterexit_trigger
   247                          
   248                          syspart_locate_freezeslot:
   249                                  ;; Get the first sector of a given freeze slot
   250                                  ;; X = low byte of slot #
   251                                  ;; Y = high byte of slot #
   252                          
   253  8364 da                         phx
   254  8365 5a                         phy
   255                          
   256                                  ;; Check that we have a system partition
   257  8366 adfebc                     lda syspart_present
   258  8369 d007                       bne splf1
   259  836b a9ff                       lda #syspart_error_nosyspart
   260  836d 8dfdbc                     sta syspart_error_code
   261  8370 18                         clc
   262  8371 60                         rts
   263                          splf1:
   264                                  ;; Check that freeze slot number is not invalid
   265  8372 ccddbb                     cpy syspart_freeze_slot_count+1
   266  8375 f002                       beq sc1
   267  8377 900e                       bcc slotnumok
   268  8379 ecdcbb             sc1:        cpx syspart_freeze_slot_count+0
   269  837c f002                       beq slotbad
   270  837e 9007                       bcc slotnumok
   271                          slotbad:
   272                                  ;; Report error status for out of bounds slot number
   273  8380 a902                       lda #syspart_error_badslotnum
   274  8382 8dfdbc                     sta syspart_error_code
   275  8385 18                         clc
   276  8386 60                         rts
   277                          
   278                          slotnumok:
   279                          
   280  8387 20b983                     jsr syspart_locate_freezeslot_0
   281                                  ;; Now add freeze slot size x (YYXX) bytes
   282                                  ;; Use hardware multiplier to work out slot address
   283                          
   284                                  ;; Set multiplicant inputs to multiplier
   285                          
   286                                  ;; XXX - Works only with SD HC cards!
   287                          
   288                                  ;; SDHC, so unit is sectors, and so is just a case of copying the bytes
   289                                  ;; Start by shifting down by 1 byte = /256
   290  838a a203                       ldx #$03
   291  838c bdd8bb             splf4b:        lda syspart_freeze_slot_size_in_sectors,x
   292  838f 9d70d7                     sta mult48_d0,x
   293  8392 ca                         dex
   294  8393 10f7                       bpl splf4b
   295                          
   296                          @multiplierSet:
   297                          
   298  8395 fa                         plx
   299  8396 8e74d7                     stx mult48_e0
   300  8399 7a                         ply
   301  839a 8c75d7                     sty mult48_e1
   302  839d a900                       lda #$00
   303  839f 8d76d7                     sta mult48_e2
   304  83a2 8d77d7                     sta mult48_e3
   305                          
   306                                  ;; Read out answer, and add it to slot 0 address
   307  83a5 a200                       ldx #0
   308  83a7 a003                       ldy #3
   309  83a9 18                         clc
   310  83aa bd78d7             splf3:        lda mult48_result0,x
   311  83ad 7d81d6                     adc $d681,x
   312  83b0 9d81d6                     sta $d681,x
   313  83b3 e8                         inx
   314  83b4 88                         dey
   315  83b5 10f3                       bpl splf3
   316                          
   317  83b7 38                         sec
   318  83b8 60                         rts
   319                          
   320                          syspart_locate_freezeslot_0:
   321                                  ;; Freeze slot #0 starts at:
   322                                  ;;   syspart_start_sector + syspart_freeze_area_start
   323                                  ;; + syspart_freeze_directory_sector_count
   324  83b9 adc0bb                     lda syspart_start_sector+0
   325  83bc 18                         clc
   326  83bd 6dd0bb                     adc syspart_freeze_area_start+0
   327  83c0 8d81d6                     sta $d681
   328  83c3 a201                       ldx #1
   329  83c5 bdc0bb             splf2:        lda syspart_start_sector,x
   330  83c8 7dd0bb                     adc syspart_freeze_area_start,x
   331  83cb 9d81d6                     sta $d681,x
   332  83ce e8                         inx
   333  83cf e004                       cpx #4
   334  83d1 d0f2                       bne splf2
   335  83d3 ad81d6                     lda $d681
   336  83d6 18                         clc
   337  83d7 6ddebb                     adc syspart_freeze_directory_sector_count+0
   338  83da 8d81d6                     sta $d681
   339  83dd ad82d6                     lda $d682
   340  83e0 6ddfbb                     adc syspart_freeze_directory_sector_count+1
   341  83e3 8d82d6                     sta $d682
   342  83e6 ad83d6                     lda $d683
   343  83e9 6900                       adc #0
   344  83eb 8d83d6                     sta $d683
   345  83ee ad84d6                     lda $d684
   346  83f1 6900                       adc #0
   347  83f3 8d84d6                     sta $d684
   348                          
   349  83f6 60                         rts
   350                          
   351                          
   352                          syspart_configsector_set:
   353                                  ;; So, the config sector USED to live in the system partition.
   354                                  ;; But that causes a few problems:
   355                                  ;; 1. You need a system partition, just to be able to pick PAL or NTSC on start.
   356                                  ;; 2. The utility menu now, for good reason, appears before trying to probe any
   357                                  ;;    SD cards. This means that the configure programme couldn't work out the
   358                                  ;;    correct sector to work on.
   359                                  ;; As a result, we now just officially have the config sector live in sector 1.
   360  83f7 a203                       ldx #3
   361  83f9 a900                       lda #0
   362                          spcr1:        ;; lda syspart_start_sector,x
   363  83fb 9d81d6                     sta $d681,x
   364  83fe ca                         dex
   365  83ff 10fa                       bpl spcr1
   366  8401 4c6fa2                     jmp sd_inc_sectornumber
   367                          
   368                          syspart_configsector_read:
   369  8404 20f783                     jsr syspart_configsector_set
   370  8407 4c2da2                     jmp sd_readsector
   371                          
   372                          syspart_configsector_write:
   373  840a 20f783                     jsr syspart_configsector_set
   374  840d 209ea1                     jsr write_non_mbr_sector
   375  8410 38                         sec
   376  8411 60                         rts
   377                          
   378                          syspart_config_invalid:
   379  8412 18                         clc
   380  8413 60                         rts
   381                          
   382                          syspart_configsector_apply:
   383                                  ;; Check version
   384  8414 ad00de                     lda $de00
   385  8417 c901                       cmp #$01
   386  8419 d0f7                       bne syspart_config_invalid
   387  841b ad01de                     lda $de01
   388  841e c901                       cmp #$01
   389  8420 d0f0                       bne syspart_config_invalid
   390                          
   391                                  ;; Set DMAgic revision
   392  8422 ad20de                     lda $de20
   393  8425 8d03d7                     sta $d703
   394                          
   395                                  ;; Set $D054 options
   396                                  ;; (eg scanline emulation ($20) and horizontal blur filter ($08))
   397  8428 a928                       lda #$28
   398  842a 1c54d0                     trb $d054
   399  842d 2d21de                     and $de21
   400  8430 0c54d0                     tsb $d054
   401                          
   402                                  ;; Set PAL/NTSC mode (keeping $D058 value)
   403  8433 ae58d0                     ldx $d058
   404  8436 ad6fd0                     lda $d06f
   405  8439 293f                       and #$3f
   406  843b 8d6fd0                     sta $d06f
   407  843e ad02de                     lda $de02
   408  8441 29c0                       and #$c0
   409  8443 0d6fd0                     ora $d06f
   410  8446 8d6fd0                     sta $d06f
   411                                  ;; And also write it into the instruction that sets the display mode on reset
   412  8449 8d75a9                     sta pal_ntsc_minus_1+1
   413  844c 8e58d0                     stx $d058
   414                          
   415                                  ;; set CIA TOD50 flag depending on PAL/NTSC
   416  844f ad02de                     lda $de02
   417  8452 2980                       and #$80        ; extract flag (1 = NTSC)
   418  8454 d012                       bne @skiptod50  ; already cleared flags, done!
   419  8456 ad0edc                     lda $dc0e
   420  8459 0980                       ora #$80
   421  845b 8d0edc                     sta $dc0e       ; set CIA1:TOD50
   422  845e ad0edd                     lda $dd0e
   423  8461 0980                       ora #$80
   424  8463 8d0edd                     sta $dd0e       ; set CIA2:TOD50
   425  8466 8010                       bra @skiptod50end
   426                          @skiptod50:
   427  8468 ad0edc                     lda $dc0e
   428  846b 297f                       and #$7f
   429  846d 8d0edc                     sta $dc0e       ; clear CIA1:TOD50
   430  8470 ad0edd                     lda $dd0e
   431  8473 297f                       and #$7f
   432  8475 8d0edd                     sta $dd0e       ; clear CIA2:TOD50
   433                          @skiptod50end:
   434                          
   435                                  ;; Set audio and related options
   436  8478 ad0dde                     lda $de0d
   437  847b 8d1ad6                     sta $d61a
   438  847e a900                       lda #$00
   439  8480 8d3cd6                     sta $d63c
   440  8483 ad22de                     lda $de22
   441  8486 f005                       beq @sid6581
   442  8488 a90f                       lda #$0f
   443  848a 8d3cd6                     sta $d63c
   444                          @sid6581:
   445                          
   446                          
   447                                  ;; Trigger onboarding menu or not
   448                                  ;; (activated elsewhere)
   449                                  // $de0e bit 7
   450                          
   451                                  ;; Super SFX cartridge emulation
   452  848d ad0cde                     lda $de0c
   453  8490 a300                       ldz #$00
   454  8492 a907                       lda #$07
   455  8494 8d13bf                     sta zptempv32+3
   456  8497 a2fe                       ldx #$fe
   457  8499 8e12bf                     stx zptempv32+2
   458  849c e8                         inx
   459  849d 8e11bf                     stx zptempv32+1
   460  84a0 8e10bf                     stx zptempv32+0
   461  84a3 ea9210                     sta [<zptempv32],z
   462                          
   463                                  ;; Audio amplifier control
   464  84a6 ad03de                     lda $de03
   465  84a9 2901                       and #$01
   466  84ab 8dfed6                     sta audioamp_ctl
   467                          
   468                                  ;; Stereo flags
   469  84ae ad03de                     lda $de03
   470  84b1 2940                       and #$40
   471  84b3 f006                       beq is_stereo
   472  84b5 2036a3                     jsr audio_set_mono
   473  84b8 4ccb84                     jmp done_audio
   474                          is_stereo:
   475  84bb ad03de                     lda $de03
   476  84be 2920                       and #$20
   477  84c0 d006                       bne is_mirrored
   478  84c2 20b1a3                     jsr audio_set_stereo
   479  84c5 4ccb84                     jmp done_audio
   480                          is_mirrored:
   481  84c8 20bba3                     jsr audio_set_stereomirrored
   482                          done_audio:
   483                          
   484                                  ;; Set F011 to use 3.5 drive or disk images
   485  84cb ad04de                     lda $de04
   486  84ce 8da1d6                     sta sd_fdc_select
   487                                  ;; this **will** make the second drive unattached/nodisk!
   488                                  ;; - we fix this for now in main.asm:1140
   489                          
   490                                  ;; Enable/disable Amiga mouse support (emulates 1351 mouse)
   491  84d1 ad05de                     lda $de05
   492  84d4 8d1bd6                     sta mouse_detect_ctrl
   493                          
   494                                  ;; Enable/disable experimental long filename support
   495  84d7 a94c                       lda #$4c                 ; Disable LFN support by default
   496  84d9 8d7b95                     sta disable_lfn_byte
   497  84dc ad0fde                     lda $de0f
   498  84df 1005                       bpl @nolfn
   499                                  ;; Diable jump that disables LFN support
   500  84e1 a92c                       lda #$2c                 ; BIT $xxxx opcode
   501  84e3 8d7b95                     sta disable_lfn_byte
   502                          @nolfn:
   503                                  ;; Copy MAC address
   504  84e6 a205                       ldx #$05
   505                          maccopy:
   506  84e8 bd06de                     lda $de06, x
   507  84eb 9de9d6                     sta mac_addr_0, x
   508  84ee ca                         dex
   509  84ef 10f7                       bpl maccopy
   510                          
   511                                  ;; Copy default disk image name
   512  84f1 ad10de                     lda $de10
   513  84f4 f00b                       beq nodiskname
   514  84f6 a20f                       ldx #$0f
   515                          disknamecopy:
   516  84f8 bd10de                     lda        $de10, x
   517  84fb 9ddcb3                     sta        txt_MEGA65D81, x
   518  84fe ca                         dex
   519  84ff 10f7                       bpl        disknamecopy
   520                          nodiskname:
   521  8501 38                         sec
   522  8502 60                         rts
   523                          
   524                          syspart_dmagic_autoset_trap:
   525  8503 200985                     jsr syspart_dmagic_autoset
   526  8506 8d7fd6                     sta hypervisor_enterexit_trigger
   527                          
   528                          syspart_dmagic_autoset:
   529                                  ;; Set DMAgic revision based on ROM version
   530                                  ;; $20017-$2001D = "V9xxxxx" version string.
   531                                  ;; If it is 900000 - 910522, then DMAgic revA, else revB
   532  8509 a916                       lda #$16
   533  850b 8d10bf                     sta zptempv32
   534  850e a900                       lda #$00
   535  8510 8d11bf                     sta zptempv32+1
   536  8513 8d13bf                     sta zptempv32+3
   537  8516 a902                       lda #$02
   538  8518 8d12bf                     sta zptempv32+2
   539  851b a300                       ldz #$00
   540  851d eab210                     lda [<zptempv32],z
   541  8520 c956                       cmp #$56
   542  8522 f001                       beq @hasC65ROMVersion
   543  8524 60                         rts
   544                          @hasC65ROMVersion:
   545                                  ;; Check first digit is 9
   546  8525 1b                         inz
   547  8526 eab210                     lda [<zptempv32],z
   548  8529 c939                       cmp #$39
   549  852b d034                       bne @useDMAgicRevB
   550                                  ;; check if second digit is 0, if so, revA
   551  852d 1b                         inz
   552  852e eab210                     lda [<zptempv32],z
   553  8531 c930                       cmp #$30
   554  8533 f03a                       beq @useDMAgicRevA
   555                                  ;; check if second digit != 1, if so, revB
   556  8535 c931                       cmp #$31
   557  8537 d028                       bne @useDMAgicRevB
   558                                  ;; check 3rd digit is 0, if not, revB
   559  8539 1b                         inz
   560  853a eab210                     lda [<zptempv32],z
   561  853d c930                       cmp #$30
   562  853f d020                       bne @useDMAgicRevB
   563                                  ;; check 4th digit is >5, if so, revB
   564  8541 1b                         inz
   565  8542 eab210                     lda [<zptempv32],z
   566  8545 c936                       cmp #$36
   567  8547 b018                       bcs @useDMAgicRevB
   568                                  ;; check 4th digit is <5, if so, revA
   569  8549 c935                       cmp #$35
   570  854b 9022                       bcc @useDMAgicRevA
   571                                  ;; check 5th digit <=> 2
   572  854d 1b                         inz
   573  854e eab210                     lda [<zptempv32],z
   574  8551 c932                       cmp #$32
   575  8553 901a                       bcc @useDMAgicRevA
   576  8555 c933                       cmp #$33
   577  8557 b008                       bcs @useDMAgicRevB
   578                                  ;; check 6th digit <3
   579  8559 1b                         inz
   580  855a eab210                     lda [<zptempv32],z
   581  855d c933                       cmp #$33
   582  855f 900e                       bcc @useDMAgicRevA
   583                          @useDMAgicRevB:
   584  8561 a300                       ldz #$00
   585  8563 a901                       lda #$01
   586  8565 0c03d7                     tsb $d703
   587                          
   588  8568 a286                       ldx #<msg_dmagicb
   589  856a a0b3                       ldy #>msg_dmagicb
   590  856c 4cbcaa                     jmp printmessage
   591                          
   592                          @useDMAgicRevA:
   593  856f a300                       ldz #$00
   594  8571 a901                       lda #$01
   595  8573 1c03d7                     trb $d703
   596                          
   597  8576 a274                       ldx #<msg_dmagica
   598  8578 a0b3                       ldy #>msg_dmagica
   599  857a 4cbcaa                     jmp printmessage
   600                          
   601                          
   602                                  ;; Magic string that identifies a MEGA65 system partition
   603                          syspart_magic:
   604  857d 4d45474136355359...        !text "MEGA65SYS00"
   605                          msg_syspart_open_error:
   606  8588 53595354454d2050...        !text "SYSTEM PARTITION ERROR: (ERRNO: $$)"
   607  85ab 00                         !8 0
   608                          msg_syspart_ok:
   609  85ac 53595354454d2050...        !text "SYSTEM PARTITION OK"
   610  85bf 00                         !8 0
   611                          msg_syspart_info:
   612  85c0 5359533a20242424...        !text "SYS: $$$$ FRZ + $$$$ SVC X $$$$$$$$"
   613  85e3 00                         !8 0
   614                          msg_syspart_config_invalid:
   615  85e4 5359535041525420...        !text "SYSPART CONFIG INVALID. PLEASE SET."
   616  8607 00                         !8 0
   617                          
   618                          syspart_trap:
   619  8608 78                         sei
   620  8609 d8                         cld
   621  860a 29fe                       and #$fe
   622  860c aa                         tax
   623  860d 7c1086                     jmp (syspart_trap_table,x)
   624                          
   625                          syspart_trap_table:
   626                                  ;; $00-$0E
   627  8610 0f83                       !16 syspart_configsector_read_trap
   628  8612 1583                       !16 syspart_configsector_write_trap
   629  8614 2183                       !16 syspart_configsector_apply_trap
   630  8616 1b83                       !16 syspart_configsector_set_trap
   631  8618 0385                       !16 syspart_dmagic_autoset_trap
   632  861a 3582                       !16 invalid_subfunction
   633  861c 3582                       !16 invalid_subfunction
   634  861e 3582                       !16 invalid_subfunction
   635                          
   636                                  ;; $10-$1E
   637  8620 5883                       !16 syspart_locate_freezeslot_trap
   638  8622 2783                       !16 syspart_unfreeze_from_slot_trap
   639  8624 3c8b                       !16 syspart_read_freeze_region_list_trap
   640  8626 4983                       !16 syspart_get_slot_count_trap
   641  8628 3582                       !16 invalid_subfunction
   642  862a 3582                       !16 invalid_subfunction
   643  862c 3582                       !16 invalid_subfunction
   644  862e 3582                       !16 invalid_subfunction
   645                          
   646                                  ;; $20-$2E
   647  8630 3582                       !16 invalid_subfunction
   648  8632 3582                       !16 invalid_subfunction
   649  8634 3582                       !16 invalid_subfunction
   650  8636 3582                       !16 invalid_subfunction
   651  8638 3582                       !16 invalid_subfunction
   652  863a 3582                       !16 invalid_subfunction
   653  863c 3582                       !16 invalid_subfunction
   654  863e 3582                       !16 invalid_subfunction
   655                          
   656                                  ;; $30-$3E
   657  8640 3582                       !16 invalid_subfunction
   658  8642 3582                       !16 invalid_subfunction
   659  8644 3582                       !16 invalid_subfunction
   660  8646 3582                       !16 invalid_subfunction
   661  8648 3582                       !16 invalid_subfunction
   662  864a 3582                       !16 invalid_subfunction
   663  864c 3582                       !16 invalid_subfunction
   664  864e 3582                       !16 invalid_subfunction
   665                          
   666                                  ;; $40-$4E
   667  8650 3582                       !16 invalid_subfunction
   668  8652 3582                       !16 invalid_subfunction
   669  8654 3582                       !16 invalid_subfunction
   670  8656 3582                       !16 invalid_subfunction
   671  8658 3582                       !16 invalid_subfunction
   672  865a 3582                       !16 invalid_subfunction
   673  865c 3582                       !16 invalid_subfunction
   674  865e 3582                       !16 invalid_subfunction
   675                          
   676                                  ;; $50-$5E
   677  8660 3582                       !16 invalid_subfunction
   678  8662 3582                       !16 invalid_subfunction
   679  8664 3582                       !16 invalid_subfunction
   680  8666 3582                       !16 invalid_subfunction
   681  8668 3582                       !16 invalid_subfunction
   682  866a 3582                       !16 invalid_subfunction
   683  866c 3582                       !16 invalid_subfunction
   684  866e 3582                       !16 invalid_subfunction
   685                          
   686                                  ;; $60-$6E
   687  8670 3582                       !16 invalid_subfunction
   688  8672 3582                       !16 invalid_subfunction
   689  8674 3582                       !16 invalid_subfunction
   690  8676 3582                       !16 invalid_subfunction
   691  8678 3582                       !16 invalid_subfunction
   692  867a 3582                       !16 invalid_subfunction
   693  867c 3582                       !16 invalid_subfunction
   694  867e 3582                       !16 invalid_subfunction
   695                          
   696                                  ;; $70-$7E
   697  8680 3582                       !16 invalid_subfunction
   698  8682 3582                       !16 invalid_subfunction
   699  8684 3582                       !16 invalid_subfunction
   700  8686 3582                       !16 invalid_subfunction
   701  8688 3582                       !16 invalid_subfunction
   702  868a 3582                       !16 invalid_subfunction
   703  868c 3582                       !16 invalid_subfunction
   704  868e 3582                       !16 invalid_subfunction

; ******** Source: src/hyppo/main.asm
   378                          
   379                          ;; /*  -------------------------------------------------------------------
   380                          ;;     Freeze/Unfreeze functions
   381                          ;;     ---------------------------------------------------------------- */

; ******** Source: freeze.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          version_sentinel_str = "VRS"
     7                          version = 1
     8                          
     9                          freeze_to_slot:
    10                                  ;; Freeze current running process to the specified slot
    11                          
    12                                  ;; Slot in XXYY
    13                          
    14  8690 206483                     jsr syspart_locate_freezeslot
    15  8693 b001                       bcs freeze_save_to_sdcard_immediate
    16  8695 60                         rts
    17                          
    18                          freeze_save_to_sdcard_immediate:
    19                          
    20                                  ;; Save the current process to the SD card. $D681-4 are expected to
    21                                  ;; already be pointing to the first sector of the freeze slot
    22                          
    23                                  ;; Stash SD card registers to scratch area
    24                                  ;; (also stashed $D070 which gets mushed by palette saving)
    25  8696 20c08a                     jsr copy_sdcard_regs_to_scratch
    26                          
    27                                  ;; Save current SD card sector buffer contents
    28  8699 205b87                     jsr freeze_write_first_sector_and_wait
    29                          
    30                                  ;; Save each region in the list
    31  869c a200                       ldx #$00
    32                          freeze_next_region:
    33  869e 20c887                     jsr freeze_save_region
    34  86a1 8a                         txa
    35  86a2 18                         clc
    36  86a3 6908                       adc #$08
    37  86a5 aa                         tax
    38  86a6 bd5f8b                     lda freeze_mem_list+7,x
    39  86a9 c9ff                       cmp #$ff
    40  86ab d0f1                       bne freeze_next_region
    41                          
    42  86ad 20b787                     jsr freeze_end_multi_block_write
    43                          
    44  86b0 60                         rts
    45                          
    46                          unfreeze_load_from_sdcard_immediate:
    47                          
    48                                  ;; Restore a frozen process from the SD card. $D681-4 are expecxted to
    49                                  ;; already be pointing to the first sector of the freeze slot
    50                          
    51                                  ;; Skip the first sector of the frozen program which is the
    52                                  ;; contents of the SD card sector buffer prior to freezing.
    53                                  ;; (We will load it in as the very last thing)
    54  86b1 206fa2                     jsr sd_inc_sectornumber
    55                          
    56                                  ;; Save each region in the list
    57  86b4 a200                       ldx #$00
    58                          
    59                          unfreeze_next_region:
    60                          
    61                                  ;; Require SHIFT press and release between every sector for debug
    62                          ;;         jsr wait_on_shift_key
    63                          
    64                                  ;; Not sure why this delay is necessary, but it is.
    65                                  ;; Maybe restoring SD card IO registers causes it to go busy for a while?
    66  86b6 20b8a1                     jsr sd_wait_for_ready_reset_if_required
    67                          
    68  86b9 20be88                     jsr unfreeze_load_region
    69                          
    70                                  ;; Re-enable M65 IO in case we wrote over the key register during the region unfreeze
    71                                  ;; NOTE: This usage was re-instated after deleting it cause exiting the freeze-menu to
    72                                  ;; either stall in BASIC (in an endless loop awaiting for the sd-card to be ready) for
    73                                  ;; some users, or causing DIR to return 'Drive not ready' for other users.
    74                                  ;; The exact reason behind the impact of its removal isn't known and warrants further
    75                                  ;; investigation at some stage. See this past Discord thread for more details:
    76                                  ;; https://discord.com/channels/719326990221574164/791383472853614593/982994187681161278
    77  86bc a947                       lda #$47
    78  86be 8d2fd0                     sta $d02f
    79  86c1 a953                       lda #$53
    80  86c3 8d2fd0                     sta $d02f
    81                          
    82  86c6 8a                         txa
    83  86c7 18                         clc
    84  86c8 6908                       adc #$08
    85  86ca aa                         tax
    86  86cb bd5f8b                     lda freeze_mem_list+7,x
    87  86ce c9ff                       cmp #$ff
    88  86d0 d0e4                       bne unfreeze_next_region
    89                          
    90                                  ;; Fix mounted D81, in case it has moved on the SD card since program was frozen
    91                          
    92                                  ;; 1a. Check image0 flags
    93                                  ; first we check if we should mount
    94  86d2 ad11bd                     lda currenttask_d81_image0_flags
    95  86d5 8901                       bit #d81_image_flag_mounted
    96  86d7 d00d                       bne @attach_image0
    97                          
    98                                  ;; 2a. Detach image0, probably not attaching the real drive
    99                          @detach_image0:
   100  86d9 a280                       ldx #%10000000
   101                                  ; check for real drive attach, currenttask_d81_image0_flags is still loaded
   102  86db 8940                       bit #d81_image_flag_noreal
   103  86dd f002                       beq @detach_image0_call
   104  86df a2c0                       ldx #%11000000          ; FLAG_NOREAL set
   105                          
   106                          @detach_image0_call:
   107  86e1 20019c                     jsr dos_attach
   108  86e4 8020                       bra handle_drive1
   109                          
   110                                  ;; 3a. Copy filename for image 0 (emulating dos_setname)
   111                          @attach_image0:
   112                                  ; if we got no namelen, we detach instead!
   113                                  ; (second level security, if flags set incorrectly)
   114  86e6 ae13bd                     ldx currenttask_d81_image0_namelen
   115  86e9 f0ee                       beq @detach_image0
   116  86eb a200                       ldx #0
   117  86ed bd15bd             -       lda currenttask_d81_image0_name,x
   118  86f0 9d68bc                     sta dos_requested_filename,x
   119  86f3 e8                         inx
   120  86f4 ec13bd                     cpx currenttask_d81_image0_namelen
   121  86f7 d0f4                       bne -
   122  86f9 a900                       lda #0
   123  86fb 9d68bc                     sta dos_requested_filename,x
   124  86fe 8e67bc                     stx dos_requested_filename_len
   125                          
   126                                  ;; 4a. Try to reattach it
   127  8701 a200                       ldx #$00
   128  8703 20019c                     jsr dos_attach
   129                          
   130                          handle_drive1:
   131                                  ;; 1b. Check image1 flags
   132                                  ; first we check if we should mount
   133  8706 ad12bd                     lda currenttask_d81_image1_flags
   134  8709 8901                       bit #d81_image_flag_mounted
   135  870b d00d                       bne @attach_image1
   136                          
   137                                  ;; 2b. Detach image1, probably not attaching the real drive
   138                          @detach_image1:
   139  870d a281                       ldx #%10000001
   140                                  ; check for real drive attach, currenttask_d81_image1_flags is still loaded
   141  870f 8940                       bit #d81_image_flag_noreal
   142  8711 f002                       beq @detach_image1_call
   143  8713 a2c1                       ldx #%11000001          ; FLAG_NOREAL set
   144                          
   145                          @detach_image1_call:
   146  8715 20019c                     jsr dos_attach
   147  8718 8020                       bra @attach_done
   148                          
   149                          @attach_image1:
   150                                  ;; 3b. Copy filename for image 1 (emulating dos_setname)
   151  871a ae14bd                     ldx currenttask_d81_image1_namelen
   152  871d f01b                       beq @attach_done
   153  871f a200                       ldx #0
   154  8721 bd35bd             -       lda currenttask_d81_image1_name,x
   155  8724 9d68bc                     sta dos_requested_filename,x
   156  8727 e8                         inx
   157  8728 ec14bd                     cpx currenttask_d81_image1_namelen
   158  872b d0f4                       bne -
   159  872d a900                       lda #0
   160  872f 9d68bc                     sta dos_requested_filename,x
   161  8732 8e67bc                     stx dos_requested_filename_len
   162                          
   163                                  ;; 4. Try to reattach it
   164  8735 a201                       ldx #$01
   165  8737 20019c                     jsr dos_attach
   166                          
   167                          @attach_done:
   168                          
   169                                  ;; Turn SID volume registers back on, as those registers
   170                                  ;; cannot be frozen.
   171  873a a90f                       lda #$0f
   172  873c 8d18d4                     sta $D418
   173  873f 8d38d4             	sta $D438
   174  8742 8d58d4                     sta $D458
   175  8745 8d78d4             	sta $D478
   176                          
   177  8748 60                         rts
   178                          
   179                          unfreeze_read_sector_and_wait:
   180                          
   181                          
   182                          ;;         jsr debug_show_sector
   183                          
   184                          @retryRead:
   185  8749 20b8a1                     jsr sd_wait_for_ready_reset_if_required
   186                          
   187  874c a902                       lda #$02
   188  874e 8d80d6                     sta $d680
   189                          
   190  8751 20afa1                     jsr sd_wait_for_ready
   191  8754 90f3                       bcc @retryRead
   192                          
   193                                  ;; Read succeeded, so advance sector number, and return
   194                                  ;; success
   195                          
   196                                  ;; Increment freeze slot sector number
   197  8756 206fa2                     jsr sd_inc_sectornumber
   198                          
   199  8759 38                         sec
   200                          
   201  875a 60                         rts
   202                          
   203                          freeze_write_first_sector_and_wait:
   204                          
   205  875b ee20d0                     inc $d020
   206                          
   207                                  ;; Require SHIFT press and release between every sector for debug
   208                          ;;         jsr wait_on_shift_key
   209                          
   210  875e a900                       lda #$00
   211  8760 8dc687                     sta freeze_write_tries+0
   212  8763 8dc787                     sta freeze_write_tries+1
   213                          
   214                          @retryWrite1:
   215                          
   216  8766 20b8a1                     jsr sd_wait_for_ready_reset_if_required
   217                          
   218                                  ;; Trigger the write of the first sector of a multi-sector write
   219  8769 2098a1             	jsr sd_open_write_gate
   220  876c a904                       lda #$04
   221  876e 8d80d6                     sta $d680
   222                          
   223  8771 20afa1                     jsr sd_wait_for_ready
   224  8774 4c8187                     jmp @wroteOk1
   225                          
   226  8777 eec687                     inc freeze_write_tries+0
   227  877a d0ea                       bne @retryWrite1
   228  877c eec787                     inc freeze_write_tries+1
   229  877f d0e5                       bne @retryWrite1
   230                          
   231                          @wroteOk1:
   232  8781 ce20d0                     dec $d020
   233                          
   234                                  ;; Increment freeze slot sector number
   235  8784 206fa2                     jsr sd_inc_sectornumber
   236                          
   237  8787 38                         sec
   238  8788 60                         rts
   239                          
   240                          freeze_write_sector_and_wait:
   241                          
   242  8789 ee20d0                     inc $d020
   243                          
   244                                  ;; Require SHIFT press and release between every sector for debug
   245                          ;;         jsr wait_on_shift_key
   246                          
   247  878c a900                       lda #$00
   248  878e 8dc687                     sta freeze_write_tries+0
   249  8791 8dc787                     sta freeze_write_tries+1
   250                          
   251                          @retryWrite:
   252                          
   253  8794 20b8a1                     jsr sd_wait_for_ready_reset_if_required
   254                          
   255                                  ;; Trigger the write (subsequent sector of multi-sector write)
   256  8797 2098a1             	jsr sd_open_write_gate
   257  879a a905                       lda #$05
   258  879c 8d80d6                     sta $d680
   259                          
   260  879f 20afa1                     jsr sd_wait_for_ready
   261  87a2 4caf87                     jmp @wroteOk
   262                          
   263  87a5 eec687                     inc freeze_write_tries+0
   264  87a8 d0ea                       bne @retryWrite
   265  87aa eec787                     inc freeze_write_tries+1
   266  87ad d0e5                       bne @retryWrite
   267                          
   268                          @wroteOk:
   269  87af ce20d0                     dec $d020
   270                          
   271                                  ;; Increment freeze slot sector number
   272  87b2 206fa2                     jsr sd_inc_sectornumber
   273                          
   274  87b5 38                         sec
   275  87b6 60                         rts
   276                          
   277                          freeze_end_multi_block_write:
   278  87b7 20afa1                     jsr sd_wait_for_ready
   279  87ba 2098a1             	jsr sd_open_write_gate
   280  87bd a906                       lda #$06
   281  87bf 8d80d6                     sta $d680
   282  87c2 20afa1                     jsr sd_wait_for_ready
   283  87c5 60                         rts
   284                          
   285                          freeze_write_tries:
   286  87c6 0000                       !16 $0
   287                          
   288                          freeze_save_region:
   289                                  ;; X = offset into freeze_mem_list
   290                          
   291                                  ;; Check if end of list, if so, do nothing and return
   292  87c8 bd5f8b                     lda freeze_mem_list+7,x
   293  87cb c9ff                       cmp #$ff
   294  87cd d001                       bne fsr1
   295  87cf 60                         rts
   296                          fsr1:
   297                          
   298                                  ;; Call setup routine to make any special preparations
   299                                  ;; (eg copying data out of non-memory mapped areas, or collecting
   300                                  ;; various groups of data together)
   301  87d0 da                         phx
   302  87d1 aa                         tax
   303  87d2 207e89                     jsr dispatch_freeze_prep
   304  87d5 fa                         plx
   305                          
   306                                  ;; Get address of region
   307  87d6 bd588b                     lda freeze_mem_list+0,x
   308  87d9 8d018b                     sta freeze_region_dmalist_source_start+0
   309  87dc bd598b                     lda freeze_mem_list+1,x
   310  87df 8d028b                     sta freeze_region_dmalist_source_start+1
   311                          
   312                                  ;; Source address is 32-bit, and we need bits 20-27
   313                                  ;; for the source MB (upper 4 bits are ignored)
   314  87e2 bd5a8b                     lda freeze_mem_list+2,x
   315  87e5 4a                         lsr
   316  87e6 4a                         lsr
   317  87e7 4a                         lsr
   318  87e8 4a                         lsr
   319  87e9 8dfa8a                     sta freeze_region_dmalist_source_mb
   320  87ec bd5b8b                     lda freeze_mem_list+3,x
   321  87ef 0a                         asl
   322  87f0 0a                         asl
   323  87f1 0a                         asl
   324  87f2 0a                         asl
   325  87f3 0dfa8a                     ora freeze_region_dmalist_source_mb
   326  87f6 8dfa8a                     sta freeze_region_dmalist_source_mb
   327                          
   328                                  ;; Bank is a bit fiddly: Lower nybl is bits
   329                                  ;; 16-19 of address.  Then we have to add the IO flag
   330                                  ;; The IO flag is used if the source MB value = $FF.
   331                                  ;; However, because we use 28-bit addresses for everything
   332                                  ;; the IO bit should be zero, as should the other special
   333                                  ;; bits.
   334                          
   335  87f9 bd5a8b                     lda freeze_mem_list+2,X
   336  87fc 290f                       and #$0f
   337  87fe 8d038b                     sta freeze_region_dmalist_source_bank
   338                          
   339                                  ;; At this point, we have the DMA list source setup.
   340                          
   341                                  ;; Point the destination to the SD card direct job
   342                                  ;; sector buffer ($FFD6E00).
   343  8801 a900                       lda #$00
   344  8803 8d048b                     sta freeze_region_dmalist_dest_start+0
   345  8806 a96e                       lda #$6E
   346  8808 8d058b                     sta freeze_region_dmalist_dest_start+1
   347  880b a90d                       lda #$0D
   348  880d 8d068b                     sta freeze_region_dmalist_dest_bank
   349  8810 a9ff                       lda #$ff
   350  8812 8dfc8a                     sta freeze_region_dmalist_dest_mb
   351                          
   352                                  ;; Now DMA source and destination addresses have been set
   353                                  ;; We now need to step through the region $200 bytes at a
   354                                  ;; time, until there are no bytes left.
   355                                  ;; If the length is $0000 initially, then it means 64KB.
   356                                  ;; The tricky bit is for regions <$200 bytes long, as we need
   357                                  ;; to make sure we don't copy more than we should (it could
   358                                  ;; be from Hypervisor memory, for example, or to some
   359                                  ;; important IO registers, such as the Hypervisor enter/exit
   360                                  ;; trap).
   361                          
   362                                  ;; Get length of region
   363  8815 bd5c8b                     lda freeze_mem_list+4,x
   364  8818 8d008c                     sta freeze_dma_length_remaining+0
   365  881b bd5d8b                     lda freeze_mem_list+5,x
   366  881e 8d018c                     sta freeze_dma_length_remaining+1
   367  8821 bd5e8b                     lda freeze_mem_list+6,x
   368  8824 297f                       and #$7f                              ;; mask out bottom 7 bits, since bit 7 indicates if a region should be skipped in unfreezing
   369  8826 8d028c                     sta freeze_dma_length_remaining+2
   370                          
   371                          freeze_region_dma_loop:
   372                          
   373  8829 209c88                     jsr set_dma_length_based_on_freeze_dma_length_remaining
   374                          
   375                                  ;; Then make sure that there are still bytes to copy.
   376                                  ;; If not, then we are done with this block.
   377  882c 0d008c                     ora freeze_dma_length_remaining+0
   378  882f 0d028c                     ora freeze_dma_length_remaining+2
   379  8832 f03c                       beq freeze_region_dma_done
   380                          
   381                          @freezeExecuteDMA:
   382                          
   383                                  ;; Execute DMA job
   384  8834 a9ff                       lda #$ff
   385  8836 8d02d7                     sta $d702
   386  8839 8d04d7                     sta $d704
   387  883c a98a                       lda #>freeze_region_dmalist
   388  883e 8d01d7                     sta $d701
   389  8841 a9f8                       lda #<freeze_region_dmalist
   390  8843 8d05d7                     sta $d705
   391                          
   392                                  ;; Write SD-card direct sector buffer to freeze slot
   393                                  ;; Flash a different colour while actually writing sector
   394  8846 ee20d0                     inc $d020
   395                          
   396  8849 208987                     jsr freeze_write_sector_and_wait
   397                          
   398  884c ce20d0                     dec $d020
   399                          
   400                                  ;; Check if remaining length is negative or zero. If so, stop
   401  884f 207188                     jsr is_freeze_dma_length_remaining_zero_or_negative
   402  8852 f01c                       beq freeze_region_dma_done
   403                          
   404                                  ;; DMA count is set, subtract from remaining length
   405  8854 208088                     jsr subtract_freeze_dma_size_from_length_remaining
   406                          
   407  8857 207188                     jsr is_freeze_dma_length_remaining_zero_or_negative
   408  885a f014                       beq freeze_region_dma_done
   409                          
   410                                  ;; advance source address
   411  885c ad028b                     lda freeze_region_dmalist_source_start+1
   412  885f 18                         clc
   413  8860 6902                       adc #$02
   414  8862 8d028b                     sta freeze_region_dmalist_source_start+1
   415  8865 ad038b                     lda freeze_region_dmalist_source_bank
   416  8868 6900                       adc #$00
   417  886a 8d038b                     sta freeze_region_dmalist_source_bank
   418                          
   419  886d 4c2988                     jmp freeze_region_dma_loop
   420                          
   421                          freeze_region_dma_done:
   422  8870 60                         rts
   423                          
   424                          is_freeze_dma_length_remaining_zero_or_negative:
   425  8871 ad028c                     lda freeze_dma_length_remaining+2
   426  8874 3007                       bmi @negativeSize
   427  8876 0d018c                     ora freeze_dma_length_remaining+1
   428  8879 0d008c                     ora freeze_dma_length_remaining+0
   429  887c 60                         rts
   430                          @negativeSize:
   431  887d a900                       lda #$00
   432  887f 60                         rts
   433                          
   434                          subtract_freeze_dma_size_from_length_remaining:
   435  8880 38                         sec
   436  8881 ad008c                     lda freeze_dma_length_remaining+0
   437  8884 edff8a                     sbc freeze_region_dmalist_count+0
   438  8887 8d008c                     sta freeze_dma_length_remaining+0
   439  888a ad018c                     lda freeze_dma_length_remaining+1
   440  888d ed008b                     sbc freeze_region_dmalist_count+1
   441  8890 8d018c                     sta freeze_dma_length_remaining+1
   442  8893 ad028c                     lda freeze_dma_length_remaining+2
   443  8896 e900                       sbc #$00
   444  8898 8d028c                     sta freeze_dma_length_remaining+2
   445  889b 60                         rts
   446                          
   447                          set_dma_length_based_on_freeze_dma_length_remaining:
   448  889c ad018c                     lda freeze_dma_length_remaining+1
   449  889f 29fe                       and #$fe
   450  88a1 0d028c                     ora freeze_dma_length_remaining+2
   451  88a4 f00b                       beq @isPartialSector
   452                          
   453                                  ;; At least a whole sector remains
   454  88a6 a900                       lda #$00
   455  88a8 8dff8a                     sta freeze_region_dmalist_count+0
   456  88ab a902                       lda #$02
   457  88ad 8d008b                     sta freeze_region_dmalist_count+1
   458  88b0 60                         rts
   459                          
   460                          @isPartialSector:
   461                                  ;; Set DMA size to remaining bytes
   462  88b1 ad008c                     lda freeze_dma_length_remaining+0
   463  88b4 8dff8a                     sta freeze_region_dmalist_count+0
   464  88b7 ad018c                     lda freeze_dma_length_remaining+1
   465  88ba 8d008b                     sta freeze_region_dmalist_count+1
   466  88bd 60                         rts
   467                          
   468                          unfreeze_load_region:
   469                                  ;; X = offset into freeze_mem_list
   470                          
   471                                  ;; Check if end of list, if so, do nothing and return
   472  88be bd5f8b                     lda freeze_mem_list+7,x
   473  88c1 c9ff                       cmp #$ff
   474  88c3 f004                       beq @dontUnfreeze
   475                                  ;; If it is the thumbnail, also don't unfreeze, as it doesn't make sense,
   476                                  ;; and the way we freeze the thumbnail means unfreezing would corrupt $1000-$1FFF
   477  88c5 c50c                       cmp freeze_prep_thumbnail
   478  88c7 d001                       bne @doUnfreeze
   479                          @dontUnfreeze:
   480  88c9 60                         rts
   481                          @doUnfreeze:
   482                          
   483                                  ;; Call setup routine to make any special preparations
   484                                  ;; (eg copying data out of non-memory mapped areas, or collecting
   485                                  ;; various groups of data together)
   486  88ca da                         phx
   487  88cb aa                         tax
   488  88cc 208189                     jsr dispatch_unfreeze_prep
   489  88cf fa                         plx
   490                          
   491                                  ;; Get address of region
   492  88d0 bd588b                     lda freeze_mem_list+0,x
   493  88d3 8d048b                     sta freeze_region_dmalist_dest_start+0
   494  88d6 bd598b                     lda freeze_mem_list+1,x
   495  88d9 8d058b                     sta freeze_region_dmalist_dest_start+1
   496                          
   497                                  ;; Source address is 32-bit, and we need bits 20-27
   498                                  ;; for the source MB (upper 4 bits are ignored)
   499  88dc bd5a8b                     lda freeze_mem_list+2,x
   500  88df 4a                         lsr
   501  88e0 4a                         lsr
   502  88e1 4a                         lsr
   503  88e2 4a                         lsr
   504  88e3 8dfc8a                     sta freeze_region_dmalist_dest_mb
   505  88e6 bd5b8b                     lda freeze_mem_list+3,x
   506  88e9 0a                         asl
   507  88ea 0a                         asl
   508  88eb 0a                         asl
   509  88ec 0a                         asl
   510  88ed 0dfc8a                     ora freeze_region_dmalist_dest_mb
   511  88f0 8dfc8a                     sta freeze_region_dmalist_dest_mb
   512                          
   513                                  ;; Bank is a bit fiddly: Lower nybl is bits
   514                                  ;; 16-19 of address.  Then we have to add the IO flag
   515                                  ;; The IO flag is used if the source MB value = $FF.
   516                                  ;; However, because we use 28-bit addresses for everything
   517                                  ;; the IO bit should be zero, as should the other special
   518                                  ;; bits.
   519                          
   520  88f3 bd5a8b                     lda freeze_mem_list+2,X
   521  88f6 290f                       and #$0f
   522  88f8 8d068b                     sta freeze_region_dmalist_dest_bank
   523                          
   524                                  ;; At this point, we have the DMA list source setup.
   525                          
   526                                  ;; Point the source to the SD card direct job
   527                                  ;; sector buffer ($FFD6E00).
   528  88fb a900                       lda #$00
   529  88fd 8d018b                     sta freeze_region_dmalist_source_start+0
   530  8900 a96e                       lda #$6E
   531  8902 8d028b                     sta freeze_region_dmalist_source_start+1
   532  8905 a90d                       lda #$0D
   533  8907 8d038b                     sta freeze_region_dmalist_source_bank
   534  890a a9ff                       lda #$ff
   535  890c 8dfa8a                     sta freeze_region_dmalist_source_mb
   536                          
   537                                  ;; Now DMA source and destination addresses have been set
   538                                  ;; We now need to step through the region $200 bytes at a
   539                                  ;; time, until there are no bytes left.
   540                                  ;; If the length is $0000 initially, then it means 64KB.
   541                                  ;; The tricky bit is for regions <$200 bytes long, as we need
   542                                  ;; to make sure we don't copy more than we should (it could
   543                                  ;; be from Hypervisor memory, for example, or to some
   544                                  ;; important IO registers, such as the Hypervisor enter/exit
   545                                  ;; trap).
   546                          
   547                                  ;; Get length of region
   548  890f bd5c8b                     lda freeze_mem_list+4,x
   549  8912 8d008c                     sta freeze_dma_length_remaining+0
   550  8915 bd5d8b                     lda freeze_mem_list+5,x
   551  8918 8d018c                     sta freeze_dma_length_remaining+1
   552  891b bd5e8b                     lda freeze_mem_list+6,x
   553  891e 8d038c                     sta unfreeze_skip
   554  8921 297f                       and #$7f                              ;; mask out bottom 7 bits, since bit 7 indicates if a region should be skipped in unfreezing
   555  8923 8d028c                     sta freeze_dma_length_remaining+2
   556                          
   557                          unfreeze_region_dma_loop:
   558                          
   559                                  ;; Write SD-card direct sector buffer to freeze slot
   560                                  ;; Flash a different colour while actually writing sector
   561  8926 ee20d0                     inc $d020
   562                          
   563  8929 204987                     jsr unfreeze_read_sector_and_wait
   564                          
   565  892c ce20d0                     dec $d020
   566                          
   567  892f 209c88                     jsr set_dma_length_based_on_freeze_dma_length_remaining
   568                          
   569                                  ;; Then make sure that there are still bytes to copy.
   570                                  ;; If not, then we are done with this block.
   571  8932 0d008c                     ora freeze_dma_length_remaining+0
   572  8935 0d028c                     ora freeze_dma_length_remaining+2
   573  8938 f038                       beq unfreeze_region_dma_done
   574                          
   575  893a 2c038c                     bit unfreeze_skip
   576  893d 3012                       bmi @skipDMA
   577                          
   578                          @unfreezeExecuteDMA:
   579                                  ;; Execute DMA job
   580  893f a9ff                       lda #$ff
   581  8941 8d02d7                     sta $d702
   582  8944 8d04d7                     sta $d704
   583  8947 a98a                       lda #>freeze_region_dmalist
   584  8949 8d01d7                     sta $d701
   585  894c a9f8                       lda #<freeze_region_dmalist
   586  894e 8d05d7                     sta $d705
   587                          
   588                          @skipDMA:
   589                                  ;; Check if remaining length is negative or zero. If so, stop
   590  8951 207188                     jsr is_freeze_dma_length_remaining_zero_or_negative
   591  8954 f01c                       beq unfreeze_region_dma_done
   592                          
   593                                  ;; DMA count is set, subtract from remaining length
   594  8956 208088                     jsr subtract_freeze_dma_size_from_length_remaining
   595                          
   596  8959 207188                     jsr is_freeze_dma_length_remaining_zero_or_negative
   597  895c f014                       beq unfreeze_region_dma_done
   598                          
   599                                  ;; advance destination address
   600  895e ad058b                     lda freeze_region_dmalist_dest_start+1
   601  8961 18                         clc
   602  8962 6902                       adc #$02
   603  8964 8d058b                     sta freeze_region_dmalist_dest_start+1
   604  8967 ad068b                     lda freeze_region_dmalist_dest_bank
   605  896a 6900                       adc #$00
   606  896c 8d068b                     sta freeze_region_dmalist_dest_bank
   607                          
   608  896f 4c2689                     jmp unfreeze_region_dma_loop
   609                          
   610                          unfreeze_region_dma_done:
   611                          
   612                                  ;; Call postfix routine for the region just loaded
   613  8972 da                         phx
   614  8973 48                 	pha
   615                          
   616  8974 bd5f8b                     lda freeze_mem_list+7,x
   617  8977 aa                         tax
   618  8978 208489                     jsr dispatch_unfreeze_post
   619                          
   620  897b 68                 	pla
   621  897c fa                         plx
   622                          
   623                          
   624  897d 60                         rts
   625                          
   626                          
   627                          dispatch_freeze_prep:
   628                                  ;; X = Freeze prep ID byte
   629                                  ;; (all of which are even, so that we can use an indirect
   630                                  ;; X indexed jump table to efficiently do the dispatch)
   631                          
   632  897e 7c518a                     jmp (freeze_prep_jump_table,x)
   633                          
   634                          dispatch_unfreeze_prep:
   635                                  ;; X = Freeze prep ID byte
   636                                  ;; (all of which are even, so that we can use an indirect
   637                                  ;; X indexed jump table to efficiently do the dispatch)
   638                          
   639  8981 7c658a                     jmp (unfreeze_prep_jump_table,x)
   640                          
   641                          dispatch_unfreeze_post:
   642                                  ;; X = Freeze prep ID byte
   643                                  ;; (all of which are even, so that we can use an indirect
   644                                  ;; X indexed jump table to efficiently do the dispatch)
   645                          
   646  8984 7c798a                     jmp (unfreeze_post_jump_table,x)
   647                          
   648                          do_unfreeze_post_restore_sd_buffer_and_regs:
   649                                  ;; Copy back the registers from $D680 - $D70F *excluding*
   650                                  ;; $D700 and $D705 (which would trigger a DMA)
   651                                  ;; $D680 (which could trigger an SD read or write)
   652                          
   653                                  ;; The data should have been put for us at $FFD6200-$FFD628F
   654                                  ;; The contents of the SD sector buffer for restoration should
   655                                  ;; be at $FFD6000-$FFD61FF
   656                          
   657  8987 a900                       lda #<$6200
   658  8989 8500                       sta <dos_scratch_vector+0
   659  898b a962                       lda #>$6200
   660  898d 8501                       sta <dos_scratch_vector+1
   661  898f a9fd                       lda #<$0FFD
   662  8991 8502                       sta <dos_scratch_vector+2
   663  8993 a90f                       lda #>$0FFD
   664  8995 8503                       sta <dos_scratch_vector+3
   665                          
   666                                  ;; Copy $D680 - $D70F, which covers both regions of interest
   667  8997 a38f                       ldz #$8F
   668  8999 6b                 @zz2:   tza
   669  899a aa                         tax
   670  899b eab200                     lda [<dos_scratch_vector],z
   671  899e e000                       cpx #$00  ;; $D680
   672  89a0 f00b                       beq @dontWriteHotRegister
   673  89a2 e080                       cpx #$80  ;; $D700
   674  89a4 f007                       beq @dontWriteHotRegister
   675  89a6 e085                       cpx #$85  ;; $D705
   676  89a8 f003                       beq @dontWriteHotRegister
   677                          
   678  89aa 9d80d6                     sta $d680,x
   679                          
   680                          @dontWriteHotRegister:
   681  89ad ca                         dex
   682  89ae 3b                         dez
   683  89af c2ff                       cpz #$ff
   684  89b1 d0e6                       bne @zz2
   685  89b3 a300                       ldz #$00
   686                          
   687                          do_unfreeze_prep_restore_sd_buffer_and_regs:
   688                                  ;; But there is nothing we need to do in preparation to unfreezing
   689                                  ;; such a region, so just tie it to an RTS
   690  89b5 60                         rts
   691                          
   692                          do_freeze_prep_thumbnail:
   693                                  ;; Read the 4KB hardware thumbnail from $D640 and write it to $1000-$1FFF
   694                                  ;; We can in principle use a fixed-source DMA to do this.
   695                          
   696                                  ;; set up our pointer for writing
   697  89b6 a900                       lda #<$1000
   698  89b8 8500                       sta <dos_scratch_vector+0
   699  89ba a910                       lda #>$1000
   700  89bc 8501                       sta <dos_scratch_vector+1
   701  89be a000                       ldy #$00
   702  89c0 a210                       ldx #$10
   703                          
   704                                  ;; Set pointer to $FFD2640 to access thumbnail generator.
   705                                  ;; This is because the thumbnail generator lives at $D640 which overlaps
   706                                  ;; with the hypervisor trap registers when in hypervisor mode.
   707                                  ;; We previously had the thumbnail generator mapped at $D63x, but that
   708                                  ;; was causing CS glitching that was messing up reading from the C65 UART
   709                                  ;; registers.  So now we have moved it to this magic space
   710  89c2 a940                       lda #<$2640
   711  89c4 8d10bf                     sta zptempv32+0
   712  89c7 a926                       lda #>$2640
   713  89c9 8d11bf                     sta zptempv32+1
   714  89cc a9fd                       lda #<$0FFD
   715  89ce 8d12bf                     sta zptempv32+2
   716  89d1 a90f                       lda #>$0FFD
   717  89d3 8d13bf                     sta zptempv32+3
   718                          
   719                                  ;; First, make sure the read pointer is at the start of the thumbnail
   720  89d6 a300                       ldz #$00
   721                                  ;; Then advance pointer address to $D641
   722  89d8 eab210                     lda [<zptempv32],z
   723  89db a941                       lda #<$2641
   724  89dd 8d10bf                     sta zptempv32+0
   725                          
   726                          @thumbfetchloop:
   727  89e0 eab210                     lda [<zptempv32],z
   728  89e3 9100                       sta (<dos_scratch_vector),y
   729  89e5 c8                         iny
   730  89e6 d0f8                       bne @thumbfetchloop
   731  89e8 e601                       inc <dos_scratch_vector+1
   732  89ea ca                         dex
   733  89eb d0f3                       bne @thumbfetchloop
   734                          
   735  89ed 60                         rts
   736                          
   737                          do_freeze_prep_stash_sd_buffer_and_regs:
   738                                  ;; Stash the SD and DMAgic registers we use to actually save
   739                                  ;; the machine state.
   740                                  ;; DMAgic registers have to get copied without using DMA, so
   741                                  ;; that we don't corrupt the registers.
   742  89ee a900                       lda #<$6200
   743  89f0 8500                       sta <dos_scratch_vector+0
   744  89f2 a962                       lda #>$6200
   745  89f4 8501                       sta <dos_scratch_vector+1
   746  89f6 a9fd                       lda #<$0ffd
   747  89f8 8502                       sta <dos_scratch_vector+2
   748  89fa a90f                       lda #>$0ffd
   749  89fc 8503                       sta <dos_scratch_vector+3
   750                          
   751                                  ;; Copy $D680 - $D70F, which covers both regions of interest
   752  89fe a38f                       ldz #$8f
   753  8a00 6b                 @zz:    tza
   754  8a01 aa                         tax
   755  8a02 bd80d6                     lda $d680,x
   756  8a05 ea9200                     sta [<dos_scratch_vector],z
   757  8a08 ca                         dex
   758  8a09 3b                         dez
   759  8a0a c2ff                       cpz #$ff
   760  8a0c d0f2                       bne @zz
   761  8a0e a300                       ldz #$00
   762                          
   763                                  ;; Now DMA copy the SD sector buffer from $FFD6e00 to
   764                                  ;; $FFD6000.
   765                                  ;; XXX Replace this (And the above!) with a fixed DMA list. It will be shorter and faster
   766  8a10 a9ff                       lda #$ff
   767  8a12 8dfa8a                     sta freeze_region_dmalist_source_mb
   768  8a15 8dfc8a                     sta freeze_region_dmalist_dest_mb
   769  8a18 a98d                       lda #$8d
   770  8a1a 8d038b                     sta freeze_region_dmalist_source_bank
   771  8a1d 8d068b                     sta freeze_region_dmalist_dest_bank
   772  8a20 a900                       lda #<$6e00
   773  8a22 8d018b                     sta freeze_region_dmalist_source_start+0
   774  8a25 a96e                       lda #>$6e00
   775  8a27 8d028b                     sta freeze_region_dmalist_source_start+1
   776  8a2a a900                       lda #<$6000
   777  8a2c 8d048b                     sta freeze_region_dmalist_dest_start+0
   778  8a2f a960                       lda #>$6000
   779  8a31 8d058b                     sta freeze_region_dmalist_dest_start+1
   780  8a34 a900                       lda #<$0200
   781  8a36 8dff8a                     sta freeze_region_dmalist_count+0
   782  8a39 a902                       lda #>$0200
   783  8a3b 8d008b                     sta freeze_region_dmalist_count+1
   784                          
   785                                  ;; Execute DMA job
   786  8a3e a9ff                       lda #$ff
   787  8a40 8d02d7                     sta $d702
   788  8a43 8d04d7                     sta $d704
   789  8a46 a98a                       lda #>freeze_region_dmalist
   790  8a48 8d01d7                     sta $d701
   791  8a4b a9f8                       lda #<freeze_region_dmalist
   792  8a4d 8d05d7                     sta $d705
   793                          
   794                          do_freeze_prep_none:
   795  8a50 60                         rts
   796                          
   797                          ;; Jump table of routines to be called before saving specific regions
   798                          freeze_prep_jump_table:
   799  8a51 508a                       !16 do_freeze_prep_none
   800  8a53 098b                       !16 do_freeze_prep_palette_select
   801  8a55 098b                       !16 do_freeze_prep_palette_select
   802  8a57 098b                       !16 do_freeze_prep_palette_select
   803  8a59 098b                       !16 do_freeze_prep_palette_select
   804  8a5b ee89                       !16 do_freeze_prep_stash_sd_buffer_and_regs
   805  8a5d 508a                       !16 do_freeze_prep_none
   806  8a5f f18a                       !16 do_freeze_prep_viciv
   807  8a61 508a               	!16 do_freeze_prep_none
   808  8a63 508a               	!16 do_freeze_prep_none
   809                          
   810                          ;; Jump table of routines to be called before restoring specific regions
   811                          ;; (the same region list is used for freeze and unfreeze, so the jump
   812                          ;; tables for unfreezing mirror those used during freezing. The only difference
   813                          ;; is we require two sets of jump tables for unfreezing, as sometimes we have
   814                          ;; to prepare the memory map before restoring, and sometimes we have to move
   815                          ;; the restored data to the correct place in memory after restoration.
   816                          unfreeze_prep_jump_table:
   817                                  ;; SD card buffer and regs get restored in post routine
   818  8a65 8d8a                       !16 do_unfreeze_prep_none
   819  8a67 098b                       !16 do_unfreeze_prep_palette_select
   820  8a69 098b                       !16 do_unfreeze_prep_palette_select
   821  8a6b 098b                       !16 do_unfreeze_prep_palette_select
   822  8a6d 098b                       !16 do_unfreeze_prep_palette_select
   823                                  ;; SD card buffer and regs get restored in post routine
   824  8a6f 8d8a                       !16 do_unfreeze_prep_none
   825                                  ;; thumbnail doesn't get restored at all
   826  8a71 8d8a                       !16 do_unfreeze_prep_none
   827                                  ;; VIC-IV regs need nothing special before unfreezing
   828  8a73 8d8a                       !16 do_unfreeze_prep_none
   829                          	;; No prior preparation required for handling hyperregs
   830  8a75 8d8a               	!16 do_unfreeze_prep_none
   831                          	;; Nothing required before restoring CHAR ROM
   832  8a77 8d8a               	!16 do_unfreeze_prep_none
   833                          
   834                          unfreeze_post_jump_table:
   835  8a79 8e8a                       !16 do_unfreeze_post_scratch_to_sdcard_regs
   836  8a7b 8d8a                       !16 do_unfreeze_post_none
   837  8a7d 8d8a                       !16 do_unfreeze_post_none
   838  8a7f 8d8a                       !16 do_unfreeze_post_none
   839  8a81 8d8a                       !16 do_unfreeze_post_none
   840                                  ;; Don't actually restore the SD card registers until the very end.
   841                                  ;; For a start, it will result in totally the wrong SD sector address being there
   842                                  ;; when we go to read the next sector!
   843                          ;;         !16 do_unfreeze_post_restore_sd_buffer_and_regs
   844  8a83 8d8a                       !16 do_unfreeze_post_none
   845  8a85 8d8a                       !16 do_unfreeze_post_none
   846  8a87 8d8a                       !16 do_unfreeze_post_none
   847                          	;; No prior preparation required for handling hyperregs
   848  8a89 a78a               	!16 do_unfreeze_post_hyperregs
   849                          	;; Nothing required after restoring CHAR ROM
   850  8a8b 8d8a               	!16 do_unfreeze_post_none
   851                          
   852                          do_unfreeze_prep_none:
   853                          do_unfreeze_post_none:
   854                                  ;; This just needs to have an RTS, so we use one from the end of this
   855                                  ;; routine.
   856  8a8d 60                         rts
   857                          
   858                          do_unfreeze_post_scratch_to_sdcard_regs:
   859                                  ;; Check that we have a version, then only copy stuff we actually saved for
   860                                  ;; that version.
   861  8a8e a200                       ldx #0
   862  8a90 bdec8a             -       lda freeze_version,x
   863  8a93 ddd88a                     cmp version_sentinel,x
   864  8a96 d00e                       bne @rts  ; pre-versioned or corrupt freeze
   865  8a98 e8                         inx
   866  8a99 e003                       cpx #len(version_sentinel_str)
   867  8a9b d0f3                       bne -
   868                          
   869                                  ;; Version sentinal checks out
   870  8a9d bcec8a                     ldy freeze_version,x  ; actual version of this freeze
   871                                  ;; when there are future versions this code would look like:
   872                          ;;        cpy #3
   873                          ;;        bne +
   874                          ;;        ;; Do stuff added for version 3 and skip over next cmp
   875                          ;;        lda freeze_blah
   876                          ;;        sta $XXXX
   877                          ;;        dey
   878                          ;;+       cpy #2
   879                          ;;        bne +
   880                          ;;        lda freeze_blerg
   881                          ;;        sta $XXXX
   882                          ;;        ;;... etc
   883                          ;;        dey
   884                          ;;+       cmp #1
   885  8aa0 adf08a                     lda freeze_vic_errata
   886  8aa3 8d8fd0                     sta $d08f
   887  8aa6 60                 @rts    rts
   888                          
   889                          do_unfreeze_post_hyperregs:
   890                          	;; XXX For reasons unknown, the DMA restoration of the hypervisor registers
   891                          	;; messes up $D651.
   892                          	;; At the point that this fix-up routine is called, the SD card sector
   893                          	;; containing the data is available, and so we can simply fix the problem
   894                          	;; by copying $ffd6e11 to $ffd3651
   895                          	;; If problems later occur for other regs in this range, we can just
   896                          	;; make a 32-bit ZP indirect copy loop, since there is some claim that
   897                          	;; DMA writing to those registers is problematic.
   898                          
   899                                  ;; that we don't corrupt the registers.
   900  8aa7 a911                       lda #<$6e11
   901  8aa9 8500                       sta <dos_scratch_vector+0
   902  8aab a96e                       lda #>$6e11
   903  8aad 8501                       sta <dos_scratch_vector+1
   904  8aaf a9fd                       lda #<$0ffd
   905  8ab1 8502                       sta <dos_scratch_vector+2
   906  8ab3 a90f                       lda #>$0ffd
   907  8ab5 8503                       sta <dos_scratch_vector+3
   908                          
   909  8ab7 a300                       ldz #$00
   910  8ab9 eab200                     lda [<dos_scratch_vector],z
   911  8abc 8d51d6             	sta $d651
   912                          
   913  8abf 60                 	rts
   914                          
   915                          
   916                          
   917                          
   918                          copy_sdcard_regs_to_scratch:
   919                                  ;; Copy the main SD card access registers to a
   920                                  ;; scratch area, so that we can save them, and thus restore
   921                                  ;; them after unfreezing.
   922                                  ;; (This is done outside of the automatic loop, because
   923                                  ;; it has to be handled specially.)
   924  8ac0 a20f                       ldx #$0f
   925  8ac2 bd80d6             dfp1:   lda $d680,x
   926  8ac5 9ddb8a                     sta freeze_scratch_area,x
   927  8ac8 ca                         dex
   928  8ac9 10f7                       bpl dfp1
   929                                  ;; Also save $D070 (palette select register)
   930                                  ;; since it gets stomped while saving palettes
   931  8acb ad70d0                     lda $d070
   932  8ace 8deb8a                     sta freeze_d070
   933                                  ;; Also save $D08F (VIC IV Errata)
   934                                  ;; We can't extend the VIC IV DMA entry due to
   935                                  ;; it spanning $D081 which must not be written to
   936                                  ;; lest the SD reading is disturbed.
   937  8ad1 ad8fd0                     lda $d08f
   938  8ad4 8df08a                     sta freeze_vic_errata
   939  8ad7 60                         rts
   940                          
   941  8ad8 565253             version_sentinel: !text version_sentinel_str
   942                          freeze_scratch_area:
   943  8adb 0000000000000000...        !8 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
   944                          freeze_d070:
   945  8aeb 00                         !8 0
   946                          freeze_version:
   947  8aec 565253                     !text version_sentinel_str
   948                                  ;; *** NOTE: Update the version constant if more values are added to be restored from
   949                                  ;; the scratch area.  This prevents us restoring values that were not
   950                                  ;; actually frozen but just happened to be in a freeze sector when an
   951                                  ;; older freeze was made.
   952  8aef 01                         !8 version
   953                          freeze_vic_errata:
   954  8af0 00                         !8 0
   955                                  ;; If adding more values here, update the version constant
   956                          freeze_scratch_area_end:
   957                          
   958                          do_freeze_prep_viciv:
   959                                  ;; Restore saved $D070 value to fix that $D070 will have been
   960                                  ;; stomped over by the palette saving routines
   961  8af1 adeb8a                     lda freeze_d070
   962  8af4 8d70d0                     sta $d070
   963  8af7 60                         rts
   964                          
   965                          freeze_region_dmalist:
   966  8af8 0a                         !8 $0A ;; F011A format DMA list
   967  8af9 80                         !8 $80 ;; Source MB option follows
   968                          freeze_region_dmalist_source_mb:
   969  8afa 00                         !8 $00
   970  8afb 81                         !8 $81 ;; Dest MB option follows
   971                          freeze_region_dmalist_dest_mb:
   972  8afc 00                         !8 $00
   973  8afd 00                         !8 $00 ;; end of enhanced DMA option list
   974                          
   975                                  ;; F011A format DMA list
   976  8afe 00                         !8 $00 ;; copy + last request in chain
   977                          freeze_region_dmalist_count:
   978  8aff 0000                       !16 $0000 ;; size of copy
   979                          freeze_region_dmalist_source_start:
   980  8b01 0000                       !16 $0000 ;; source address lower 16 bits
   981                          freeze_region_dmalist_source_bank:
   982  8b03 00                         !8 $00   ;;
   983                          freeze_region_dmalist_dest_start:
   984  8b04 0000                       !16 $0000
   985                          freeze_region_dmalist_dest_bank:
   986  8b06 00                         !8 $00
   987  8b07 0000                       !16 $0000 ;; modulo (unused)
   988                          
   989                          do_unfreeze_prep_palette_select:
   990                                  ;; We do the same memory map setup during freeze and unfreeze
   991                          do_freeze_prep_palette_select:
   992                                  ;; X = 6, 8, 10 or 12
   993                                  ;; Use this to pick which of the four palette banks
   994                                  ;; is visible at $D100-$D3FF
   995  8b09 8a                         txa
   996  8b0a 18                         clc
   997  8b0b e902                       sbc #freeze_prep_palette0
   998  8b0d 0a                         asl
   999  8b0e 0a                         asl
  1000  8b0f 0a                         asl
  1001  8b10 0a                         asl
  1002  8b11 0a                         asl
  1003  8b12 093f                       ora #$3f  ;; keep displaying the default palette
  1004  8b14 8d70d0                     sta $d070
  1005  8b17 60                         rts
  1006                          
  1007                          wait_on_shift_key:
  1008  8b18 ad11d6                     lda $d611
  1009  8b1b f0fb                       beq wait_on_shift_key
  1010  8b1d ad11d6             -       lda $d611
  1011  8b20 d0fb                       bne -
  1012  8b22 60                         rts
  1013                          
  1014                          debug_show_sector:
  1015                                  ;; XXX DEBUG
  1016  8b23 ad81d6                     lda $d681
  1017  8b26 8d0008                     sta $0800
  1018  8b29 ad82d6                     lda $d682
  1019  8b2c 8d0108                     sta $0801
  1020  8b2f ad83d6                     lda $d683
  1021  8b32 8d0208                     sta $0802
  1022  8b35 ad84d6                     lda $d684
  1023  8b38 8d0308                     sta $0803
  1024  8b3b 60                         rts
  1025                          
  1026                          syspart_read_freeze_region_list_trap:
  1027                                  ;; Copy freeze_mem_list out to user memory
  1028  8b3c ae41d6                     ldx hypervisor_x
  1029  8b3f 8600                       stx <dos_scratch_vector+0
  1030  8b41 ad42d6                     lda hypervisor_y
  1031  8b44 297f                       and #$7f ;; don't allow writing over hypervisor or IO when copying it out
  1032  8b46 8501                       sta <dos_scratch_vector+1
  1033  8b48 a2a8                       ldx #freeze_mem_list_end-freeze_mem_list
  1034  8b4a a000                       ldy #$00
  1035  8b4c b9588b             -       lda freeze_mem_list,y
  1036  8b4f 9100                       sta (<dos_scratch_vector),y
  1037  8b51 c8                         iny
  1038  8b52 ca                         dex
  1039  8b53 d0f7                       bne -
  1040  8b55 4c1682                     jmp return_from_trap_with_success
  1041                          
  1042                          freeze_mem_list:
  1043                          	;; XXX - There must not be more than 32 of these, as the region list
  1044                          	;; has to fit within a single page.
  1045                          
  1046                                  ;; start address (4 bytes), length (3 bytes),
  1047                                  ;; preparatory action required before reading/writing (1 byte)
  1048                                  ;; Each segment will live in its own sector (or sectors if
  1049                                  ;; >512 bytes) when frozen. So we should avoid excessive
  1050                                  ;; numbers of blocks.
  1051                          
  1052                                  ;; core SDcard registers we need to be ready to start writing
  1053                                  ;; sectors. We copy these out and in manually at the start
  1054                                  ;; and end of the freeze and unfreeze routines, respectively.
  1055                                  ;; So they are not done here.
  1056                                  ;; (the +$FFF0000 is to rebase the pointer into the hypervisor memory area)
  1057  8b58 db8aff0f                   !32 freeze_scratch_area+$fff0000
  1058  8b5c 1600                       !16 (freeze_scratch_area_end - freeze_scratch_area)
  1059  8b5e 00                         !8 0
  1060  8b5f 00                         !8 freeze_prep_none
  1061                          
  1062                                  ;; SDcard sector buffer + SD card registers
  1063                                  ;; We have to save this before anything much else, because
  1064                                  ;; we need it for freezing.  We stash $FFD6E00-FFF and
  1065                                  ;; $FFD3680-70F at $FFD6000 before hand, so that we preserve
  1066                                  ;; these registers before touching them.
  1067                                  ;; (the DMAgic registers at $DDF370x have to get copied manually,
  1068                                  ;; so that we don't mess up the DMA state.  Also, when restoring
  1069                                  ;; we have to take some care putting them back exactly.)
  1070                          
  1071  8b60 0060fd0f                   !32 $ffd6000
  1072  8b64 9000                       !16 $0090
  1073  8b66 00                         !8 0
  1074  8b67 0a                         !8 freeze_prep_stash_sd_buffer_and_regs
  1075                          
  1076                                  ;; SDcard sector buffer (F011)
  1077  8b68 006cfd0f                   !32 $ffd6c00
  1078  8b6c 0002                       !16 $0200
  1079  8b6e 00                         !8 0
  1080  8b6f 00                         !8 freeze_prep_none
  1081                          
  1082                                  ;; Process decriptor
  1083  8b70 00bdff0f                   !32 $fffbd00
  1084  8b74 0001                       !16 $0100
  1085  8b76 00                         !8 0
  1086  8b77 00                         !8 freeze_prep_none
  1087                          
  1088                                  ;; $D640-$D67E hypervisor state registers
  1089                                  ;; XXX - These can't be read by DMA, so we need to have a
  1090                                  ;; prep routine that copies them out first?
  1091  8b78 4036fd0f                   !32 $ffd3640
  1092  8b7c 3e00                       !16 $003e
  1093  8b7e 00                         !8 0
  1094  8b7f 10                         !8 freeze_prep_hyperregs
  1095                          
  1096                                  ;; VIC-IV palette block 0
  1097                                  ;; Each prep routine changes which palette is visible at ffd3100.
  1098  8b80 0031fd0f                   !32 $ffd3100
  1099  8b84 0003                       !16 $0300
  1100  8b86 00                         !8 0
  1101  8b87 02                         !8 freeze_prep_palette0
  1102                          
  1103                                  ;; VIC-IV palette block 1
  1104  8b88 0031fd0f                   !32 $ffd3100
  1105  8b8c 0003                       !16 $0300
  1106  8b8e 00                         !8 0
  1107  8b8f 04                         !8 freeze_prep_palette1
  1108                          
  1109                                  ;; VIC-IV palette block 2
  1110  8b90 0031fd0f                   !32 $ffd3100
  1111  8b94 0003                       !16 $0300
  1112  8b96 00                         !8 0
  1113  8b97 06                         !8 freeze_prep_palette2
  1114                          
  1115                                  ;; VIC-IV palette block 3
  1116  8b98 0031fd0f                   !32 $ffd3100
  1117  8b9c 0003                       !16 $0300
  1118  8b9e 00                         !8 0
  1119  8b9f 08                         !8 freeze_prep_palette3
  1120                          
  1121                                  ;; 32KB colour RAM
  1122  8ba0 0000f80f                   !32 $ff80000
  1123  8ba4 0080                       !16 $8000
  1124  8ba6 00                         !8 $00
  1125  8ba7 00                         !8 freeze_prep_none
  1126                          
  1127                                  ;; CIAs
  1128  8ba8 003cfd0f                   !32 $ffd3c00
  1129  8bac 0002                       !16 $0200
  1130  8bae 00                         !8 0
  1131  8baf 00                         !8 freeze_prep_none
  1132                          
  1133                                  ;; VIC-IV $D000-$D07F
  1134  8bb0 0030fd0f                   !32 $ffd3000
  1135  8bb4 8000                       !16 $0080   ; Do not increase this. $D081 controls sd card buffers/etc.
  1136  8bb6 00                         !8 0        ;  writing to it will cause very bad things to happen.
  1137  8bb7 0e                         !8 freeze_prep_viciv
  1138                          
  1139                                  ;; VIC-IV C128 2MHz enable emulation register
  1140  8bb8 3000fd0f                   !32 $ffd0030
  1141  8bbc 0100                       !16 $0001
  1142  8bbe 00                         !8 0
  1143  8bbf 00                         !8 freeze_prep_none
  1144                          
  1145                                  ;; 384KB RAM (includes the 128KB "ROM" area)
  1146  8bc0 00000000                   !32 $0000000
  1147  8bc4 0000                       !16 $0000
  1148  8bc6 06                         !8 6          ;; =6x64K blocks = 384KB
  1149  8bc7 00                         !8 freeze_prep_none
  1150                          
  1151                                  ;; Process scratch space
  1152  8bc8 00bd0000                   !32 currenttask_block
  1153  8bcc 0001                       !16 $0100
  1154  8bce 00                         !8 0
  1155  8bcf 00                         !8 freeze_prep_none
  1156                          
  1157                                  ;; $D700-$D7FF CPU registers (excluding DMAgic registers, which we save/restore along with SD card registers)
  1158  8bd0 1037fd0f                   !32 $ffd3710
  1159  8bd4 f000                       !16 $00F0
  1160  8bd6 00                         !8 0
  1161  8bd7 00                         !8 freeze_prep_none
  1162                          
  1163                                  ;; Internal 1541 4KB RAM + 16KB ROM
  1164                                  ;; XXX - Need to also save state of VIAs
  1165  8bd8 00b0fd0f                   !32 $FFDB000
  1166  8bdc 0050                       !16 $5000
  1167  8bde 00                         !8 0
  1168  8bdf 00                         !8 freeze_prep_none
  1169                          
  1170                          	;; Thumbnail is visible always at $FFD4xxx.
  1171                          	;; This saves some hypervisor code space, by no longer requiring to read it and place it
  1172                          	;; in low memory somewhere.  It's read-only, so we don't care about attempts to write to
  1173                          	;; it during unfreezing
  1174  8be0 0040fd0f                   !32 $FFD4000
  1175  8be4 0010                       !16 $1000
  1176  8be6 80                         !8 $80                              ;; bit 7 set in # banks tells unfreezer to ignore it.
  1177  8be7 0c                         !8 freeze_prep_thumbnail
  1178                          
  1179                                  ;; Char "ROM"
  1180  8be8 00e0f70f                   !32 $ff7e000
  1181  8bec 0010                       !16 $1000
  1182  8bee 00                         !8 0
  1183  8bef 00                         !8 freeze_prep_none
  1184                          
  1185                                  ;; The reset of FFD3000 from last track (for drive initialization)
  1186  8bf0 8430fd0f                   !32 $ffd3084
  1187  8bf4 7c00                       !16 $007C
  1188  8bf6 00                         !8 0
  1189  8bf7 00                         !8 freeze_prep_none
  1190                          
  1191                                  ;; XXX - Other IO chips!
  1192                          
  1193                                  ;; End of list
  1194  8bf8 ffffffff                   !32 $FFFFFFFF
  1195  8bfc ffff                       !16 $FFFF
  1196  8bfe ff                         !8 $FF
  1197  8bff ff                         !8 $FF
  1198                          
  1199                          freeze_mem_list_end:
  1200                          
  1201                          freeze_dma_length_remaining:
  1202  8c00 000000                     !8 0,0,0
  1203                          
  1204                                  ;; If bit 7 set, then don't DMA the region into place on unfreezing
  1205                          unfreeze_skip:
  1206  8c03 00                         !8 0
  1207                          

; ******** Source: src/hyppo/main.asm
   383                          
   384                          ;; /*  -------------------------------------------------------------------
   385                          ;;     DOS, process control and related functions trap
   386                          ;;     ---------------------------------------------------------------- */

; ******** Source: dos.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2019.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                  ;; XXX - Track down why 2nd and subsequent LFN blocks are not used.
     7                          
     8                          dos_and_process_trap:
     9                          
    10                                  ;; XXX - Machine is being updated to automatically disable IRQs on trapping
    11                                  ;; to hypervisor, but for now, we need to do this explicitly.
    12                                  ;; Should be able to be removed after 20160103
    13                                  ;; BG: cannot confirm removal of the instruction below. Dated 20160902
    14  8c04 78                         sei
    15                          
    16                                  ;; XXX - We have just added a fix for this in the CPU, to CLEAR DECIMAL MODE
    17                                  ;; on entry to the hypervisor. But I'm not taking any chances just now.
    18                                  ;;
    19  8c05 d8                         cld
    20                          
    21                                  ;; Sub-function is selected by A.
    22                                  ;; Bits 6-1 are the only ones used.
    23                                  ;; Mask out bit 0 so that indirect jmp's are valid.
    24                                  ;;
    25  8c06 297e                       and #$7E
    26  8c08 aa                         tax
    27  8c09 7c0c8c                     jmp (dos_and_process_trap_table,x)
    28                          
    29                          ;;         ========================
    30                          
    31                          dos_and_process_trap_table:
    32                          
    33                                  ;; $00 - $0E
    34                                  ;;
    35  8c0c d18c                       !16 trap_dos_getversion
    36  8c0e e88c                       !16 trap_dos_getdefaultdrive
    37  8c10 468d                       !16 trap_dos_getcurrentdrive          ;; appears out-of-order (is far below)
    38  8c12 f18c                       !16 trap_dos_selectdrive
    39  8c14 6e90                       !16 trap_dos_getdisksize              ;; not currently implemented
    40  8c16 6e90                       !16 trap_dos_getcwd                   ;; not currently implemented
    41  8c18 c08f                       !16 trap_dos_chdir
    42  8c1a 6e90                       !16 trap_dos_mkdir                    ;; not currently implemented
    43                          
    44                                  ;; $10 - $1E
    45                                  ;;
    46  8c1c 6e90                       !16 trap_dos_rmdir                    ;; not currently implemented
    47  8c1e 608f                       !16 trap_dos_opendir
    48  8c20 6e8f                       !16 trap_dos_readdir
    49  8c22 9c8f                       !16 trap_dos_closedir
    50  8c24 ce8f                       !16 trap_dos_openfile
    51  8c26 9f8f                       !16 trap_dos_readfile
    52  8c28 a58f                       !16 trap_dos_writefile
    53  8c2a 4f8d                       !16 trap_dos_mkfile                   ;; implementation started
    54                          
    55                                  ;; $20 - $2E
    56                                  ;;
    57  8c2c dc8f                       !16 trap_dos_closefile
    58  8c2e ff8c                       !16 trap_dos_closeall
    59  8c30 6e90                       !16 trap_dos_seekfile                 ;; not currently implemented
    60  8c32 ab8f                       !16 trap_dos_rmfile
    61  8c34 b18f                       !16 trap_dos_fstat                    ;; implementation started
    62  8c36 6e90                       !16 trap_dos_rename                   ;; not currently implemented
    63  8c38 6e90                       !16 trap_dos_filedate                 ;; not currently implemented
    64  8c3a 278d                       !16 trap_dos_setname
    65                          
    66                                  ;; $30 - $3E
    67                                  ;;
    68  8c3c fe8f                       !16 trap_dos_findfirst
    69  8c3e 0990                       !16 trap_dos_findnext
    70  8c40 f88f                       !16 trap_dos_findfile
    71  8c42 088d                       !16 trap_dos_loadfile
    72  8c44 0f90                       !16 trap_dos_geterrorcode
    73  8c46 218d                       !16 trap_dos_setup_transfer_area
    74  8c48 b78f                       !16 trap_dos_cdrootdir
    75  8c4a 058d                       !16 trap_dos_loadfile_attic
    76                          
    77                                  ;; $40 - $4E
    78                                  ;;
    79  8c4c 1890                       !16 trap_dos_d81attach0               ;; DOS 1.2 compatibility - DEPRECATED in favor of trap_dos_attach
    80  8c4e 2890                       !16 trap_dos_d81detach                ;; DOS 1.2 compatibility - DEPRECATED in favor of trap_dos_attach
    81  8c50 3990                       !16 trap_dos_d81write_en
    82  8c52 2090                       !16 trap_dos_d81attach1               ;; DOS 1.2 compatibility - DEPRECATED in favor of trap_dos_attach
    83  8c54 3f90                       !16 trap_dos_get_proc_desc
    84  8c56 3090                       !16 trap_dos_attach
    85  8c58 3582                       !16 invalid_subfunction
    86  8c5a 3582                       !16 invalid_subfunction
    87                          
    88                                  ;; $50 - $5E
    89                                  ;;
    90  8c5c 6e90                       !16 trap_dos_gettasklist              ;; not currently implemented
    91  8c5e 6e90                       !16 trap_dos_sendmessage              ;; not currently implemented
    92  8c60 6e90                       !16 trap_dos_receivemessage           ;; not currently implemented
    93  8c62 6e90                       !16 trap_dos_writeintotask            ;; not currently implemented
    94  8c64 6e90                       !16 trap_dos_readoutoftask            ;; not currently implemented
    95  8c66 3582                       !16 invalid_subfunction
    96  8c68 3582                       !16 invalid_subfunction
    97  8c6a 3582                       !16 invalid_subfunction
    98                          
    99                                  ;; $60 - $6E
   100                                  ;;
   101  8c6c 6e90                       !16 trap_dos_terminateothertask       ;; not currently implemented
   102  8c6e 6e90                       !16 trap_dos_create_task_native       ;; not currently implemented
   103  8c70 6e90                       !16 trap_dos_load_into_task           ;; not currently implemented
   104  8c72 6e90                       !16 trap_dos_create_task_c64          ;; not currently implemented
   105  8c74 6e90                       !16 trap_dos_create_task_c65          ;; not currently implemented
   106  8c76 6e90                       !16 trap_dos_exit_and_switch_to_task  ;; not currently implemented
   107  8c78 6e90                       !16 trap_dos_switch_to_task           ;; not currently implemented
   108  8c7a 6e90                       !16 trap_dos_exit_task                ;; not currently implemented
   109                          
   110                                  ;; $70 - $7E
   111                                  ;;
   112  8c7c c38c                       !16 trap_task_toggle_rom_writeprotect
   113  8c7e b88c                       !16 trap_task_toggle_force_4502
   114  8c80 928c                       !16 trap_task_get_mapping
   115  8c82 a58c                       !16 trap_task_set_mapping
   116  8c84 3582                       !16 invalid_subfunction
   117  8c86 3582                       !16 invalid_subfunction
   118  8c88 8c8c                       !16 trap_serial_monitor_write
   119  8c8a 2ba5                       !16 reset_entry
   120                          
   121                          trap_serial_monitor_write:
   122  8c8c 8c7cd6                     sty hypervisor_write_char_to_serial_monitor
   123  8c8f 4c1682                     jmp return_from_trap_with_success
   124                          
   125                          ;;         ========================
   126                          
   127                          trap_task_get_mapping:
   128  8c92 2040ad                     jsr hypervisor_setup_copy_region
   129  8c95 900b                       bcc @bad
   130  8c97 a005                       ldy #5
   131                          @copyloop:
   132  8c99 b94ad6                     lda hypervisor_maplohi,y
   133  8c9c 9106                       sta (<hypervisor_userspace_copy_vector),y
   134  8c9e 88                         dey
   135  8c9f 10f8                       bpl @copyloop
   136  8ca1 38                         sec
   137                          @bad:
   138  8ca2 4cf78c                     jmp return_from_trap_with_carry_flag
   139                          
   140                          trap_task_set_mapping:
   141  8ca5 2040ad                     jsr hypervisor_setup_copy_region
   142  8ca8 900b                       bcc @bad2
   143  8caa a005                       ldy #5
   144                          @copyloop2:
   145  8cac b106                       lda (<hypervisor_userspace_copy_vector),y
   146  8cae 994ad6                     sta hypervisor_maplohi,y
   147  8cb1 88                         dey
   148  8cb2 10f8                       bpl @copyloop2
   149  8cb4 38                         sec
   150                          @bad2:
   151  8cb5 4cf78c                     jmp return_from_trap_with_carry_flag
   152                          
   153                          trap_task_toggle_force_4502:
   154  8cb8 ad7dd6                     lda hypervisor_feature_enables
   155  8cbb 4920                       eor #$20
   156  8cbd 8d7dd6                     sta hypervisor_feature_enables
   157  8cc0 4ccb8c                     jmp returnFeatureState
   158                          
   159                          trap_task_toggle_rom_writeprotect:
   160  8cc3 ad7dd6                     lda hypervisor_feature_enables
   161  8cc6 4904                       eor #$04
   162  8cc8 8d7dd6                     sta hypervisor_feature_enables
   163                          returnFeatureState:
   164                                  ;; Pass updated state back out to caller, so they know the result
   165  8ccb 8d40d6                     sta hypervisor_a
   166  8cce 4c1682                     jmp return_from_trap_with_success
   167                          
   168                          trap_dos_getversion:
   169                          
   170                                  ;; Return OS and DOS version.
   171                                  ;; A.X = OS Version major/minor
   172                                  ;; Y.Z = DOS Version major/minor
   173                          
   174  8cd1 a902                       lda #<os_version
   175  8cd3 8d41d6                     sta hypervisor_x
   176  8cd6 a901                       lda #>os_version
   177  8cd8 8d40d6                     sta hypervisor_a
   178  8cdb a901                       lda #>dos_version
   179  8cdd 8d42d6                     sta hypervisor_y
   180  8ce0 a903                       lda #<dos_version
   181  8ce2 8d43d6                     sta hypervisor_z
   182  8ce5 4c1682                     jmp return_from_trap_with_success
   183                          
   184                          ;;         ========================
   185                          
   186                          trap_dos_getdefaultdrive:
   187                          
   188  8ce8 ad02bc                     lda dos_default_disk
   189  8ceb 8d40d6                     sta hypervisor_a
   190  8cee 4c1682                     jmp return_from_trap_with_success
   191                          
   192                          ;;         ========================
   193                          
   194                          trap_dos_selectdrive:
   195                          
   196  8cf1 ae41d6                     ldx hypervisor_x
   197  8cf4 202293                     jsr dos_set_current_disk
   198                          
   199                          return_from_trap_with_carry_flag:
   200  8cf7 b003                       bcs +
   201  8cf9 4c2482                     jmp return_from_trap_with_failure
   202  8cfc 4c1682             +       jmp return_from_trap_with_success
   203                          
   204                          trap_dos_closeall:
   205                          
   206  8cff 207190                     jsr dos_clear_filedescriptors
   207  8d02 4c1682                     jmp return_from_trap_with_success
   208                          
   209                          ;;         ========================
   210                          
   211                          trap_dos_loadfile_attic:
   212  8d05 a908                       lda #$08  		; Set address to $8xxxxxx to access attic RAM
   213  8d07 2c                         !8 $2c 		; BIT $xxxx to skip lda #$00 below
   214                                  ;; FALL THROUGH
   215                          
   216                          trap_dos_loadfile:
   217                          
   218                                  ;; Only allow loading into lower 16MB to avoid possibility of writing
   219                                  ;; over hypervisor
   220                                  ;;
   221  8d08 a900                       lda #$00
   222  8d0a 851b                       sta <(dos_file_loadaddress+3)
   223                          
   224  8d0c ad41d6                     lda hypervisor_x
   225  8d0f 8518                       sta <dos_file_loadaddress
   226  8d11 ad42d6                     lda hypervisor_y
   227  8d14 8519                       sta <(dos_file_loadaddress+1)
   228  8d16 ad43d6                     lda hypervisor_z
   229  8d19 851a                       sta <(dos_file_loadaddress+2)
   230                          
   231  8d1b 205099                     jsr dos_readfileintomemory
   232  8d1e 4cf78c                     jmp return_from_trap_with_carry_flag
   233                          
   234                          ;;         ========================
   235                          
   236                          trap_dos_setup_transfer_area:
   237                          
   238  8d21 2040ad                     jsr hypervisor_setup_copy_region
   239                          
   240  8d24 4cf78c                     jmp return_from_trap_with_carry_flag
   241                          
   242                          trap_dos_setname:
   243                          
   244                                  ;; read file name from any where in bottom 32KB of RAM, as mapped on entry
   245                                  ;; to the hypervisor (this prevents the user from setting the filename to some
   246                                  ;; piece of the hypervisor, and thus leaking hypervisor data to user-land if the
   247                                  ;; user were to later query the filename).
   248                          
   249                                  +Checkpoint "trap_dos_setname"
   250                          
   251  8d27 2040ad                     jsr hypervisor_setup_copy_region
   252  8d2a 900c                       bcc tdsnfailure
   253                          
   254  8d2c a606                       ldx <hypervisor_userspace_copy_vector
   255  8d2e a407                       ldy <(1+hypervisor_userspace_copy_vector)
   256  8d30 20d59b                     jsr dos_setname
   257  8d33 9003                       bcc tdsnfailure
   258                          
   259                                  ;; setname succeeded
   260                                  ;;
   261                          
   262  8d35 4c1682                     jmp return_from_trap_with_success
   263                          
   264                          ;;         ========================
   265                          
   266                          tdsnfailure:
   267                                  ;; save the error code so a later trap_dos_geterrorcode will return it
   268  8d38 8dfcbc                     sta dos_error_code
   269  8d3b 4c2482                     jmp return_from_trap_with_failure
   270                          
   271                          ;;         ========================
   272                          
   273                          
   274                          illegalvalue:
   275                          
   276                                  ;; BG: the below section seems never called from anywhere: suggest removal
   277                          
   278                          !if DEBUG_HYPPO {
   279                          ;;         tya
   280                          ;;         tax
   281                          ;;         jsr checkpoint_bytetohex
   282                          ;;         sty iv1+0
   283                          ;;         stx iv1+1
   284                          ;;
   285                          ;;         jsr checkpoint
   286                          ;;         .byte 0,"Filename contains $00 @ position $"
   287                          ;; iv1:        .byte "%%",0
   288                          }
   289                          
   290  8d3e a911                       lda #dos_errorcode_illegal_value
   291  8d40 8dfcbc                     sta dos_error_code
   292  8d43 4c2482                     jmp return_from_trap_with_failure
   293                          
   294                          ;;         ========================
   295                          
   296                          trap_dos_getcurrentdrive:
   297                          
   298  8d46 ad03bc                     lda dos_disk_current_disk
   299  8d49 8d40d6                     sta hypervisor_a
   300  8d4c 4c1682                     jmp return_from_trap_with_success
   301                          
   302                          ;;         ========================
   303                          
   304                          trap_dos_mkfile:
   305                          
   306                                  ;; XXX Filename must already be set.
   307                                  ;; XXX Must be a file in the current directory only.
   308                                  ;; XXX Can only create normal files, not directories
   309                                  ;;     (change attribute after).
   310                                  ;; XXX Only supports 8.3 names for now.
   311                                  ;; XXX Filenames without extension might still cause problems.
   312                                  ;; XXX Allocates 512KB at a time, i.e., a full FAT sector's
   313                                  ;;     worth of clusters.
   314                                  ;; XXX Allocates a contiguous block, so that D81s etc can
   315                                  ;;     be created, and guaranteed contiguous on the storage,
   316                                  ;;     so that they can be mounted.
   317                                  ;; XXX Size of file specified in $ZZYYXX, i.e., limit of 16MB.
   318                                  ;; XXX Doesn't handle full file systems (or ones without enough space
   319                                  ;;     free properly. Should check candidate cluster number is not too
   320                                  ;;     high, and abort if it is.
   321                          
   322                                  ;; First, make sure the file doesn't already exist
   323  8d4f 204a94                     jsr dos_findfile
   324  8d52 9009                       bcc +
   325                                  ;; File exists, so abort
   326  8d54 18                         clc
   327  8d55 a98d                       lda #dos_errorcode_file_exists
   328  8d57 8dfcbc                     sta dos_error_code
   329  8d5a 4c2482                     jmp return_from_trap_with_failure
   330                          +
   331                          
   332                                  ;; We need 1 FAT sector per 512KB of data.
   333                                  ;; I.e., shift ZZ right by three bits to get number
   334                                  ;; of empty FAT sectors we need to indicate sufficient space.
   335  8d5d ad43d6                     lda hypervisor_z
   336  8d60 4a                         lsr
   337  8d61 4a                         lsr
   338  8d62 4a                         lsr
   339  8d63 18                         clc
   340  8d64 6901                       adc #$01
   341  8d66 8d04bf                     sta dos_scratch_byte_1
   342                          
   343                                  ;; Now go looking for empty FAT sectors
   344                                  ;; Start at cluster 128, and add 128 each time to step through
   345                                  ;; them.
   346                                  ;; This skips the first sector of FAT, which always has some used
   347                                  ;; bits, and ensures we can allocate on a whole sector basis.
   348  8d69 a980                       lda #128
   349  8d6b 8510                       sta <(zptempv32+0)
   350  8d6d a900                       lda #$00
   351  8d6f 8511                       sta <(zptempv32+1)
   352  8d71 8512                       sta <(zptempv32+2)
   353  8d73 8513                       sta <(zptempv32+3)
   354                          
   355                                  ;; Initially 0 empty pages found
   356  8d75 a900                       lda #0
   357  8d77 8d05bf                     sta dos_scratch_byte_2
   358                          
   359  8d7a 2018a2                     jsr sd_map_sectorbuffer
   360                          
   361                          find_empty_fat_page_loop:
   362                          
   363  8d7d a203                       ldx #3
   364  8d7f b510               -	lda <zptempv32,x
   365  8d81 9db4bc                     sta dos_current_cluster,x
   366  8d84 ca                         dex
   367  8d85 10f8                       bpl -
   368                          
   369  8d87 204f8f                     jsr read_fat_sector_for_cluster
   370                          
   371                                  ;; Is the page empty
   372  8d8a a200                       ldx #0
   373  8d8c bd00de             -	lda sd_sectorbuffer,x
   374  8d8f d008                       bne +
   375  8d91 bd00df                     lda sd_sectorbuffer+$100,x
   376  8d94 d003                       bne +
   377                          
   378  8d96 e8                         inx
   379  8d97 d0f3                       bne -
   380                          +
   381                          
   382                                  ;; Z=1 if FAT sector all unallocated, Z=0 otherwise
   383  8d99 f008                       beq fat_sector_is_empty
   384                          
   385                                  ;; Reset empty FAT sector counter
   386  8d9b a900                       lda #0
   387  8d9d 8d05bf                     sta dos_scratch_byte_2
   388  8da0 4cae8d                     jmp +
   389                          
   390                          fat_sector_is_empty:
   391  8da3 ee05bf                     inc dos_scratch_byte_2
   392  8da6 ad05bf                     lda dos_scratch_byte_2
   393  8da9 cd04bf                     cmp dos_scratch_byte_1
   394  8dac f01c                       beq found_enough_contiguous_free_space
   395                          +
   396                                  ;; Need to find another
   397  8dae a980                       lda #$80
   398  8db0 18                         clc
   399  8db1 6510                       adc <(zptempv32+0)
   400  8db3 8510                       sta <(zptempv32+0)
   401  8db5 a511                       lda <(zptempv32+1)
   402  8db7 6900                       adc #0
   403  8db9 8511                       sta <(zptempv32+1)
   404  8dbb a512                       lda <(zptempv32+2)
   405  8dbd 6900                       adc #0
   406  8dbf 8512                       sta <(zptempv32+2)
   407  8dc1 a513                       lda <(zptempv32+3)
   408  8dc3 6900                       adc #0
   409  8dc5 8513                       sta <(zptempv32+3)
   410                          
   411                                  ;; XXX Check that we haven't hit the end of the file system
   412                          
   413  8dc7 4c7d8d                     jmp find_empty_fat_page_loop
   414                          
   415                          found_enough_contiguous_free_space:
   416                          
   417                                  ;; Space begins dos_scratch_byte_2 FAT sectors before here,
   418                                  ;; so rewind back to there by taking $80 away for each count.
   419  8dca ce05bf                     dec dos_scratch_byte_2
   420                          
   421  8dcd ad05bf             -	lda dos_scratch_byte_2
   422  8dd0 f01f                       beq +
   423  8dd2 a510                       lda <(zptempv32+0)
   424  8dd4 38                         sec
   425  8dd5 e980                       sbc #$80
   426  8dd7 8510                       sta <(zptempv32+0)
   427  8dd9 a511                       lda <(zptempv32+1)
   428  8ddb e900                       sbc #0
   429  8ddd 8511                       sta <(zptempv32+1)
   430  8ddf a512                       lda <(zptempv32+2)
   431  8de1 e900                       sbc #0
   432  8de3 8512                       sta <(zptempv32+2)
   433  8de5 a513                       lda <(zptempv32+3)
   434  8de7 e900                       sbc #0
   435  8de9 8513                       sta <(zptempv32+3)
   436  8deb ce05bf                     dec dos_scratch_byte_2
   437  8dee 4ccd8d                     jmp -
   438                          +
   439                                  ;; zptempv32 now contains the starting cluster for our file
   440                          
   441                                  ;; Find directory entry slot
   442  8df1 200c8f                     jsr dos_find_free_dirent
   443  8df4 b001                       bcs +
   444                                  ;; Couldn't find a free dirent, so return whatever error
   445                                  ;; we have been indicated.
   446  8df6 60                         rts
   447                          +
   448                          
   449                                  ;; Show offset in directory sector for dirent
   450                          ;;	lda dos_scratch_vector+0
   451                          ;;	sta $0700
   452                          ;;	lda dos_scratch_vector+1
   453                          ;;	and #$01
   454                          ;;	sta $0701
   455                          ;;
   456                          ;;	;; Show directory sector
   457                          ;;	ldx #3
   458                          ;;!:	lda $d681,x
   459                          ;;	sta $0703,x
   460                          ;;	dex
   461                          ;;	bpl !-
   462                          ;;
   463                          ;;	;; Show first cluster we will use
   464                          ;;	ldx #3
   465                          ;;!:	lda zptempv32,x
   466                          ;;	sta $0708,x
   467                          ;;	dex
   468                          ;;	bpl !-
   469                          
   470                                  ;; XXX Populate dirent structure
   471                                  ;; dirent: erase old contents
   472  8df7 a01f                       ldy #31
   473  8df9 a900                       lda #0
   474  8dfb 9100               -	sta (<dos_scratch_vector),y
   475                                  ;; Put spaces in filename field (first 11 bytes)
   476  8dfd c00b                       cpy #11
   477  8dff d002                       bne foo1
   478  8e01 a920                       lda #$20
   479                          foo1:
   480  8e03 88                         dey
   481  8e04 10f5                       bpl -
   482                                  ;; dirent: filename
   483                                  ;; Split filename at dot
   484  8e06 a000                       ldy #0
   485  8e08 a200                       ldx #fs_fat32_dirent_offset_shortname
   486  8e0a bd68bc             -	lda dos_requested_filename,x
   487  8e0d c92e                       cmp #$2e
   488  8e0f d004                       bne not_dot
   489  8e11 a007                       ldy #8-1
   490  8e13 d006                       bne was_dot
   491                          not_dot:
   492                                  ;; Don't write nul char if filename is short
   493  8e15 c900                       cmp #0
   494  8e17 f00a                       beq +
   495  8e19 9100                       sta (<dos_scratch_vector),y
   496                          was_dot:
   497  8e1b f006                       beq +
   498  8e1d e8                         inx
   499  8e1e c8                         iny
   500  8e1f c00b                       cpy #11
   501  8e21 d0e7                       bne -
   502                          +
   503                          
   504                                  ;; dirent: attributes
   505  8e23 a00b                       ldy #fs_fat32_dirent_offset_attributes
   506  8e25 a920                       lda #$20 ;; Archive bit set
   507  8e27 9100                       sta (<dos_scratch_vector),y
   508                                  ;; dirent: start cluster
   509  8e29 a01a                       ldy #fs_fat32_dirent_offset_clusters_low
   510  8e2b a510                       lda <(zptempv32+0)
   511  8e2d 9100                       sta (<dos_scratch_vector),y
   512  8e2f c8                         iny
   513  8e30 a511                       lda <(zptempv32+1)
   514  8e32 9100                       sta (<dos_scratch_vector),y
   515  8e34 a014                       ldy #fs_fat32_dirent_offset_clusters_high
   516  8e36 a512                       lda <(zptempv32+2)
   517  8e38 9100                       sta (<dos_scratch_vector),y
   518  8e3a c8                         iny
   519  8e3b a513                       lda <(zptempv32+3)
   520  8e3d 9100                       sta (<dos_scratch_vector),y
   521                                  ;; dirent: file length
   522  8e3f a01c                       ldy #fs_fat32_dirent_offset_file_length
   523  8e41 ad41d6                     lda hypervisor_x
   524  8e44 9100                       sta (<dos_scratch_vector),y
   525  8e46 c8                         iny
   526  8e47 ad42d6                     lda hypervisor_y
   527  8e4a 9100                       sta (<dos_scratch_vector),y
   528  8e4c c8                         iny
   529  8e4d ad43d6                     lda hypervisor_z
   530  8e50 9100                       sta (<dos_scratch_vector),y
   531  8e52 c8                         iny
   532  8e53 a900                       lda #0
   533  8e55 9100                       sta (<dos_scratch_vector),y
   534                          
   535                                  ;; Write sector back with updated dirent
   536  8e57 209ea1                     jsr write_non_mbr_sector
   537  8e5a 20afa1                     jsr sd_wait_for_ready
   538                          
   539                                  ;; Update both FATs to make the allocation
   540                          
   541                                  ;; Work out how many sectors full of incrementing clusters
   542                                  ;; we need.
   543  8e5d ad04bf                     lda dos_scratch_byte_1
   544  8e60 8d05bf                     sta dos_scratch_byte_2
   545                          mkfile_fat_write_loop:
   546                                  ;; Get the (currently empty) sector
   547  8e63 a203                       ldx #3
   548  8e65 b510               -	lda <zptempv32,x
   549  8e67 9db4bc                     sta dos_current_cluster,x
   550  8e6a ca                         dex
   551  8e6b 10f8                       bpl -
   552  8e6d 204f8f                     jsr read_fat_sector_for_cluster
   553                          
   554                                  ;; Update cluster number and write it into the field
   555  8e70 a000                       ldy #0
   556                          -
   557                                  ;; XXX Rework to use 32-bit pseudo register
   558  8e72 a510                       lda <(zptempv32+0)
   559  8e74 18                         clc
   560  8e75 6901                       adc #1
   561  8e77 8510                       sta <(zptempv32+0)
   562  8e79 9900de                     sta sd_sectorbuffer,y
   563  8e7c c8                         iny
   564  8e7d a511                       lda <(zptempv32+1)
   565  8e7f 6900                       adc #0
   566  8e81 8511                       sta <(zptempv32+1)
   567  8e83 9900de                     sta sd_sectorbuffer,y
   568  8e86 c8                         iny
   569  8e87 a512                       lda <(zptempv32+2)
   570  8e89 6900                       adc #0
   571  8e8b 8512                       sta <(zptempv32+2)
   572  8e8d 9900de                     sta sd_sectorbuffer,y
   573  8e90 c8                         iny
   574  8e91 a513                       lda <(zptempv32+3)
   575  8e93 6900                       adc #0
   576  8e95 8513                       sta <(zptempv32+3)
   577  8e97 9900de                     sta sd_sectorbuffer,y
   578  8e9a c8                         iny
   579  8e9b d0d5                       bne -
   580                          -
   581  8e9d a510                       lda <(zptempv32+0)
   582  8e9f 18                         clc
   583  8ea0 6901                       adc #1
   584  8ea2 8510                       sta <(zptempv32+0)
   585  8ea4 9900df                     sta sd_sectorbuffer+$100,y
   586  8ea7 c8                         iny
   587  8ea8 a511                       lda <(zptempv32+1)
   588  8eaa 6900                       adc #0
   589  8eac 8511                       sta <(zptempv32+1)
   590  8eae 9900df                     sta sd_sectorbuffer+$100,y
   591  8eb1 c8                         iny
   592  8eb2 a512                       lda <(zptempv32+2)
   593  8eb4 6900                       adc #0
   594  8eb6 8512                       sta <(zptempv32+2)
   595  8eb8 9900df                     sta sd_sectorbuffer+$100,y
   596  8ebb c8                         iny
   597  8ebc a513                       lda <(zptempv32+3)
   598  8ebe 6900                       adc #0
   599  8ec0 8513                       sta <(zptempv32+3)
   600  8ec2 9900df                     sta sd_sectorbuffer+$100,y
   601  8ec5 c8                         iny
   602  8ec6 d0d5                       bne -
   603                          
   604                                  ;; If the last FAT sector for this file, then
   605                                  ;; the last cluster entry should be $0FFFFFF8 to mark
   606                                  ;; end of file.
   607  8ec8 ad05bf                     lda dos_scratch_byte_2
   608  8ecb c901                       cmp #1
   609  8ecd d012                       bne +
   610  8ecf a9f8                       lda #$F8
   611  8ed1 8dfcdf                     sta $dffc
   612  8ed4 a9ff                       lda #$FF
   613  8ed6 8dfddf                     sta $dffd
   614  8ed9 8dfedf                     sta $dffe
   615  8edc a90f                       lda #$0F
   616  8ede 8dffdf                     sta $dfff
   617                          +
   618                                  ;; Write FAT sector to FAT1
   619  8ee1 209ea1                     jsr write_non_mbr_sector
   620  8ee4 20afa1                     jsr sd_wait_for_ready
   621                          
   622                                  ;; Work out where it will be in the 2nd FAT
   623  8ee7 ad04bc                     lda dos_disk_table_offset
   624  8eea 0909                       ora #fs_fat32_length_of_fat
   625  8eec a8                         tay
   626  8eed a200                       ldx #0
   627  8eef bd81d6             -	lda $d681,x
   628  8ef2 7900bb                     adc dos_disk_table,y
   629  8ef5 c8                         iny
   630  8ef6 e8                         inx
   631  8ef7 e004                       cpx #4
   632  8ef9 d0f4                       bne -
   633                          
   634                                  ;; Write FAT sector to FAT2
   635  8efb 209ea1                     jsr write_non_mbr_sector
   636  8efe 20afa1                     jsr sd_wait_for_ready
   637                          
   638                                  ;; More FAT sectors to go?
   639  8f01 ce05bf                     dec dos_scratch_byte_2
   640  8f04 f003                       beq +
   641  8f06 4c638e                     jmp mkfile_fat_write_loop
   642                          +
   643                          
   644                                  ;; All done: File has been created.
   645  8f09 4c1682                     jmp return_from_trap_with_success
   646                          
   647                          dos_find_free_dirent:
   648                                  ;; Start by opening the directory.
   649  8f0c 207694                     jsr dos_opendir
   650                                  ;; Then look for free directory entry slots.
   651  8f0f 2018a2                     jsr sd_map_sectorbuffer
   652                          
   653                                  ;; FALL THROUGH
   654                          
   655                          empty_dirent_search_loop:
   656                          
   657  8f12 20e197                     jsr dos_file_read_current_sector
   658                          
   659                                  ;; Look for free dirent in first half of each sector.
   660  8f15 a200                       ldx #0
   661  8f17 a9de                       lda #$de
   662  8f19 8501                       sta <(dos_scratch_vector+1)
   663  8f1b bd00de             -	lda sd_sectorbuffer,x
   664  8f1e c900                       cmp #$00 ;; vacant
   665  8f20 f029                       beq available_dirent_slot
   666  8f22 c9e5                       cmp #$e5 ;; deleted
   667  8f24 f025                       beq available_dirent_slot
   668  8f26 8a                         txa
   669  8f27 6920                       adc #$20
   670  8f29 aa                         tax
   671  8f2a d0ef                       bne -
   672  8f2c e601                       inc <(dos_scratch_vector+1)
   673  8f2e bd00de             -	lda sd_sectorbuffer,x
   674  8f31 c900                       cmp #$00 ;; vacant
   675  8f33 f016                       beq available_dirent_slot
   676  8f35 c9e5                       cmp #$e5 ;; deleted
   677  8f37 f012                       beq available_dirent_slot
   678  8f39 8a                         txa
   679  8f3a 6920                       adc #$20
   680  8f3c aa                         tax
   681  8f3d d0ef                       bne -
   682                          
   683                                  ;; No empty slots in this directory, so see if there any more sectors in
   684                                  ;; this directory?
   685  8f3f 200898                     jsr dos_file_advance_to_next_sector
   686  8f42 b0ce                       bcs empty_dirent_search_loop
   687                          
   688                                  ;; Directory is full, so return error
   689                                  ;; XXX Later we should allow extending the directory by adding another cluster.
   690  8f44 a98e                       lda #dos_errorcode_directory_full
   691  8f46 8dfcbc                     sta dos_error_code
   692  8f49 18                         clc
   693  8f4a 60                         rts
   694                          
   695                          available_dirent_slot:
   696  8f4b 8600                       stx <(dos_scratch_vector+0)
   697                          
   698  8f4d 38                         sec
   699  8f4e 60                         rts
   700                          
   701                          ;;         ========================
   702                          
   703                          read_fat_sector_for_cluster:
   704  8f4f 200b99                     jsr dos_cluster_to_fat_sector
   705                          
   706                                  ;; Now read the sector
   707  8f52 a203                       ldx #3
   708  8f54 bdb4bc             -       lda dos_current_cluster,x
   709  8f57 9d81d6                     sta $d681,x
   710  8f5a ca                         dex
   711  8f5b 10f7                       bpl -
   712  8f5d 4c2da2                     jmp sd_readsector
   713                          
   714                          ;;         ========================
   715                          
   716                          trap_dos_opendir:
   717                          
   718                                  ;; X = File descriptor
   719                                  ;; Y = Page of memory to write dirent into
   720                          
   721                                  ;; Open the current working directory for iteration.
   722                                  ;;
   723  8f60 207694                     jsr dos_opendir
   724  8f63 b006                       bcs tdod1
   725                          
   726                                  ;; Something has gone wrong. Assume dos_opendir will
   727                                  ;; have set error code
   728                                  ;;
   729  8f65 adfcbc                     lda dos_error_code
   730  8f68 4c2482                     jmp return_from_trap_with_failure
   731                          
   732                          tdod1:
   733                                  ;; Directory opened ok.
   734                                  ;;
   735  8f6b 4c1082                     jmp return_from_trap_with_success_and_file_descriptor_in_a
   736                          
   737                          ;;         ========================
   738                          
   739                          trap_dos_readdir:
   740                          
   741                                  ;; Read next directory entry from file descriptor $XX
   742                                  ;; Return dirent structure to $YY00
   743                                  ;; in first 32KB of mapped address space
   744                          
   745                                  +Checkpoint "trap_dos_readdir"
   746                          
   747  8f6e 2018a2                     jsr sd_map_sectorbuffer
   748                          
   749                                  ;; Get offset to current file descriptor
   750                                  ;; (we can't use X register, as has been clobbered in the jump
   751                                  ;; table dispatch code)
   752                                  ;;
   753  8f71 ae41d6                     ldx hypervisor_x
   754  8f74 8ef9bc                     stx dos_current_file_descriptor
   755                          
   756  8f77 20ba97                     jsr dos_get_file_descriptor_offset
   757  8f7a 901a                       bcc tdrd1
   758  8f7c 8dfabc                     sta dos_current_file_descriptor_offset
   759                          
   760  8f7f 20d594                     jsr dos_readdir
   761  8f82 9012                       bcc tdrd1
   762                          
   763                                  ;; Read the directory entry, now copy it to userland
   764                                  ;;
   765  8f84 2040ad                     jsr hypervisor_setup_copy_region
   766  8f87 900d                       bcc tdrd1
   767                          
   768                                  ;; We can now copy the bytes of the dirent to user-space
   769                                  ;;
   770  8f89 a056                       ldy #dos_dirent_structure_length-1
   771                          tdrd2:
   772                                  ;; This loop actually copies the whole dirent.
   773                                  ;; XXX dos_dirent_longfilename must be first in the dirent structure
   774  8f8b b910bc                     lda dos_dirent_longfilename,y
   775  8f8e 9106                       sta (<hypervisor_userspace_copy_vector),y
   776  8f90 88                         dey
   777  8f91 10f8                       bpl tdrd2
   778                          
   779                                  +Checkpoint "trap_dos_readdir <success>"
   780                          
   781  8f93 4c1682                     jmp return_from_trap_with_success
   782                          
   783                          ;;         ========================
   784                          
   785                          tdrd1:
   786                                  +Checkpoint "trap_dos_readdir <failure>"
   787                          
   788  8f96 adfcbc                     lda dos_error_code
   789  8f99 4c2482                     jmp return_from_trap_with_failure
   790                          
   791                          ;;         ========================
   792                          
   793                          trap_dos_closedir:
   794  8f9c 4cdc8f                     jmp trap_dos_closefile
   795                          
   796                          ;;         ========================
   797                          
   798                          trap_dos_readfile:
   799  8f9f 20499a                     jsr dos_readfile
   800  8fa2 4cf78c                     jmp return_from_trap_with_carry_flag
   801                          
   802                          trap_dos_writefile:
   803  8fa5 20559a                     jsr dos_writefile
   804  8fa8 4cf78c                     jmp return_from_trap_with_carry_flag
   805                          
   806                          trap_dos_rmfile:
   807  8fab 20669a                     jsr dos_rmfile
   808  8fae 4cf78c                     jmp return_from_trap_with_carry_flag
   809                          
   810                          trap_dos_fstat:
   811  8fb1 20a59b                     jsr dos_fstat
   812  8fb4 4cf78c                     jmp return_from_trap_with_carry_flag
   813                          
   814                          ;;         ========================
   815                          
   816                          trap_dos_cdrootdir:
   817  8fb7 ae41d6                     ldx hypervisor_x
   818  8fba 203c93                     jsr dos_cdroot
   819  8fbd 4cf78c                     jmp return_from_trap_with_carry_flag
   820                          
   821                          trap_dos_chdir:
   822                          
   823                                  ;; Opens file in current dirent structure
   824                                  ;; XXX - This means we must preserve the dirent struct when
   825                                  ;; context-switching to avoid a race-condition
   826                          
   827  8fc0 200494                     jsr dos_chdir
   828  8fc3 9003                       bcc tdcd1
   829                          
   830                                  +Checkpoint "trap_dos_chdir <success>"
   831                          
   832  8fc5 4c1682                     jmp return_from_trap_with_success
   833                          
   834                          tdcd1:
   835                                  +Checkpoint "trap_dos_chdir <failure>"
   836                          
   837  8fc8 adfcbc                     lda dos_error_code
   838  8fcb 4c2482                     jmp return_from_trap_with_failure
   839                          
   840                          ;;         ========================
   841                          
   842                          
   843                          trap_dos_openfile:
   844                          
   845                                  ;; Opens file in current dirent structure
   846                                  ;; XXX - This means we must preserve the dirent struct when
   847                                  ;; context-switching to avoid a race-condition
   848                          
   849  8fce 203694                     jsr dos_openfile
   850  8fd1 9003                       bcc tdof1
   851                          
   852                                  +Checkpoint "trap_dos_openfile <success>"
   853                          
   854  8fd3 4c1082                     jmp return_from_trap_with_success_and_file_descriptor_in_a
   855                          
   856                          tdof1:
   857                                  +Checkpoint "trap_dos_openfile <failure>"
   858                          
   859  8fd6 adfcbc                     lda dos_error_code
   860  8fd9 4c2482                     jmp return_from_trap_with_failure
   861                          
   862                          ;;         ========================
   863                          
   864                          trap_dos_closefile:
   865                          
   866  8fdc ae41d6                     ldx hypervisor_x
   867  8fdf 8ef9bc                     stx dos_current_file_descriptor
   868                          
   869  8fe2 20ba97                     jsr dos_get_file_descriptor_offset
   870  8fe5 900b                       bcc tdcf1
   871  8fe7 8dfabc                     sta dos_current_file_descriptor_offset
   872  8fea 20f093                     jsr dos_closefile
   873  8fed 9003                       bcc tdcf1
   874                          
   875                                  +Checkpoint "trap_dos_closefile <success>"
   876                          
   877  8fef 4c1682                     jmp return_from_trap_with_success
   878                          tdcf1:
   879                                  +Checkpoint "trap_dos_closefile <failure>"
   880                          
   881  8ff2 adfcbc                     lda dos_error_code
   882  8ff5 4c2482                     jmp return_from_trap_with_failure
   883                          
   884                          ;;         ========================
   885                          
   886                          trap_dos_findfile:
   887                          
   888  8ff8 204a94                     jsr dos_findfile
   889  8ffb 4cf78c                     jmp return_from_trap_with_carry_flag
   890                          
   891                          ;;         ========================
   892                          
   893                          trap_dos_findfirst:
   894                          
   895  8ffe 205794                     jsr dos_findfirst
   896  9001 9003                       bcc +
   897  9003 4c1082                     jmp return_from_trap_with_success_and_file_descriptor_in_a
   898  9006 4c2482             +	jmp return_from_trap_with_failure
   899                          
   900                          ;;         ========================
   901                          
   902                          trap_dos_findnext:
   903                          
   904  9009 206294                     jsr dos_findnext
   905  900c 4cf78c                     jmp return_from_trap_with_carry_flag
   906                          
   907                          ;;         ========================
   908                          
   909                          trap_dos_geterrorcode:
   910                          
   911  900f adfcbc                     lda dos_error_code
   912  9012 8d40d6                     sta hypervisor_a
   913                          
   914                          !if DEBUG_HYPPO {
   915                                  tax                                ;; convert .X to char-representation for display
   916                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
   917                                  sty tdgec1+0
   918                                  stx tdgec1+1
   919                          
   920                                  jsr checkpoint
   921                                  !8 0
   922                                  !text "dos_geterrorcode <=$"
   923                          tdgec1: !text "%%>"
   924                                  !8 0
   925                          }
   926                          
   927  9015 4c1682                     jmp return_from_trap_with_success
   928                          
   929                          ;;         ========================
   930                          
   931                          trap_dos_d81attach0:
   932                          
   933                                  +Checkpoint "trap_dos_d81attach0"
   934                          
   935  9018 a200                       ldx #$00
   936  901a 20019c                     jsr dos_attach
   937  901d 4cf78c                     jmp return_from_trap_with_carry_flag
   938                          
   939                          ;;         ========================
   940                          
   941                          trap_dos_d81attach1:
   942                          
   943                                  +Checkpoint "trap_dos_d81attach1"
   944                          
   945  9020 a201                       ldx #$01
   946  9022 20019c                     jsr dos_attach
   947  9025 4cf78c                     jmp return_from_trap_with_carry_flag
   948                          
   949                          ;;         ========================
   950                          
   951                          trap_dos_d81detach:
   952                          
   953                                  +Checkpoint "trap_dos_d81detach"
   954                          
   955  9028 a2c2                       ldx #%11000010          ;; detach both drives, don't attach real drives
   956  902a 20019c                     jsr dos_attach
   957                          
   958  902d 4cf78c                     jmp return_from_trap_with_carry_flag
   959                          
   960                          ;;         ========================
   961                          
   962                          trap_dos_attach:
   963                          
   964                                  +Checkpoint "trap_dos_attach"
   965                          
   966  9030 ae41d6                     ldx hypervisor_x
   967  9033 20019c                     jsr dos_attach
   968                          
   969  9036 4cf78c                     jmp return_from_trap_with_carry_flag
   970                          
   971                          ;;         ========================
   972                          
   973                          trap_dos_d81write_en:
   974                          
   975  9039 205290                     jsr dos_d81write_en
   976  903c 4cf78c                     jmp return_from_trap_with_carry_flag
   977                          
   978                          ;;         ========================
   979                          
   980                          trap_dos_get_proc_desc:
   981  903f 2040ad                     jsr hypervisor_setup_copy_region
   982  9042 900b                       bcc @bad
   983  9044 a000                       ldy #0
   984                          @copyloop:
   985  9046 b900bd                     lda currenttask_block,y
   986  9049 9106                       sta (<hypervisor_userspace_copy_vector),y
   987  904b c8                         iny
   988  904c d0f8                       bne @copyloop
   989  904e 38                         sec
   990                          @bad:
   991  904f 4cf78c                     jmp return_from_trap_with_carry_flag
   992                          
   993                          dos_d81write_en:
   994  9052 ad8bd6                     lda $d68b
   995  9055 2903                       and #$03
   996  9057 c903                       cmp #$03
   997  9059 d00c                       bne td81we1
   998  905b 0904                       ora #$04
   999  905d 8d8bd6                     sta $d68b
  1000                          
  1001                                  ;; Mark disk image write-enabled in proces descriptor
  1002  9060 ad11bd                     lda currenttask_d81_image0_flags
  1003  9063 0904                       ora #d81_image_flag_write_en
  1004                          
  1005  9065 38                         sec
  1006  9066 60                         rts
  1007                          
  1008                          td81we1:
  1009                                  ;; No disk image mounted
  1010                                  ;;
  1011                          
  1012                                  +Checkpoint "dos_d81writ_en-FAIL"
  1013                          
  1014  9067 a980                       lda #dos_errorcode_no_such_disk
  1015  9069 8dfcbc                     sta dos_error_code
  1016  906c 18                         clc
  1017  906d 60                         rts
  1018                          
  1019                          ;;         ========================
  1020                          
  1021                          ;; BG: the following are placeholders for the future development
  1022                          
  1023                          trap_dos_getdisksize:
  1024                          trap_dos_getcwd:
  1025                          trap_dos_mkdir:
  1026                          trap_dos_rmdir:
  1027                          trap_dos_seekfile:
  1028                          trap_dos_rename:
  1029                          trap_dos_filedate:
  1030                          trap_dos_gettasklist:
  1031                          trap_dos_sendmessage:
  1032                          trap_dos_receivemessage:
  1033                          trap_dos_writeintotask:
  1034                          trap_dos_readoutoftask:
  1035                          trap_dos_terminateothertask:
  1036                          trap_dos_create_task_native:
  1037                          trap_dos_load_into_task:
  1038                          trap_dos_create_task_c64:
  1039                          trap_dos_create_task_c65:
  1040                          trap_dos_exit_and_switch_to_task:
  1041                          trap_dos_switch_to_task:
  1042                          trap_dos_exit_task:
  1043                          
  1044  906e 4c3582                     jmp invalid_subfunction;;
  1045                          
  1046                          ;;         ========================
  1047                          
  1048                          ;; ======================================================================================
  1049                          ;; ======================================================================================
  1050                          ;; ======================================================================================
  1051                          
  1052                          ;; Clear all file descriptors.
  1053                          ;; This just consists of setting the drive number to $ff,
  1054                          ;; which indicates "no such drive"
  1055                          ;; Drive number field is first byte of file descriptor for convenience
  1056                          
  1057                          dos_clear_filedescriptors:
  1058                          
  1059                                  ;; XXX - This doesn't close the underlying file descriptors!
  1060                                  ;;
  1061  9071 a9ff                       lda #$ff
  1062  9073 8d80bd                     sta currenttask_filedescriptor0
  1063  9076 8da0bd                     sta currenttask_filedescriptor1
  1064  9079 8dc0bd                     sta currenttask_filedescriptor2
  1065  907c 8de0bd                     sta currenttask_filedescriptor3
  1066                          
  1067                                  ;; XXX - Doesn't flush any files open for write
  1068  907f 8db9bc                     sta dos_file_descriptors
  1069  9082 8dc9bc                     sta dos_file_descriptors+$10
  1070  9085 8dd9bc                     sta dos_file_descriptors+$20
  1071  9088 8de9bc                     sta dos_file_descriptors+$30
  1072                          
  1073  908b 38                         sec
  1074  908c 60                         rts
  1075                          
  1076                          ;;         ========================
  1077                          
  1078                          ;; Read partition table from SD card.
  1079                          ;;
  1080                          ;; Add all FAT32 partitions to our list of known disks.
  1081                          ;;
  1082                          ;; This routine assumes that the SD card has been reset and is ready to
  1083                          ;; service requests.
  1084                          ;;
  1085                          ;; XXX - We don't support extended partition tables! Only the old-fashion
  1086                          ;; 4 DOS partitions.  We might get excited and add support for them later
  1087                          ;;
  1088                          dos_read_partitiontable:
  1089                          
  1090                                  ;; clear error code
  1091                                  ;;
  1092  908d a900                       lda #0
  1093  908f 8dfcbc                     sta dos_error_code
  1094                          
  1095                                  ;; Clear the list of known disks
  1096                                  ;;
  1097  9092 200091                     jsr dos_initialise_disklist
  1098                          
  1099  9095 20e990                     jsr dos_read_mbr
  1100  9098 903e                       bcc l_drpt_fail
  1101                          
  1102                                  ;; Make the sector buffer visible
  1103                                  ;;
  1104  909a 2018a2                     jsr sd_map_sectorbuffer
  1105                          
  1106  909d a902                       lda #dos_errorcode_bad_signature
  1107  909f 8dfcbc                     sta dos_error_code
  1108                          
  1109                                  ;; check for $55, $AA MBR signature
  1110                                  ;;
  1111  90a2 adfedf                     lda sd_sectorbuffer+$1FE
  1112  90a5 c955                       cmp #$55
  1113  90a7 d02f                       bne l_drpt_fail
  1114  90a9 adffdf                     lda sd_sectorbuffer+$1FF
  1115  90ac c9aa                       cmp #$AA
  1116  90ae d028                       bne l_drpt_fail
  1117                          
  1118                                  ;; yes, $55AA MBR signature was found
  1119                          
  1120                                  +Checkpoint "Found $55, $AA at $1FE on MBR"
  1121                          
  1122                                  ;; Partitions start at offsets $1BE, $1CE, $1DE, $1EE
  1123                                  ;; so consider each in turn.  Opening the partition causes other sectors to
  1124                                  ;; be read, so we must re-read the MBR between each
  1125                          
  1126                                  ;; get pointer to second half of sector buffer so that we can access the
  1127                                  ;; partition entries as we see fit.
  1128                                  ;;
  1129                          
  1130  90b0 a9be                       lda #<(sd_sectorbuffer+$1BE)
  1131  90b2 8500                       sta <dos_scratch_vector
  1132  90b4 a9df                       lda #>(sd_sectorbuffer+$1BE)
  1133  90b6 8501                       sta <(dos_scratch_vector+1)
  1134                                  +Checkpoint "=== Checking Partition #1 at $01BE"
  1135  90b8 200691                     jsr dos_consider_partition_entry
  1136                          
  1137  90bb 20e990                     jsr dos_read_mbr
  1138  90be 9018                       bcc l_drpt_fail
  1139  90c0 a9ce                       lda #<(sd_sectorbuffer+$1CE)
  1140  90c2 8500                       sta <dos_scratch_vector
  1141                                  +Checkpoint "=== Checking Partition #2 at $01CE"
  1142  90c4 200691                     jsr dos_consider_partition_entry
  1143                          
  1144  90c7 20e990                     jsr dos_read_mbr
  1145  90ca 900c                       bcc l_drpt_fail
  1146  90cc a9de                       lda #<(sd_sectorbuffer+$1DE)
  1147  90ce 8500                       sta <dos_scratch_vector
  1148                                  +Checkpoint "=== Checking Partition #3 at $01DE"
  1149  90d0 200691                     jsr dos_consider_partition_entry
  1150                          
  1151  90d3 20e990                     jsr dos_read_mbr
  1152  90d6 b003                       bcs +
  1153                          l_drpt_fail:
  1154  90d8 4c8491                     jmp drpt_fail
  1155  90db a9ee               +       lda #<(sd_sectorbuffer+$1EE)
  1156  90dd 8500                       sta <dos_scratch_vector
  1157                                  +Checkpoint "=== Checking Partition #4 at $01EE"
  1158  90df 200691                     jsr dos_consider_partition_entry
  1159                          
  1160  90e2 a900                       lda #0
  1161  90e4 8dfcbc                     sta dos_error_code
  1162  90e7 38                         sec
  1163  90e8 60                         rts
  1164                          
  1165                          ;;         ========================
  1166                          
  1167                          dos_read_mbr:
  1168                          
  1169                                  ;; Offset zero on disk
  1170                                  ;;
  1171                          
  1172  90e9 a900                       lda #0
  1173  90eb 8d81d6                     sta sd_address_byte0
  1174  90ee 8d82d6                     sta sd_address_byte1
  1175  90f1 8d83d6                     sta sd_address_byte2
  1176  90f4 8d84d6                     sta sd_address_byte3
  1177                          
  1178                                  +Checkpoint "Reading MBR @ 0x00000000"
  1179                          
  1180                                  ;; Read sector
  1181                                  ;;
  1182  90f7 202da2                     jsr sd_readsector
  1183  90fa b003                       bcs +
  1184  90fc 4c8491                     jmp drpt_fail
  1185  90ff 60                 +       rts
  1186                          
  1187                          ;;         ========================
  1188                          
  1189                          dos_initialise_disklist:
  1190                          
  1191  9100 a900                       lda #0
  1192  9102 8d01bc                     sta dos_disk_count
  1193  9105 60                         rts
  1194                          
  1195                          ;;         ========================
  1196                          
  1197                          dos_consider_partition_entry:
  1198                          
  1199  9106 a900                       lda #$00
  1200  9108 8dfcbc                     sta dos_error_code
  1201                          
  1202                                  ;; Offset within partition table entry of partition type
  1203                                  ;;
  1204                                  ;; BG: make this a hash-define
  1205                                  ;;
  1206  910b a004                       ldy #$04
  1207                          
  1208                                  ;; Get partition type byte
  1209                                  ;;
  1210  910d b100                       lda (<dos_scratch_vector),y
  1211                          
  1212                                  ;; We like FAT32 partitions, whether LBA or CHS addressed, although we actually
  1213                                  ;; use LBA addressing.  XXX - Can this cause problems for CHS partitions?
  1214                                  ;; (SD cards which must really use LBA, can still show up with CHS partitions!
  1215                                  ;;  this is really annoying.)
  1216                                  ;;
  1217  910f c90c                       cmp #constant_partition_type_fat32_lba        ;; compare with 0x0C
  1218  9111 f02c                       beq partitionisinteresting_lba
  1219                          
  1220  9113 c90b                       cmp #constant_partition_type_fat32_chs        ;; compare with 0x0B
  1221  9115 f02b                       beq partitionisinteresting_chs
  1222                          
  1223  9117 c941                       cmp #constant_partition_type_megea65_sys ;; compare with 0x41
  1224  9119 f008                       beq partitionisinteresting_mega65sys
  1225                          
  1226  911b a901                       lda #dos_errorcode_partition_not_interesting
  1227  911d 8dfcbc                     sta dos_error_code
  1228  9120 4c8291                     jmp partitionisnotinteresting
  1229                          
  1230                          ;;         ========================
  1231                          
  1232                          partitionisinteresting_mega65sys:
  1233                          
  1234                                  +Checkpoint "MEGA65 System Partition (type=0x41)"
  1235                          
  1236                                  ;; Only one system partition
  1237  9123 adfebc                     lda syspart_present
  1238  9126 f003                       beq +
  1239  9128 4c8491                     jmp partitionerror
  1240                          +
  1241                                  ;; Store start and length of System partition
  1242                                  ;; (These are the first two fields of the syspart structure
  1243                                  ;;  to facilitate a simple copy here)
  1244  912b a008                       ldy #$08
  1245  912d a200                       ldx #$00
  1246                          
  1247  912f b100               spc1:   lda (<dos_scratch_vector),y
  1248  9131 9dc0bb                     sta syspart_structure,x
  1249  9134 e8                         inx
  1250  9135 c8                         iny
  1251  9136 c010                       cpy #$10
  1252  9138 d0f5                       bne spc1
  1253                          
  1254  913a 205e82                     jsr syspart_open
  1255  913d 38                         sec
  1256  913e 60                         rts
  1257                          
  1258                          partitionisinteresting_lba:
  1259                          
  1260                                  +Checkpoint "Partn has fat32_lba (type=0x0c)"
  1261                          
  1262  913f 4c4591                     jmp partitionisinteresting
  1263                          
  1264                          partitionisinteresting_chs:
  1265                          
  1266                                  +Checkpoint "WARN:Partn has fat32_chs (type=0x0b)"
  1267                          
  1268  9142 4c4591                     jmp partitionisinteresting
  1269                          
  1270                          ;;         ========================
  1271                          
  1272                          partitionisinteresting:
  1273                          
  1274                                  ;; Make sure we have a spare disk slot
  1275  9145 ad01bc                     lda dos_disk_count
  1276  9148 c906                       cmp #dos_max_disks
  1277  914a d003                       bne +
  1278  914c 4c8491                     jmp partitionerror
  1279                          +
  1280                                  ;; Partition is FAT32 (either 0B or 0C), so add it to the list
  1281                          
  1282                                  ;; Disk structures in dos_disk_table are 32 bytes long, so shift count left
  1283                                  ;; 5 times to get offset in dos disk list table
  1284                                  ;;
  1285                                  ;; initially, dos_disk_count=00 so shifting results in =00
  1286                                  ;;
  1287  914f ad01bc                     lda dos_disk_count
  1288  9152 0a                         asl
  1289  9153 0a                         asl
  1290  9154 0a                         asl
  1291  9155 0a                         asl
  1292  9156 0a                         asl
  1293  9157 aa                         tax
  1294                          
  1295                                  ;; Copy relevant fields into place
  1296                                  ;; These are start of partition and length of partition (both in sectors)
  1297                                  ;; XXX - This requires that our dos_disk_table has these two fields together
  1298                                  ;; at the start of the structure.
  1299                                  ;;
  1300  9158 a008                       ldy #$08        ;; partition_lba_begin (4 bytes)
  1301                          
  1302  915a b100               dcpe1:  lda (<dos_scratch_vector),y
  1303  915c 9d00bb                     sta dos_disk_table,x
  1304  915f e8                         inx
  1305  9160 c8                         iny
  1306  9161 c010                       cpy #$10        ;; partition_num_sectors (4 bytes)
  1307  9163 d0f5                       bne dcpe1
  1308                          
  1309                                  ;; Examine the internals of the partition to get the remaining fields.
  1310                                  ;; At this point we no longer use the contents of the MBR
  1311                                  ;;
  1312                          
  1313  9165 208691                     jsr dos_disk_openpartition
  1314  9168 901a                       bcc partitionerror
  1315                          
  1316                          !if DEBUG_HYPPO {
  1317                                  jsr dump_disk_table
  1318                          }
  1319                          
  1320                                  ;; Check if partition is bootable (or the only partition)
  1321                                  ;; If so, make the partition the default disk
  1322                                  ;;
  1323                                  ;; BG, we should examine all four partitions before setting the default disk
  1324                                  ;;
  1325  916a ad01bc                     lda dos_disk_count
  1326  916d f006                       beq makethispartitionthedefault
  1327  916f a000                       ldy #$00
  1328  9171 b100                       lda (<dos_scratch_vector),y
  1329  9173 1008                       bpl dontmakethispartitionthedefault
  1330                          
  1331                          
  1332                          makethispartitionthedefault:
  1333  9175 ad01bc                     lda dos_disk_count
  1334  9178 8d02bc                     sta dos_default_disk
  1335                          
  1336                          !if DEBUG_HYPPO {
  1337                                  ;; print out this message to Checkpoint
  1338                                  ;;
  1339                          
  1340                                  tax                                ;; convert .X to char-representation for display
  1341                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  1342                                  sty mtptd
  1343                                  stx mtptd+1
  1344                          
  1345                                  jsr checkpoint
  1346                                  !8 0
  1347                                  !text "dos_default_disk = "
  1348                          mtptd:  !text "xx"
  1349                                  !8 0
  1350                          
  1351                          ;; jsr dump_disk_table
  1352                          }
  1353                          
  1354                                  ;; return OK
  1355                                  ;;
  1356  917b 38                         sec
  1357  917c 60                         rts
  1358                          
  1359                          ;;         ========================
  1360                          
  1361                          dontmakethispartitionthedefault:
  1362                          
  1363  917d ae01bc                     ldx dos_disk_count
  1364                          
  1365                          !if DEBUG_HYPPO {
  1366                                  ;; print out this message to Checkpoint
  1367                                  ;;
  1368                          
  1369                                                                  ;; convert .X to char-representation for display
  1370                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  1371                                  stx mtptd2
  1372                          
  1373                                  jsr checkpoint
  1374                                  !8 0
  1375                                  !text "Part#"
  1376                          mtptd2: !text "x NOT set to the default_disk"
  1377                                  !8 0
  1378                          
  1379                          ;; jsr dump_disk_table
  1380                          }
  1381                          
  1382                                  ;; return OK
  1383                                  ;;
  1384                          
  1385  9180 38                         sec
  1386  9181 60                         rts
  1387                          
  1388                          ;;         ========================
  1389                          
  1390                          partitionisnotinteresting:
  1391                          
  1392                                  ;; return OK
  1393                                  ;;
  1394                          
  1395                                  +Checkpoint "Partition not interesting"
  1396                          
  1397  9182 38                         sec
  1398  9183 60                         rts
  1399                          
  1400                          ;;         ========================
  1401                          
  1402                          drpt_fail:
  1403                          
  1404                                  ;; error code will already be set
  1405                          
  1406                          partitionerror:
  1407                          
  1408                                  ;; return ERROR
  1409                          
  1410                          !if DEBUG_HYPPO {
  1411                                  ldx dos_error_code                ;; convert .X to char-representation for display
  1412                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  1413                                  sty perr
  1414                                  stx perr+1
  1415                          
  1416                                  jsr checkpoint
  1417                                  !8 0
  1418                                  !text "partitionerror="
  1419                          perr:   !text "xx"
  1420                                  !8 0
  1421                          }
  1422                          
  1423  9184 18                         clc
  1424  9185 60                         rts
  1425                          
  1426                          dos_disk_openpartition:
  1427                          
  1428                                  +Checkpoint "dos_disk_openpartition: (examine Vol ID)"
  1429                          
  1430                                  ;; A contains the disk number we are trying to open.
  1431                                  ;;
  1432  9186 a900                       lda #$00
  1433  9188 8dfcbc                     sta dos_error_code
  1434                          
  1435                                  ;; Load first sector of file system and parse.
  1436                                  ;; This is the Volume ID pointed to by the PartitionTable in the MBR
  1437                          
  1438                                  ;; Get offset of disk entry in our disk table structure
  1439                                  ;;
  1440  918b ad01bc                     lda dos_disk_count
  1441  918e 0a                         asl
  1442  918f 0a                         asl
  1443  9190 0a                         asl
  1444  9191 0a                         asl
  1445  9192 0a                         asl
  1446  9193 8d04bc                     sta dos_disk_table_offset
  1447                          
  1448                                  ;; Now pull the start sector from the structure and get ready to request
  1449                                  ;; that structure from the SD card.
  1450                                  ;;
  1451  9196 0900                       ora #fs_start_sector        ;; OR with 00 does nothing, but this is the standard
  1452  9198 a8                         tay
  1453  9199 a200                       ldx #$00
  1454                          
  1455  919b b900bb             ddop1:  lda dos_disk_table,y
  1456  919e 9d81d6                     sta sd_address_byte0,x
  1457  91a1 c8                         iny
  1458  91a2 e8                         inx
  1459  91a3 e004                       cpx #$04
  1460  91a5 d0f4                       bne ddop1
  1461                          
  1462                          !if DEBUG_HYPPO {
  1463                          jsr dumpsectoraddress        ;; debugging
  1464                          }
  1465                          
  1466  91a7 202da2                     jsr sd_readsector
  1467  91aa 90d8                       bcc partitionerror
  1468                          
  1469                                  ;; We now have the sector, so parse.
  1470                          
  1471  91ac 2018a2                     jsr sd_map_sectorbuffer
  1472                          
  1473                          ;;         ========================
  1474                          
  1475                                  ;; Check for 55/AA singature (again, for the Vol-ID of this partition)
  1476                                  ;;
  1477                          
  1478  91af a902                       lda #dos_errorcode_bad_signature
  1479  91b1 8dfcbc                     sta dos_error_code
  1480                          
  1481  91b4 adfedf                     lda sd_sectorbuffer+$1FE
  1482  91b7 c955                       cmp #$55
  1483  91b9 f003                       beq ddop1a
  1484  91bb 4c8491                     jmp partitionerror
  1485                          ddop1a:
  1486  91be adffdf                     lda sd_sectorbuffer+$1FF
  1487  91c1 c9aa                       cmp #$AA
  1488  91c3 f003                       beq ddop1b
  1489  91c5 4c8491                     jmp partitionerror
  1490                          ddop1b:
  1491                                  +Checkpoint "Partn has $55, $AA GOOD"
  1492                          
  1493                                  ;; Start populating fields
  1494                          
  1495                          ;;         BG assumes this is all correct...
  1496                          
  1497                          ;;         ========================
  1498                          
  1499                                  ;; Filter out obviously FAT16/FAT12 file systems
  1500                                  ;;
  1501  91c8 a903                       lda #dos_errorcode_is_small_fat
  1502  91ca 8dfcbc                     sta dos_error_code
  1503                                  ;;
  1504                                  ;; BG i think we dont need to check this for minimal operation
  1505                                  ;;
  1506                                  ;; for fat32, the 11'th entry is unused, http:;;www.easeus.com/resource/fat32-disk-structure.htm
  1507                                  ;;
  1508  91cd ad11de                     lda sd_sectorbuffer+$11        ;; this is NOT the MBSyte of the number of FATs
  1509  91d0 d0b2                       bne partitionerror
  1510                          
  1511                          ;;         ========================
  1512                          
  1513                                  ;; get # copies of fat
  1514                                  ;;
  1515  91d2 ad04bc                     lda dos_disk_table_offset
  1516  91d5 0917                       ora #fs_fat32_fat_copies        ;; is $17
  1517  91d7 a8                         tay
  1518  91d8 ad10de                     lda sd_sectorbuffer+$10        ;; should be 2
  1519  91db 9900bb                     sta dos_disk_table,y
  1520                          
  1521                          ;;         ========================
  1522                          
  1523                                  ;; With root directory entries = 0, the reserved sector count
  1524                                  ;; is the number of reserved sectors, plus (copies of fat) *
  1525                                  ;; (sectors in one copy of the fat).
  1526                                  ;; the first FAT begins immediately after the reserved sectors
  1527                          
  1528                                  ;; Determine system sector count
  1529                                  ;; (= reserved sectors + fat_count * fat_sectors)
  1530                                  ;; $20 + $EE5 + $EE5 = $1DEA
  1531                                  ;; plus partition offset = $81 = $1E6B
  1532                                  ;; partition length = $3BAF7F
  1533                                  ;; $08 sectors / cluster
  1534                                  ;; so data sectors in partition = $3BAF7F - $1DEA = $3B9195
  1535                                  ;; = $77232 clusters
  1536                          
  1537                                  ;; BG does not like the above reasoning, ie fixed number of reserved sectors.
  1538                          
  1539                                  ;; Reserved sector field on disk is only 2 bytes!
  1540                                  ;;
  1541  91de ad04bc                     lda dos_disk_table_offset
  1542  91e1 090d                       ora #fs_fat32_system_sectors        ;; is $0D
  1543  91e3 a8                         tay
  1544  91e4 a200                       ldx #$00
  1545                          
  1546  91e6 bd0ede             ddop10: lda sd_sectorbuffer+$0E,x
  1547  91e9 9900bb                     sta dos_disk_table,y
  1548  91ec c8                         iny
  1549  91ed e8                         inx
  1550  91ee e002                       cpx #$02
  1551  91f0 d0f4                       bne ddop10
  1552                          
  1553                          ;;         ========================
  1554                          
  1555                                  ;; Store length of one copy of the FAT
  1556                                  ;;
  1557  91f2 ad04bc                     lda dos_disk_table_offset
  1558  91f5 0909                       ora #fs_fat32_length_of_fat        ;; is $09
  1559  91f7 a8                         tay
  1560  91f8 a200                       ldx #$00
  1561                          
  1562  91fa bd24de             ddop11: lda sd_sectorbuffer+$24,x        ;; sectors_per_fat
  1563  91fd 9900bb                     sta dos_disk_table,y
  1564  9200 c8                         iny
  1565  9201 e8                         inx
  1566  9202 e004                       cpx #$04
  1567  9204 d0f4                       bne ddop11
  1568                          
  1569                          ;;         ========================
  1570                          
  1571                                  ;; Get number of reserved clusters.  We only allow upto 255 reserved
  1572                                  ;; clusters, so report an error if the upper three bytes are not zero
  1573                                  ;;
  1574                                  ;; BG: why only 255 reserved clusters? and isnt it reserved sectors instead?
  1575                                  ;; and seems to be looking at the root_dir_first_cluster
  1576                                  ;;
  1577  9206 a904                       lda #dos_errorcode_too_many_reserved_clusters
  1578  9208 8dfcbc                     sta dos_error_code
  1579                          
  1580  920b ad2dde                     lda sd_sectorbuffer+$2C+1
  1581  920e 0d2ede                     ora sd_sectorbuffer+$2C+2
  1582  9211 0d2fde                     ora sd_sectorbuffer+$2C+3
  1583                          
  1584                                  ;; XXX - 16 bit BNE should be fine here! Why doesn't it work?
  1585                                  ;;         bne partitionerror
  1586                          
  1587  9214 f003                       beq ddop11ok
  1588  9216 4c8491                     jmp partitionerror
  1589                          
  1590                          ;;         ========================
  1591                          
  1592                          ddop11ok:
  1593                          
  1594                                  ;; <64K reserved clusters, so file system passes this test -- just copy number
  1595                                  ;;
  1596                                  ;; BG does not agree with the logic, of <64k reservedclusters to passes
  1597                                  ;; BG the code below could be changed to be same as lda,ora,tay
  1598                                  ;;
  1599                                  ;; BG, so by design, we reject any Vol_ID that has
  1600                                  ;; RootDirFirstCluster[3..0] not equal to $00000002
  1601                                  ;;
  1602  9219 ac04bc                     ldy dos_disk_table_offset
  1603  921c ad2cde                     lda sd_sectorbuffer+$2C        ;; 2c is the ClusterNumberOfFirstRootDir
  1604  921f 990fbb                     sta dos_disk_table + fs_fat32_reserved_clusters,y
  1605                          
  1606                          ;; Checkpoint("dos_disk_table-1")
  1607                          ;; jsr dump_disk_table        ; debugging
  1608                          
  1609                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00 = (fs_start_sector),                       (fs_sector_count)
  1610                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02 = type, (sectorsPerFat),(reservedSectors),(reservedClusters)
  1611                          ;; dos_disk_table[10-17] = 00,00,00,00,00,00,00,02 = x..x                                ,(fs_fat32_fat_copies)
  1612                          ;; dos_disk_table[18-1F] = 00,00,00,00,xx,xx,xx,xx
  1613                          
  1614                          ;;         ========================
  1615                          
  1616                                  ;; Now work out the sector of cluster 0, by adding:
  1617                                  ;;   fs_fat32_system_sectors
  1618                                  ;; + the length of each FAT
  1619                                  ;; + start of partition,
  1620                                  ;; and store this result in dos_disk_table[18..1B]
  1621                                  ;;
  1622                                  ;; For efficiency, we pull the fields we need out of the sector buffer,
  1623                                  ;; instead of working out their offsets in the dos_disk_table structure.
  1624                                  ;; BG disagree, we know the offsets of the fields in dos_disk_table
  1625                          
  1626                                  ;; Start with fs_fat32_system_sectors (which is 16 bits), then pad MSBs with zero
  1627                                  ;;
  1628  9222 ad04bc                     lda dos_disk_table_offset
  1629  9225 090d                       ora #fs_fat32_system_sectors        ;; is $0D
  1630  9227 a8                         tay
  1631  9228 ad04bc                     lda dos_disk_table_offset
  1632  922b 0918                       ora #fs_fat32_cluster0_sector        ;; is $18
  1633  922d aa                         tax
  1634  922e a302                       ldz #$02
  1635                          
  1636  9230 b900bb             ddop2:  lda dos_disk_table,y
  1637  9233 9d00bb                     sta dos_disk_table,x
  1638  9236 c8                         iny
  1639  9237 e8                         inx
  1640  9238 3b                         dez
  1641  9239 d0f5                       bne ddop2
  1642                          
  1643                                  ;; clear top 16 bits of cluster0_sector (dos_disk_table[1A,1B])
  1644                                  ;;
  1645                                  ;; BG: why tza, just do lda#$00
  1646  923b 6b                         tza
  1647  923c 9d00bb                     sta dos_disk_table+0,x
  1648  923f 9d01bb                     sta dos_disk_table+1,x
  1649                          
  1650                          ;; Checkpoint("dos_disk_table-2")
  1651                          ;; jsr dump_disk_table        ; debugging
  1652                          
  1653                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1654                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1655                          ;; dos_disk_table[10-17] = 00,00,00,00,00,00,00,02
  1656                          ;; dos_disk_table[18-1F] = 38,02,00,00,xx,xx,xx,xx -> $00000238
  1657                          
  1658                          
  1659                          ;;         ========================
  1660                          
  1661                                  ;; Now add length of fat for each copy of the fat
  1662                                  ;;
  1663  9242 a905                       lda #dos_errorcode_not_two_fats
  1664  9244 8dfcbc                     sta dos_error_code
  1665                          
  1666                                  ;; BG #FATs should be sourced from dos_disk_table[17], not from buffer+$10
  1667                          
  1668  9247 ab10de                     ldz sd_sectorbuffer+$10         ;; # of FAT copies
  1669  924a f004                       beq l_partitionerror            ;; There must be at least one copy of the FAT!
  1670  924c c202                       cpz #2
  1671  924e f003                       beq ddop_addnextfatsectors
  1672                          l_partitionerror:
  1673  9250 4c8491                     jmp partitionerror
  1674                          
  1675                          ddop_addnextfatsectors:
  1676  9253 ad04bc                     lda dos_disk_table_offset
  1677  9256 0918                       ora #fs_fat32_cluster0_sector   ;; is $18
  1678  9258 a8                         tay
  1679  9259 a200                       ldx #$00
  1680  925b 18                         clc
  1681  925c 08                         php                             ;; push processor-status (to remember the carry-flag)
  1682                          
  1683  925d 28                 ddop12: plp                             ;; pull processor-status
  1684  925e b900bb                     lda dos_disk_table,y            ;; cluster0_sector
  1685  9261 7d24de                     adc sd_sectorbuffer+$24,x       ;; sectors per fat ;BG should load from dos_disk_table[09]
  1686  9264 9900bb                     sta dos_disk_table,y            ;; cluster0_sector
  1687  9267 08                         php
  1688  9268 c8                         iny
  1689  9269 e8                         inx
  1690  926a e004                       cpx #$04
  1691  926c d0ef                       bne ddop12
  1692                          
  1693  926e 28                         plp
  1694                                  ;;
  1695                                  ;; as Z was initially 2 (#FATs), we do this loop twice
  1696                                  ;; resulting in 2x the sectorsPerFat added to "reservedSectors".
  1697  926f 3b                         dez
  1698  9270 d0e1                       bne ddop_addnextfatsectors
  1699                          
  1700                          ;; Checkpoint("dos_disk_table-3")
  1701                          ;; jsr dump_disk_table        ; debugging
  1702                          
  1703                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1704                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1705                          ;; dos_disk_table[10-17] = 00,00,00,00,00,00,00,02
  1706                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx -> $00000238 + ($000003e6 + $000003e6) = $00000A04
  1707                          
  1708                          ;; BG does not agree with the calculations below, why do we need to calculate it this way?
  1709                          
  1710                                  ;; Next, we temporarily need the number of data sectors, so that we can work
  1711                                  ;; out the number of clusters in the file system.
  1712                                  ;; This is the total number of sectors in the partition, minus the number of
  1713                                  ;; reserved sectors.
  1714                          
  1715                                  ;; Subtract (cluster 0 sector = 32 bits) from
  1716                                  ;; (length of filesystem in sectors = 32 bits)
  1717                          
  1718  9272 ad04bc                     lda dos_disk_table_offset
  1719  9275 0918                       ora #fs_fat32_cluster0_sector   ;; is $18
  1720  9277 aa                         tax
  1721  9278 ad04bc                     lda dos_disk_table_offset
  1722  927b 0912                       ora #fs_fat32_cluster_count     ;; is $12
  1723  927d a8                         tay
  1724  927e 38                         sec
  1725  927f ad20de                     lda sd_sectorbuffer+$20+0     ;; from FAT spec, this is number of sectors in partition
  1726  9282 fd00bb                     sbc dos_disk_table+0,x        ;; x=$18 initially
  1727  9285 9900bb                     sta dos_disk_table+0,y        ;; y=$12 initially
  1728  9288 ad21de                     lda sd_sectorbuffer+$20+1
  1729  928b fd01bb                     sbc dos_disk_table+1,x
  1730  928e 9901bb                     sta dos_disk_table+1,y
  1731  9291 ad22de                     lda sd_sectorbuffer+$20+2
  1732  9294 fd02bb                     sbc dos_disk_table+2,x
  1733  9297 9902bb                     sta dos_disk_table+2,y
  1734  929a ad23de                     lda sd_sectorbuffer+$20+3
  1735  929d fd03bb                     sbc dos_disk_table+3,x
  1736  92a0 9903bb                     sta dos_disk_table+3,y
  1737                          
  1738                          ;;         ========================
  1739                          
  1740                          get_sec_per_cluster:
  1741                                  ;; Get sectors per cluster (and store in dos_disk_table entry)
  1742                                  ;; (this gets destoryed below, so we have to re-read it again after)
  1743                                  ;;
  1744  92a3 ad04bc                     lda dos_disk_table_offset
  1745  92a6 0916                       ora #fs_fat32_sectors_per_cluster        ;; is $16
  1746  92a8 a8                         tay
  1747  92a9 ad0dde                     lda sd_sectorbuffer+$0D
  1748  92ac 9900bb                     sta dos_disk_table,y
  1749                          
  1750                          ;; Checkpoint("dos_disk_table-4")
  1751                          ;; jsr dump_disk_table        ; debugging
  1752                          
  1753                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1754                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1755                          ;; dos_disk_table[10-17] = 00,00,FC,95,0F,00,08,02 -> new data appears
  1756                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1757                          
  1758                          
  1759                          ;;         ========================
  1760                          
  1761                                  ;; Now divide number of sectors available for clusters by the number of
  1762                                  ;; sectors per cluster to obtain the number of actual clusters in the file
  1763                                  ;; system.  Since clusters must contain a power-of-two number of sectors,
  1764                                  ;; we can implement the division using a simple shift.
  1765                          
  1766                                  ;; copy number of sectors into number of sectors ready for shifting down
  1767                          
  1768                                  ;; Put number of sectors per cluster into Z, and don't shift if there is only
  1769                                  ;; one sector per cluster.
  1770                                  ;;
  1771  92af ad0dde                     lda sd_sectorbuffer+$0D            ;; because of the checkpoint message above
  1772  92b2 4b                         taz                                ;; why store .A in .Z anyway
  1773                          
  1774  92b3 29fe                       and #$fe        ;; #%1111.1110
  1775  92b5 f01e                       beq ddop_gotclustercount
  1776                          
  1777                          ddop14:
  1778                                  ;; Divide cluster count by two.  This is a 32-bit value, so we have to use
  1779                                  ;; ROR to do the shift, and propagate the carry bits between the bytes.
  1780                                  ;; This also entails doing it from the last byte, backwards.
  1781                          
  1782                                  ;; Get offset of start of (sectors_per_cluster) field
  1783                                  ;;
  1784  92b7 ad04bc                     lda dos_disk_table_offset
  1785  92ba 0912                       ora #fs_fat32_cluster_count        ;; is $12
  1786                          
  1787                                  ;; get offset of last byte in this field
  1788                                  ;;
  1789  92bc 18                         clc
  1790  92bd 6903                       adc #$03
  1791  92bf a8                         tay
  1792                          
  1793  92c0 a203                       ldx #$03
  1794  92c2 18                         clc
  1795                          
  1796  92c3 b900bb             ddop15: lda dos_disk_table,y
  1797  92c6 6a                         ror
  1798  92c7 9900bb                     sta dos_disk_table,y
  1799  92ca 88                         dey
  1800  92cb ca                         dex
  1801  92cc 10f5                       bpl ddop15
  1802                          
  1803  92ce 6b                         tza
  1804  92cf 4a                         lsr
  1805  92d0 4b                         taz
  1806  92d1 29fe                       and #$fe
  1807  92d3 d0e2                       bne ddop14
  1808                          
  1809                          ddop_gotclustercount:
  1810                          
  1811                          ;; Checkpoint("dos_disk_table-5")
  1812                          ;; jsr dump_disk_table        ; debugging
  1813                          
  1814                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1815                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1816                          ;; dos_disk_table[10-17] = 00,00,AF,7C,00,00,08,02 -> new data appears
  1817                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1818                          
  1819                          
  1820                                  ;; Re-get sectors per cluster (and store in dos_disk_table entry)
  1821                                  ;; (this was destroyed in the calculation above)
  1822                                  ;;
  1823  92d5 ad04bc                     lda dos_disk_table_offset
  1824  92d8 0916                       ora #fs_fat32_sectors_per_cluster        ;; is $16
  1825  92da a8                         tay
  1826  92db ad0dde                     lda sd_sectorbuffer+$0D
  1827  92de 9900bb                     sta dos_disk_table,y
  1828                          
  1829                          ;; Checkpoint("dos_disk_table-6")
  1830                          ;; jsr dump_disk_table        ; debugging
  1831                          
  1832                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1833                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1834                          ;; dos_disk_table[10-17] = 00,00,AF,7C,00,00,08,02
  1835                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1836                          
  1837                          ;;         ========================
  1838                          
  1839                                  ;; filter out non-FAT32 filesystems
  1840                                  ;; NOTE: FAT32 can have as few as 65525 clusters, but we do not support
  1841                                  ;; such file systems, which should be rare, anyway.
  1842                          
  1843  92e1 ad04bc                     lda dos_disk_table_offset
  1844  92e4 0916                       ora #fs_fat32_sectors_per_cluster        ;; is $16
  1845  92e6 a8                         tay
  1846  92e7 a906                       lda #dos_errorcode_too_few_clusters
  1847  92e9 8dfcbc                     sta dos_error_code
  1848                          
  1849  92ec b903bb                     lda dos_disk_table+3,y        ;; BG this seems to creep-out-of-bounds from +16 to +19
  1850  92ef 1902bb                     ora dos_disk_table+2,y
  1851  92f2 d003                       bne +
  1852  92f4 4c8491                     jmp partitionerror
  1853                          +
  1854                                  ;; Now get cluster of root directory.
  1855                                  ;;
  1856  92f7 ad04bc                     lda dos_disk_table_offset
  1857  92fa 0910                       ora #fs_fat32_root_dir_cluster                ;; is $10
  1858  92fc a8                         tay
  1859                          
  1860  92fd a203                       ldx #$03
  1861  92ff bd2cde             ddop16: lda sd_sectorbuffer+$2C,x        ;; +$2c is rootDirFirstCluster[3..0]
  1862  9302 9900bb                     sta dos_disk_table,y
  1863  9305 ca                         dex
  1864                          ;; BG should there be a "dey" here somewhere?
  1865  9306 10f7                       bpl ddop16
  1866                          
  1867                                  ;; We have now set the following fields:
  1868                                  ;;
  1869                                  ;; fs_fat32_length_of_fat
  1870                                  ;; fs_fat32_system_sectors
  1871                                  ;; fs_fat32_reserved_clusters
  1872                                  ;; fs_fat32_root_dir_cluster
  1873                                  ;; 12,13,14,15 ?
  1874                                  ;; fs_fat32_sectors_per_cluster
  1875                                  ;; fs_fat32_fat_copies
  1876                                  ;; fs_fat32_cluster0_sector
  1877                          
  1878                                  ;; Our caller has set:
  1879                                  ;;
  1880                                  ;; fs_start_sector
  1881                                  ;; fs_sector_count
  1882                          
  1883                          ;; Checkpoint("dos_disk_table-7")
  1884                          ;; jsr dump_disk_table        ; debugging
  1885                          
  1886                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1887                          ;; dos_disk_table[08-0F] = 00,E6,03,00,00,38,02,02
  1888                          ;; dos_disk_table[10-17] = 02,00,AF,7C,00,00,08,02 -> new data appears in [10]
  1889                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1890                          
  1891                                  ;; So all that is left for us is to set fs_type_and_source to $0F
  1892                                  ;; to indicate FAT32 filesystem on the SD card ...
  1893                                  ;;
  1894  9308 ad04bc                     lda dos_disk_table_offset
  1895  930b 0908                       ora #fs_type_and_source                ;; is $08
  1896  930d a8                         tay
  1897  930e a90f                       lda #$0f
  1898  9310 9900bb                     sta dos_disk_table,y
  1899                          
  1900                          ;; jsr dump_disk_table        ; debugging
  1901                          
  1902                          ;; dos_disk_table[00-07] = 00,08,00,00,00,A0,0F,00
  1903                          ;; dos_disk_table[08-0F] = 0F,E6,03,00,00,38,02,02 -> new data appears in [08]
  1904                          ;; dos_disk_table[10-17] = 02,00,AF,7C,00,00,08,02
  1905                          ;; dos_disk_table[18-1F] = 04,0A,00,00,xx,xx,xx,xx
  1906                          
  1907                                  +Checkpoint "FAT32 partition data copied to dos_disk_table"
  1908                          
  1909                                  ;; ... and increment the number of disks we know
  1910  9313 ee01bc                     inc dos_disk_count
  1911                          
  1912                          dos_return_success:
  1913                          
  1914                                  ;; Return success
  1915                                  ;;
  1916  9316 a900                       lda #$00
  1917  9318 8dfcbc                     sta dos_error_code
  1918                          
  1919  931b 38                         sec
  1920  931c 60                         rts
  1921                          
  1922                          ;;         ========================
  1923                          ;;         ========================
  1924                          
  1925                          dos_return_error:
  1926                          
  1927  931d 8dfcbc                     sta dos_error_code
  1928                          
  1929                          dos_return_error_already_set:
  1930                          
  1931  9320 18                         clc
  1932  9321 60                         rts
  1933                          
  1934                          ;;         ========================
  1935                          
  1936                          dos_set_current_disk:
  1937                          
  1938                                  ;; Is disk number valid?
  1939                                  ;;
  1940                                  ;; INPUT: .X = disk
  1941                                  ;;
  1942                          
  1943  9322 ec01bc                     cpx dos_disk_count
  1944  9325 9007                       bcc + 			; Should this be BCC or BMI?
  1945                          
  1946  9327 a980                       lda #dos_errorcode_no_such_disk
  1947  9329 8dfcbc                     sta dos_error_code
  1948  932c 18                         clc
  1949  932d 60                         rts
  1950                          
  1951                          +
  1952  932e 8e03bc                     stx dos_disk_current_disk
  1953  9331 8a                         txa
  1954  9332 0a                         asl
  1955  9333 0a                         asl
  1956  9334 0a                         asl
  1957  9335 0a                         asl
  1958  9336 0a                         asl
  1959  9337 8d04bc                     sta dos_disk_table_offset
  1960                          
  1961                          !if DEBUG_HYPPO {
  1962                                  ldx dos_disk_current_disk        ;; convert .X to char-representation for display
  1963                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  1964                                  sty dscd+0
  1965                                  stx dscd+1
  1966                          
  1967                                  ;; print debug message
  1968                                  ;;
  1969                                  jsr checkpoint
  1970                                  !8 0
  1971                                  !text "dos_set_current_disk="
  1972                          dscd:   !text "xx"
  1973                                  !8 0
  1974                          }
  1975                          
  1976  933a 38                         sec
  1977  933b 60                         rts
  1978                          
  1979                          ;;         ========================
  1980                          
  1981                          dos_cdroot:
  1982                          
  1983                                  ;; Change to root directory on specified disk
  1984                                  ;; (Changes current disk if required)
  1985                                  ;;
  1986                                  ;; INPUT: .X = disk
  1987                          
  1988  933c 202293                     jsr dos_set_current_disk
  1989  933f b002                       bcs dos_cdroot_current_disk_already_set
  1990                          
  1991                                  ;; Could not set disk. Error will be already set
  1992  9341 18                         clc
  1993  9342 60                         rts
  1994                          
  1995                          dos_cdroot_current_disk_already_set:
  1996                          
  1997                                  ;; get offset of disk entry
  1998                                  ;;
  1999                          
  2000  9343 ae04bc                     ldx dos_disk_table_offset
  2001  9346 bd10bb                     lda dos_disk_table + fs_fat32_root_dir_cluster +0,x
  2002  9349 8d05bc                     sta dos_disk_cwd_cluster
  2003  934c bd11bb                     lda dos_disk_table + fs_fat32_root_dir_cluster +1,x
  2004  934f 8d06bc                     sta dos_disk_cwd_cluster+1
  2005                          
  2006  9352 a900                       lda #$00
  2007  9354 8d07bc                     sta dos_disk_cwd_cluster+2        ;; BG here we assume that the 2x MSB's are zero
  2008  9357 8d08bc                     sta dos_disk_cwd_cluster+3
  2009                          
  2010                                  ;; Nothing else to do, as it doesn't actually affect any existing DOS activity,
  2011                                  ;; only future file/directory operations.
  2012                          
  2013  935a 4c1693                     jmp dos_return_success
  2014                          
  2015                          ;;         ========================
  2016                          
  2017                          dos_cluster_to_sector:
  2018                          
  2019                                  ;; convert a cluster number in dos_current_cluster into a sector number
  2020                                  ;; pre-loaded into SD address registers
  2021                                  ;; It is assumed to be on the current disk
  2022                          
  2023  935d a203                       ldx #$03
  2024  935f bdb4bc             dcts0:  lda dos_current_cluster,x
  2025  9362 9d81d6                     sta $d681,x
  2026  9365 ca                         dex
  2027  9366 10f7                       bpl dcts0
  2028                          
  2029                                  ;; subtract 2 from the cluster number (clusters 0 and 1 don't actually exist
  2030                                  ;; on FAT32).
  2031                                  ;;
  2032  9368 a9ff                       lda #$ff
  2033  936a aa                         tax
  2034  936b a8                         tay
  2035  936c 4b                         taz
  2036  936d a9fe                       lda #$fe
  2037  936f 20149e                     jsr sdsector_add_uint32
  2038                          
  2039                                  ;; now shift it left according to fs_sectors_per_cluster
  2040                                  ;;
  2041  9372 ae04bc                     ldx dos_disk_table_offset
  2042  9375 bd16bb                     lda dos_disk_table+fs_fat32_sectors_per_cluster,x
  2043  9378 a8                         tay
  2044  9379 29fe                       and #$fe
  2045  937b f014                       beq multipliedclusternumber
  2046                          
  2047  937d 18                 dcts1:  clc
  2048  937e 2e81d6                     rol $D681
  2049  9381 2e82d6                     rol $D682
  2050  9384 2e83d6                     rol $D683
  2051  9387 2e84d6                     rol $D684
  2052  938a 98                         tya
  2053  938b 4a                         lsr
  2054  938c a8                         tay
  2055  938d 29fe                       and #$fe
  2056  938f d0ec                       bne dcts1
  2057                          
  2058                          multipliedclusternumber:
  2059                          
  2060                                  ;; skip over filesystem reserved and FAT sectors
  2061                                  ;;
  2062  9391 a918                       lda #fs_fat32_cluster0_sector
  2063  9393 20339e                     jsr sdsector_add_uint32_from_disktable
  2064                          
  2065                                  ;; add start sector of partition
  2066                                  ;;
  2067  9396 a900                       lda #fs_start_sector
  2068  9398 20339e                     jsr sdsector_add_uint32_from_disktable
  2069                          
  2070                                  ;; XXX - Check that result does not exceed fs_start_sector+fs_sector_count
  2071                                  ;; and run over into another partition
  2072                          
  2073                                  ;; return success
  2074  939b 38                         sec
  2075  939c 60                         rts
  2076                          
  2077                          ;;         ========================
  2078                          
  2079                          dos_get_free_descriptor:
  2080                          
  2081  939d a200                       ldx #$00
  2082                          
  2083  939f 8a                 dgfd1:  txa
  2084  93a0 0a                         asl
  2085  93a1 0a                         asl
  2086  93a2 0a                         asl
  2087  93a3 0a                         asl
  2088  93a4 a8                         tay
  2089  93a5 b9b9bc                     lda dos_file_descriptors+dos_filedescriptor_offset_diskid,y
  2090  93a8 c9ff                       cmp #$FF
  2091  93aa f00a                       beq dgfd_found_free
  2092  93ac e8                         inx
  2093  93ad e004                       cpx #dos_filedescriptor_max
  2094  93af d0ee                       bne dgfd1
  2095                          
  2096  93b1 a984                       lda #dos_errorcode_too_many_open_files
  2097  93b3 4c1d93                     jmp dos_return_error
  2098                          
  2099                          ;;         ========================
  2100                          
  2101                          dgfd_found_free:
  2102                          
  2103  93b6 8ef9bc                     stx dos_current_file_descriptor
  2104  93b9 8cfabc                     sty dos_current_file_descriptor_offset
  2105                          
  2106                                  ;; Push the address dos_file_descriptors + dos_current_file_descriptor_offset
  2107                                  ;;
  2108  93bc 18                         clc
  2109  93bd a9b9                       lda #<dos_file_descriptors
  2110  93bf 6dfabc                     adc dos_current_file_descriptor_offset
  2111  93c2 a8                         tay
  2112  93c3 a9bc                       lda #>dos_file_descriptors
  2113  93c5 6900                       adc #$00
  2114  93c7 48                         pha
  2115  93c8 5a                         phy
  2116                          
  2117                                  ;; Clear descriptor entry
  2118                                  ;;
  2119  93c9 a00f                       ldy #$0f
  2120  93cb a900                       lda #$00
  2121                          
  2122  93cd 8201               dgfd2:  sta ($01,sp),y
  2123  93cf 88                         dey
  2124  93d0 d0fb                       bne dgfd2
  2125                          
  2126                                  ;; Pop the address
  2127  93d2 68                         pla
  2128  93d3 68                         pla
  2129                          
  2130                                  ;; Return file descriptor in X
  2131  93d4 38                         sec
  2132  93d5 60                         rts
  2133                          
  2134                          ;;         ========================
  2135                          
  2136                          dos_clearall:
  2137                          
  2138                                  ;; Free all file descriptors with extreme prejudice
  2139                                  ;; Clear dos_disk_table
  2140                          
  2141                                  ;; display debug message to uart
  2142                                  ;;
  2143                                  +Checkpoint "dos_clearall:"
  2144                          
  2145  93d6 a9ff                       lda #$ff
  2146  93d8 8db9bc                     sta dos_file_descriptors
  2147  93db 8dc9bc                     sta dos_file_descriptors+$10
  2148  93de 8dd9bc                     sta dos_file_descriptors+$20
  2149  93e1 8de9bc                     sta dos_file_descriptors+$30
  2150  93e4 a200                       ldx #$00
  2151  93e6 a900                       lda #$00
  2152  93e8 9d00bb             dca1:   sta dos_disk_table,x
  2153  93eb e8                         inx
  2154  93ec d0fa                       bne dca1
  2155  93ee 38                         sec
  2156  93ef 60                         rts
  2157                          
  2158                          ;;         ========================
  2159                          
  2160                          dos_closefile:
  2161                          
  2162                                  ;; Close the current file/directory
  2163                                  ;; If the file is read-only, we can just free the file descriptor and return.
  2164                                  ;; XXX - If the file is open for write, we might have a buffer to flush.
  2165                                  ;; (Worry about this when we implement writing. Opening files for write will
  2166                                  ;; probably require the caller to nominate a 512 byte buffer in user-space
  2167                                  ;; memory so that the convenience write-byte routine can work.  The other case,
  2168                                  ;; writing a sector at a time, should just be synchronous, so that there is no
  2169                                  ;; buffering required.)
  2170                          
  2171  93f0 aefabc                     ldx dos_current_file_descriptor_offset
  2172  93f3 bdbabc                     lda dos_file_descriptors + dos_filedescriptor_offset_mode,x
  2173  93f6 c901                       cmp #dos_filemode_readwrite
  2174  93f8 d000                       bne dcf_simple
  2175                          
  2176                                  ;; This is where we would flush the write buffer, and update file length in
  2177                                  ;; directory, if required.  Note that to save space, we don't actually keep the
  2178                                  ;; location of the directory entry of the file in the file descriptor.  This
  2179                                  ;; complicates things somewhat, and we might need to change this.  However, the
  2180                                  ;; file descriptor table must be a power of two in length, and there isn't any
  2181                                  ;; space to double its' size.  Thus we will need a separate table that holds the
  2182                                  ;; directory sector and entry for any file being written to.  We might save a
  2183                                  ;; few bytes by allowing less than dos_filedescriptor_max files to be open for
  2184                                  ;; writing at any point in time.
  2185                          
  2186                          dcf_simple:
  2187                          
  2188  93fa aefabc                     ldx dos_current_file_descriptor_offset
  2189  93fd a9ff                       lda #$ff ;; not allocated flag for file descriptor
  2190  93ff 9db9bc                     sta dos_file_descriptors + dos_filedescriptor_offset_diskid,x
  2191  9402 38                         sec
  2192  9403 60                         rts
  2193                          
  2194                          ;;         ========================
  2195                          
  2196                          dos_chdir:
  2197                                  ;; Works similarly to dos_openfile, i.e. you must first have the
  2198                                  ;; directory in the dirent structure, found via dos_findfile
  2199                          
  2200                                  ;; Check if the file is a directory, if so, refuse to open it.
  2201                                  ;;
  2202  9404 ad66bc                     lda dos_dirent_type_and_attribs
  2203  9407 2910                       and #fs_fat32_attribute_isdirectory
  2204  9409 d005                       bne dcd_is_a_directory
  2205                          
  2206  940b a987                       lda #dos_errorcode_not_a_directory
  2207  940d 4c1d93                     jmp dos_return_error
  2208                          
  2209                          ;;         ========================
  2210                          
  2211                          dcd_is_a_directory:
  2212                          
  2213  9410 204697                     jsr dos_set_current_file_from_dirent
  2214  9413 9047                       bcc l3_dos_return_error_already_set
  2215                          
  2216                                  ;; Close the file descriptor opened by dos_set_current_file_from_dirent
  2217  9415 20f093                     jsr dos_closefile
  2218                          
  2219                                  ;; Copy cluster of requesteed directory into disk CWD cluster
  2220  9418 a203                       ldx #3
  2221  941a bd5ebc             dcd1:	lda dos_dirent_cluster,x
  2222  941d 9d05bc                     sta dos_disk_cwd_cluster,x
  2223  9420 ca                         dex
  2224  9421 10f7                       bpl dcd1
  2225                          
  2226                                  ;; Check if cluster 0. If so, cd to root directory
  2227                                  ;; (its a convention to put cluster 0 in references to the root directory
  2228                                  ;; on some FAT implementations, apparently).
  2229                          
  2230  9423 a203                       ldx #3
  2231  9425 a900                       lda #0
  2232  9427 1d05bc             dcd2:	ora dos_disk_cwd_cluster,x
  2233  942a ca                         dex
  2234  942b 10fa                       bpl dcd2
  2235                          
  2236  942d c900                       cmp #0
  2237  942f d003                       bne @nonZeroCluster
  2238                          
  2239                                  ;; Is cluster 0, so change to root directory
  2240  9431 4c4393                     jmp dos_cdroot_current_disk_already_set
  2241                          
  2242                          @nonZeroCluster:
  2243                                  ;; Return success
  2244  9434 38                         sec
  2245  9435 60                         rts
  2246                          
  2247                          ;;         ========================
  2248                          
  2249                          
  2250                          dos_openfile:
  2251                          
  2252                                  ;; Open the file that is in the dirent structure
  2253                                  ;; (to open a file by arbitrary name, you must first call dos_findfile)
  2254                          
  2255                                  ;; Check if the file is a directory, if so, refuse to open it.
  2256                                  ;;
  2257  9436 ad66bc                     lda dos_dirent_type_and_attribs
  2258  9439 2910                       and #fs_fat32_attribute_isdirectory
  2259  943b f005                       beq dos_not_a_directory
  2260                          
  2261  943d a986                       lda #dos_errorcode_is_a_directory
  2262  943f 4c1d93                     jmp dos_return_error
  2263                          
  2264                          ;;         ========================
  2265                          
  2266                          dos_not_a_directory:
  2267                          
  2268  9442 204697                     jsr dos_set_current_file_from_dirent
  2269  9445 9015                       bcc l3_dos_return_error_already_set
  2270                          
  2271  9447 4c9397                     jmp dos_open_current_file
  2272                          
  2273                          ;;         ========================
  2274                          
  2275                          dos_findfile:
  2276                          
  2277                                  ;; Convenience wrapper around dos_findfirst to make sure that we don't
  2278                                  ;; leave any hanging file descriptors.
  2279                          
  2280  944a 205794                     jsr dos_findfirst
  2281  944d b003                       bcs @found
  2282  944f 4c5c94                     jmp l3_dos_return_error_already_set
  2283                          @found: ;; if we found the file, directory-FD is still open
  2284  9452 20f093                     jsr dos_closefile
  2285  9455 38                         sec
  2286  9456 60                         rts
  2287                          
  2288                          ;;         ========================
  2289                          
  2290                          dos_findfirst:
  2291                          
  2292                                  ;; Search for file in current directory
  2293                                  ;; if found:
  2294                                  ;;    return return carry set
  2295                                  ;;    leaves directory-FD open, to enable call dos_findnext to find more
  2296                                  ;; if not found:
  2297                                  ;;    will return carry clear
  2298                                  ;;    closes directory-FD
  2299                          
  2300                                  ;; Convert name to upper case for searching
  2301                                  ;;
  2302                                  ;; GI. Avoiding uppercase for now, so we find matches on LFN files
  2303                                  ;; But later on, would rather enforce uppercase 'everywhere', even on the files we iterate over in the directory...
  2304                          
  2305  9457 207694                     jsr dos_opendir
  2306  945a b003                       bcs +
  2307                          l3_dos_return_error_already_set:
  2308  945c 4c2093                     jmp dos_return_error_already_set
  2309                          +
  2310                                  ;; Directory is now open, and we can now iterate through directory entries
  2311                                  ;;
  2312  945f 4c6294                     jmp dos_findnext
  2313                          
  2314                          
  2315                          ;;         ========================
  2316                          
  2317                          dos_findnext:
  2318                          
  2319                                  ;; Keep searching in directory for another match
  2320                                  ;; see dos_findfirst above for return state!
  2321                          
  2322                          dff_try_next_entry:
  2323                          
  2324                                  ;; Get next directory entry
  2325                                  ;;
  2326  9462 20d594                     jsr dos_readdir
  2327  9465 b008                       bcs dff_have_next_entry
  2328                          
  2329                                  ;; no more entries, so we close file descriptor for convinience
  2330  9467 20f093                     jsr dos_closefile
  2331                          
  2332  946a a988                       lda #dos_errorcode_file_not_found
  2333  946c 4c1d93                     jmp dos_return_error
  2334                          
  2335                          dff_have_next_entry:
  2336                          
  2337                                  ;; Compare dos_dirent_longfilename with dos_requested_filename
  2338                                  ;;
  2339  946f 20ff96                     jsr dos_dirent_compare_name_to_requested
  2340                          
  2341                                  ;; no match? try next entry
  2342                                  ;;
  2343  9472 90ee                       bcc dff_try_next_entry
  2344                          
  2345                                  ;; we have a match, so return success
  2346                                  ;; (we don't close the file handle for the directory search, because the
  2347                                  ;; caller may want to find multiple matches)
  2348                                  ;;
  2349  9474 38                         sec
  2350  9475 60                         rts
  2351                          
  2352                          ;;         ========================
  2353                          
  2354                          dos_opendir:
  2355                          
  2356                                  ;; assure we are using the sdcard buffer (not the fdc buffer)
  2357  9476 a980                       lda #$80
  2358  9478 0c89d6                     tsb $d689
  2359                          
  2360                                  ;; Open the current directory as a file
  2361                                  ;;
  2362  947b 209d93                     jsr dos_get_free_descriptor
  2363  947e b003                       bcs +
  2364  9480 4c2093                     jmp dos_return_error_already_set
  2365                          +
  2366                                  ;; get offset in file descriptor table
  2367                                  ;;
  2368  9483 8a                         txa
  2369  9484 0a                         asl
  2370  9485 0a                         asl
  2371  9486 0a                         asl
  2372  9487 0a                         asl
  2373  9488 a8                         tay
  2374                          
  2375                                  ;; set disk id
  2376                                  ;;
  2377  9489 ad03bc                     lda dos_disk_current_disk
  2378  948c 99b9bc                     sta dos_file_descriptors+dos_filedescriptor_offset_diskid,y
  2379                          
  2380                                  ;; load cluster of dir into file descriptor
  2381                                  ;;
  2382  948f a200                       ldx #$00
  2383                          
  2384  9491 bd05bc             dff1:   lda dos_disk_cwd_cluster,x
  2385  9494 99bbbc                     sta dos_file_descriptors+dos_filedescriptor_offset_startcluster,y
  2386  9497 99bfbc                     sta dos_file_descriptors+dos_filedescriptor_offset_currentcluster,y
  2387  949a c8                         iny
  2388  949b e8                         inx
  2389  949c e004                       cpx #$04
  2390  949e d0f1                       bne dff1
  2391                          
  2392                                  ;; Mark file descriptor as being a directory
  2393                                  ;;
  2394  94a0 aefabc                     ldx dos_current_file_descriptor_offset
  2395  94a3 a980                       lda #dos_filemode_directoryaccess
  2396  94a5 9dbabc                     sta dos_file_descriptors + dos_filedescriptor_offset_mode,x
  2397                          
  2398  94a8 209397                     jsr dos_open_current_file
  2399  94ab b003                       bcs +
  2400  94ad 4c2093                     jmp dos_return_error_already_set
  2401  94b0 60                 +       rts
  2402                          
  2403                          ;;         ========================
  2404                          
  2405                          dos_readdir_storecurrententry
  2406                                  ;; store current cluster/sector/offset to rewind to later for rmfile
  2407  94b1 a000                       ldy #$00
  2408  94b3 aefabc                     ldx dos_current_file_descriptor_offset
  2409  94b6 bdbfbc             -       lda dos_file_descriptors + dos_filedescriptor_offset_currentcluster,x
  2410  94b9 9909bc                     sta dos_direntstart_cluster,y
  2411  94bc e8                         inx
  2412  94bd c8                         iny
  2413  94be c007                       cpy #$07
  2414  94c0 d0f4                       bne -
  2415  94c2 60                         rts
  2416                          
  2417                          dos_readdir_retreivelastentry
  2418                                  ;; retrieve current cluster/sector/offset to for rmfile
  2419  94c3 a000                       ldy #$00
  2420  94c5 aefabc                     ldx dos_current_file_descriptor_offset
  2421  94c8 b909bc             -       lda dos_direntstart_cluster,y
  2422  94cb 9dbfbc                     sta dos_file_descriptors + dos_filedescriptor_offset_currentcluster,x
  2423  94ce e8                         inx
  2424  94cf c8                         iny
  2425  94d0 c007                       cpy #$07
  2426  94d2 d0f4                       bne -
  2427  94d4 60                         rts
  2428                          
  2429                          dos_readdir:
  2430                          
  2431                                  ;; Get the current file entry, and advance pointer
  2432                                  ;; This requires parsing the current directory entry onwards, accumulating
  2433                                  ;; long filename parts as required.  We only support filenames to 64 chars,
  2434                                  ;; so long names longer than that will get ignored.
  2435                                  ;; LFN entries have an attribute byte of $0F (normally indicates volume label)
  2436                                  ;; LFN entries use 16-bit unicode values. For now we will just keep the lower
  2437                                  ;; byte of these
  2438                          
  2439                                  ;; clear long file name data from last call
  2440                                  ;;
  2441  94d5 a900                       lda #0
  2442  94d7 8d50bc                     sta dos_dirent_longfilename_length
  2443                          
  2444                                  ;; assess the EOF marker very early, to catch case where last read direntry
  2445                                  ;; was the last direntry of the cluster
  2446  94da aefabc                     ldx dos_current_file_descriptor_offset
  2447  94dd bdbabc                     lda dos_file_descriptors + dos_filedescriptor_offset_mode,x
  2448  94e0 c981                       cmp #dos_filemode_end_of_directory
  2449  94e2 d005                       bne drd_continue
  2450  94e4 a9ff                       lda #dos_errorcode_eof
  2451  94e6 4c1d93                     jmp dos_return_error
  2452                          
  2453                          drd_continue:
  2454  94e9 20e197                     jsr dos_file_read_current_sector
  2455                          
  2456                          !if DEBUG_HYPPO {
  2457                          ;; debug info, unsure what byte is being displayed...
  2458                          ;;
  2459                                  +Checkpoint "-"
  2460                          
  2461                                  ldy dos_current_file_descriptor_offset
  2462                                  clc
  2463                                  lda dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +0,y
  2464                          
  2465                                  tax                                ;; convert .X to char-representation for display
  2466                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2467                                  sty drdcp0+2
  2468                                  stx drdcp0+3
  2469                          
  2470                                  ldy dos_current_file_descriptor_offset
  2471                                  clc
  2472                                  lda dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +1,y
  2473                          
  2474                                  tax                                ;; convert .X to char-representation for display
  2475                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2476                                  sty drdcp0+0
  2477                                  stx drdcp0+1
  2478                          
  2479                                  jsr checkpoint
  2480                                  !8 0
  2481                                  !text "dos_readdir["
  2482                          drdcp0: !text "xxyy]"
  2483                                  !8 0
  2484                          
  2485                                  jsr dumpsectoraddress        ;; debug
  2486                                  jsr dumpfddata                ;; debug
  2487                          
  2488                          ;; end of debug
  2489                          }
  2490                          
  2491  94ec aefabc                     ldx dos_current_file_descriptor_offset
  2492  94ef bdbabc                     lda dos_file_descriptors + dos_filedescriptor_offset_mode,x
  2493  94f2 c980                       cmp #dos_filemode_directoryaccess
  2494  94f4 f00e                       beq drd_isdir
  2495  94f6 c981                       cmp #dos_filemode_end_of_directory
  2496  94f8 d005                       bne drd_notadir
  2497                          
  2498  94fa a9ff                       lda #dos_errorcode_eof
  2499  94fc 4c1d93                     jmp dos_return_error
  2500                          
  2501                          ;;         ========================
  2502                          
  2503                          drd_notadir:
  2504                                  ;; refuse to read files as directories
  2505                                  ;;
  2506  94ff a987                       lda #dos_errorcode_not_a_directory
  2507  9501 4c1d93                     jmp dos_return_error
  2508                          
  2509                          ;;         ========================
  2510                          
  2511                          drd_isdir:
  2512                                  ;; Clear dirent structure
  2513                                  ;; WARNING - Uses carnal knowledge to know that dirent structure is
  2514                                  ;; 64+1+11+4+4+1 = 85 contiguous bytes
  2515                                  ;;
  2516  9504 a256                       ldx #dos_dirent_structure_length-1
  2517  9506 a900                       lda #$00
  2518                          
  2519  9508 9d10bc             drce1:  sta dos_dirent_longfilename,x
  2520  950b ca                         dex
  2521  950c 10fa                       bpl drce1
  2522                          
  2523                                  ;; Read current sector
  2524                                  ;;
  2525  950e 20e197                     jsr dos_file_read_current_sector
  2526  9511 b003                       bcs +
  2527  9513 4c2093                     jmp dos_return_error_already_set
  2528  9516 2018a2             +       jsr sd_map_sectorbuffer
  2529                          
  2530                          drce_next_piece:
  2531                          
  2532                                  ;; Offset in sector correctly indicates where we need to read.
  2533                                  ;; Sectors are 512 bytes, so we can't just do a register index.
  2534                                  ;; Instead we will setup a 16-bit pointer.
  2535                                  ;;
  2536  9519 adfabc                     lda dos_current_file_descriptor_offset
  2537  951c 090b                       ora #dos_filedescriptor_offset_offsetinsector
  2538  951e aa                         tax
  2539  951f bdb9bc                     lda dos_file_descriptors,x
  2540  9522 8500                       sta <dos_scratch_vector
  2541  9524 bdbabc                     lda dos_file_descriptors+1,x
  2542  9527 18                         clc
  2543  9528 69de                       adc #$DE   ;; high byte of SD card sector buffer
  2544  952a 8501                       sta <(dos_scratch_vector+1)
  2545                          
  2546                                  ;; (dos_scratch_vector) now has the address of the directory entry
  2547                          
  2548                          !if DEBUG_HYPPO {
  2549                                  phx        ;; as the code below clobbers X
  2550                          
  2551                                  ;; print out filename and attrib
  2552                                  ;;
  2553                                  ldy #fs_fat32_dirent_offset_shortname
  2554                                  ldx #0
  2555                          eight31:
  2556                                  lda (<dos_scratch_vector),y
  2557                                  jsr makeprintable
  2558                                  sta eight3,x
  2559                                  iny
  2560                                  inx
  2561                                  cpx #11                ;; 11 chars in the filename (8+3)
  2562                                  bne eight31
  2563                                  ;;
  2564                                  ;; attrib
  2565                                  ;;
  2566                                  ldy #fs_fat32_dirent_offset_attributes        ;; = 0x0B
  2567                                  lda (<dos_scratch_vector),y
  2568                                  tax                                ;; convert .X to char-representation for display
  2569                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2570                                  sty eight3attrib+0
  2571                                  stx eight3attrib+1
  2572                                  ;;
  2573                                  ;; char1
  2574                                  ;;
  2575                                  ldy #$00
  2576                                  lda (<dos_scratch_vector),y
  2577                                  tax                                ;; convert .X to char-representation for display
  2578                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  2579                                  sty eight3char1+0
  2580                                  stx eight3char1+1
  2581                          
  2582                                  ;;
  2583                          
  2584                                  jsr checkpoint
  2585                                  !8 0
  2586                                  !text " (8.3)+(ATTRIB)+(NAME[0]) = "
  2587                          eight3: !text "FILENAMEEXT "
  2588                          eight3attrib:
  2589                                  !text "xx "
  2590                          eight3char1:
  2591                                  !text "xx"
  2592                                  !8 0
  2593                          
  2594                                  plx        ;; as the code above clobbers X
  2595                          }
  2596                          
  2597                          ;;         ========================
  2598                          
  2599                                  ;; first, check if the entry begins with $E5 marking a deleted file.
  2600                                  ;; Entry entries we just ignore, as they are totally valid.
  2601                          
  2602  952c a000                       ldy #fs_fat32_dirent_offset_shortname        ;; Y=0 (first char of entry)
  2603  952e b100                       lda (<dos_scratch_vector),y
  2604  9530 c9e5                       cmp #$e5
  2605  9532 d003                       bne +
  2606  9534 4cef96                     jmp drd_deleted_or_invalid_entry
  2607                          +
  2608  9537 c900                       cmp #$00  ;; NOTE: In Windows, I've seen #$00 markers equating to the end of direntries (i.e., stop iterating over direntries at this point)
  2609  9539 d003                       bne +
  2610                                  ;; Empty entry, so skip over it
  2611  953b 4cef96                     jmp drd_deleted_or_invalid_entry
  2612                          +
  2613                                  ;; now check the attrib
  2614                          
  2615  953e a00b                       ldy #fs_fat32_dirent_offset_attributes        ;; = 0x0B
  2616  9540 b100                       lda (<dos_scratch_vector),y
  2617                          
  2618                                  ;; check the kind of data we are looking at:
  2619                                  ;; bit 5 = 1         -> is a Archive
  2620                                  ;; bit 4 = 1         -> is a Directory
  2621                                  ;; bit 3 = 1         -> is a Volume ID
  2622                                  ;; bit 2 = 1         -> is a System
  2623                                  ;; bit 1 = 1         -> is a Hidden
  2624                                  ;; bit 0 = 1         -> is a Readonly
  2625                          
  2626  9542 a8                         tay        ;; for safe keeping
  2627                          
  2628                                  ;; if bits xx3210 = xx1111 -> is a long filename
  2629                                  ;; we process these differently to the standard (shortname) entries
  2630                                  ;;
  2631  9543 290f                       and #$0f
  2632  9545 c90f                       cmp #$0f                ;; %00001111 LFN entry special attribute value (xxxx1111)
  2633  9547 d003                       bne drce_cont0
  2634  9549 4c7b95                     jmp drce_longname        ;; MATCH -> must be LFN
  2635                          
  2636                          drce_cont0:
  2637  954c 98                         tya        ;; from safe keeping
  2638                          
  2639                                  ;; if bit-3 = 1 -> Vol ID
  2640                                  ;; we process the Vol ID different (for now)
  2641                                  ;;
  2642  954d 2908                       and #$08
  2643  954f c908                       cmp #$08                ;; %00001000 Vol-ID
  2644  9551 d003                       bne drce_cont2
  2645  9553 4c1896                     jmp drce_cont_next_part	; Ignore it
  2646                          
  2647                          drce_cont2:
  2648  9556 98                         tya        ;; from safe keeping
  2649                          
  2650                                  ;; check for bits 2 or 1 asserted
  2651                                  ;; we should ignore these hidden/system files (for now)
  2652                                  ;;
  2653  9557 2906                       and #$06                ;; %00000110
  2654  9559 f00f                       beq drce_cont3        ;; branch if equal to zero (ie not Hidden OR System)
  2655                          
  2656                                  ;; macOS creates the `.` and `..` entries as hidden. Special case `..`
  2657                                  ;; so that it appears in listings. Some uses, like the Freezer, need it
  2658                                  ;; visible to know how to navigate to the parent directory.
  2659  955b a20b                       ldx #11  ; length of dotdotshortname string
  2660  955d a000                       ldy #fs_fat32_dirent_offset_shortname        ;; Y=0 (first char of entry)
  2661  955f b100               -       lda (<dos_scratch_vector),y
  2662  9561 d97095                     cmp dotdotshortname,y
  2663  9564 d007                       bne drce_ignore
  2664  9566 c8                         iny
  2665  9567 ca                         dex
  2666  9568 d0f5                       bne -
  2667                          
  2668                          drce_cont3:
  2669                                  ;; was not hidden/system, or Vol-ID, or LFN, or was special case "..",
  2670                                  ;; so we process this entry regardless of if read-only (bit0) or not
  2671  956a 4c2396                     jmp drce_normalrecord
  2672                          
  2673                          drce_ignore:
  2674                                  ;; Ignore hidden/system files for now
  2675                                  ;; XXX We should have a flag to enable/disable this behaviour
  2676  956d 4c1896                     jmp drce_cont_next_part
  2677                          
  2678                          dotdotshortname:
  2679  9570 2e2e202020202020...        !text "..         "
  2680                          
  2681                          ;;         ========================
  2682                          
  2683                          drce_longname:
  2684                          
  2685                          disable_lfn_byte:
  2686  957b 4c1896                     jmp drce_cont_next_part
  2687                          
  2688                                  ;; make sure long entry type is "filename" (=$00)
  2689                                  ;;
  2690  957e a00c                       ldy #fs_fat32_dirent_offset_lfn_type
  2691  9580 b100                       lda (<dos_scratch_vector),y
  2692  9582 f003                       beq +
  2693  9584 4c2396                     jmp drce_normalrecord
  2694                          +
  2695                                  ;; verify checksum of long name
  2696                                  ;; XXX - Actually, we need to keep the checksum, and then compare it with the
  2697                                  ;; checksum we compute on the short name to check if this is the right long
  2698                                  ;; name.  We are just going to ignore this for now, and assume (and hope) that
  2699                                  ;; the LFN structure is always healthy.  I am sure this will come back to bite
  2700                                  ;; us at some point, and it can be fixed at that point in time.
  2701                          
  2702                                  ;; It's a long filename piece
  2703                                  ;; byte 0 gives the position in the LFN of this piece.
  2704                                  ;; Each piece has 13 16-bit unicode values.
  2705                                  ;; For now, we will only use the lower byte.  later we should gather the
  2706                                  ;; long filenames as UTF-16, and then convert them to UTF-8.
  2707                          
  2708  9587 a000                       ldy #fs_fat32_dirent_offset_lfn_part_number
  2709                          
  2710                                  ;; assess if this is the first part in the list
  2711  9589 b100                       lda (<dos_scratch_vector),y
  2712  958b 48                         pha
  2713  958c 2940                       and #$40  ;; bit4=1 means it's the first part in the list
  2714  958e 8dfbbc                     sta dos_first_vfat_chunk_in_list_flag
  2715                          
  2716                                  ;; assess which part number it is
  2717  9591 68                         pla
  2718  9592 293f                       and #$3f ;; mask out end of LFN indicator
  2719  9594 3a                         dec ;; subtract one, since pieces are numbered from 1 upwards
  2720                          
  2721                                  ;; each piece has 13 chars, and we only allow 64 characters total, so any
  2722                                  ;; piece number >4 can be ignored
  2723                                  ;;
  2724  9595 c905                       cmp #5
  2725  9597 b072                       bcs drce_ignore_lfn_piece
  2726  9599 aa                         tax
  2727  959a bdfa96                     lda lfn_piece_offsets,x
  2728  959d aa                         tax
  2729                          
  2730                                  +Checkpoint "found LFN piece <start>"
  2731                          
  2732                                  ;; Copy first part of LFN
  2733                                  ;;
  2734  959e a001                       ldy #fs_fat32_dirent_offset_lfn_part1_start
  2735  95a0 a305                       ldz #fs_fat32_dirent_offset_lfn_part1_chars
  2736  95a2 b100               drce2:  lda (<dos_scratch_vector),y
  2737  95a4 f058                       beq drce_eot_in_filename
  2738  95a6 2041a1                     jsr toupper
  2739  95a9 9d10bc                     sta dos_dirent_longfilename,x
  2740  95ac adfbbc                     lda dos_first_vfat_chunk_in_list_flag
  2741  95af f003                       beq +
  2742  95b1 8e50bc                     stx dos_dirent_longfilename_length
  2743                          +
  2744  95b4 e8                         inx
  2745                                  ;; protect against over-long LFNs
  2746  95b5 e040                       cpx #$40
  2747  95b7 f045                       beq drce_eot_in_filename
  2748  95b9 c8                         iny
  2749  95ba c8                         iny
  2750  95bb 3b                         dez
  2751  95bc d0e4                       bne drce2
  2752                          
  2753                                  ;; Copy second part of LFN
  2754                                  ;;
  2755  95be a00e                       ldy #fs_fat32_dirent_offset_lfn_part2_start
  2756  95c0 a306                       ldz #fs_fat32_dirent_offset_lfn_part2_chars
  2757  95c2 b100               drce3:  lda (<dos_scratch_vector),y
  2758  95c4 f038                       beq drce_eot_in_filename
  2759  95c6 2041a1                     jsr toupper
  2760  95c9 9d10bc                     sta dos_dirent_longfilename,x
  2761  95cc adfbbc                     lda dos_first_vfat_chunk_in_list_flag
  2762  95cf f003                       beq +
  2763  95d1 8e50bc                     stx dos_dirent_longfilename_length
  2764                          +
  2765  95d4 e8                         inx
  2766                                  ;; protect against over-long LFNs
  2767  95d5 e040                       cpx #$40
  2768  95d7 f025                       beq drce_eot_in_filename
  2769  95d9 c8                         iny
  2770  95da c8                         iny
  2771  95db 3b                         dez
  2772  95dc d0e4                       bne drce3
  2773                          
  2774                                  ;; Copy third part of LFN
  2775                                  ;;
  2776  95de a01c                       ldy #fs_fat32_dirent_offset_lfn_part3_start
  2777  95e0 a302                       ldz #fs_fat32_dirent_offset_lfn_part3_chars
  2778  95e2 b100               drce4:  lda (<dos_scratch_vector),y
  2779  95e4 f018                       beq drce_eot_in_filename
  2780  95e6 2041a1                     jsr toupper
  2781  95e9 9d10bc                     sta dos_dirent_longfilename,x
  2782  95ec adfbbc                     lda dos_first_vfat_chunk_in_list_flag
  2783  95ef f003                       beq +
  2784  95f1 8e50bc                     stx dos_dirent_longfilename_length
  2785                          +
  2786  95f4 e8                         inx
  2787                                  ;; protect against over-long LFNs
  2788  95f5 e040                       cpx #$40
  2789  95f7 f005                       beq drce_eot_in_filename
  2790  95f9 c8                         iny
  2791  95fa c8                         iny
  2792  95fb 3b                         dez
  2793  95fc d0e4                       bne drce4
  2794                          
  2795                          drce_eot_in_filename:
  2796                          
  2797                                  +Checkpoint "BGOK drce_eot_in_filename"
  2798                          
  2799                                  ;; got all characters from this LFN piece
  2800                                  ;;
  2801  95fe adfbbc                     lda dos_first_vfat_chunk_in_list_flag
  2802  9601 f008                       beq +
  2803  9603 ec50bc                     cpx dos_dirent_longfilename_length      ;; GI_NOTE: I'm suspicious of this part
  2804  9606 9003                       bcc drce_piece_didnt_grow_name_length   ;; We branch if x < dos_dirent_longfilename_length
  2805  9608 8e50bc                     stx dos_dirent_longfilename_length      ;; in my case x=19, dos_dirent_longerfilename=18. So why store this?
  2806                                  ;; cpx #$3f
  2807                                  ;; bcs drce_eot_in_filename2               ;; We branch if x >= #$3f (63). Should this be #$40?
  2808                          +
  2809                                  ;; null terminate if there is space, for convenience
  2810                                  ;; GI. Let's skip null terminator, as it is in the wrong place, and we wipe out dos_dirent_longfilename with zeroes each time anyway
  2811                                  ;; lda #$00
  2812                                  ;; sta dos_dirent_longfilename,x
  2813                                  ;; stx dos_dirent_longfilename_length
  2814                          
  2815                          drce_eot_in_filename2:
  2816                          
  2817                          drce_piece_didnt_grow_name_length:
  2818                          
  2819                          drce_ignore_lfn_piece:
  2820                          
  2821                                  +Checkpoint "BGOK drce_ignore_lfn_piece"
  2822                          
  2823                                  ;; We have finished processing this piece of long name.
  2824                                  ;; bump directory entry, read next sector if required, and re-enter loop
  2825                                  ;; above to keep accumulating
  2826                          
  2827                          drce_cont_next:
  2828                          
  2829                                  +Checkpoint "BGOK drce_cont_next"
  2830                          
  2831  960b 201d97                     jsr dos_readdir_advance_to_next_entry
  2832  960e 9003                       bcc drce_no_more_pieces
  2833                          
  2834  9610 4c1995                     jmp drce_next_piece
  2835                          
  2836                          drd_end_of_directory:
  2837                                  ;; If we have pieces, then emit the final filename,
  2838                                  ;; else return EOF on the directory by falling through to the following
  2839                                  ;; Can we ever be in such a position?  Let's assume for the time being that
  2840                                  ;; we can't.  If we start losing the last name in a directory list, then we
  2841                                  ;; can worry about fixing it then.
  2842                          
  2843                                  ;; FALL THROUGH to drce_no_more_pieces
  2844                          
  2845                          ;;         ========================
  2846                          
  2847                          drce_no_more_pieces:
  2848                                  +Checkpoint "FOUND END_OF_DIRECTORY"
  2849                          
  2850  9613 a9ff                       lda #dos_errorcode_eof
  2851  9615 4c1d93                     jmp dos_return_error
  2852                          
  2853                          ;;         ========================
  2854                          
  2855                          
  2856                          drce_cont_next_part:
  2857                          
  2858  9618 201d97                     jsr dos_readdir_advance_to_next_entry
  2859  961b 9003                       bcc +
  2860  961d 4cd594                     jmp dos_readdir
  2861  9620 4c2093             +       jmp dos_return_error_already_set
  2862                          
  2863                          ;;         ========================
  2864                          
  2865                          drce_normalrecord:
  2866                                  ;; PGS: We have found a short name.
  2867                          
  2868                                  ;; start of short filename. store entry for use by fstat and rmfile
  2869  9623 20b194                     jsr dos_readdir_storecurrententry
  2870                          
  2871                                  +Checkpoint "processing SHORT-name"
  2872                          
  2873                                  ;; store short name
  2874                                  ;;
  2875  9626 a000                       ldy #fs_fat32_dirent_offset_shortname
  2876                          
  2877                          ;; this test has already been done
  2878                          ;;
  2879                          ;;         ; Ignore empty and deleted entries (first byte $00 or $E5 respectively)
  2880                          ;;         ;
  2881                          ;;         lda (<dos_scratch_vector),y
  2882                          ;;         beq drd_end_of_directory
  2883                          ;;         cmp #$e5
  2884                          ;;         beq drd_deleted_or_invalid_entry
  2885                          
  2886  9628 a200                       ldx #$00
  2887  962a b100               drce5:  lda (<dos_scratch_vector),y
  2888  962c 9d51bc                     sta dos_dirent_shortfilename,x
  2889  962f e8                         inx
  2890  9630 c8                         iny
  2891  9631 e00b                       cpx #11
  2892  9633 d0f5                       bne drce5
  2893                          
  2894                                  ;; If we have no long name, copy it also to long name, inserting "." between
  2895                                  ;; name and extension as required.
  2896                                  ;;
  2897  9635 ad50bc                     lda dos_dirent_longfilename_length
  2898  9638 d05b                       bne drce_already_have_long_name
  2899                          
  2900                                  ;; copy name part
  2901                                  ;;
  2902  963a a000                       ldy #fs_fat32_dirent_offset_shortname
  2903  963c a200                       ldx #$00
  2904  963e b100               drce7:  lda (<dos_scratch_vector),y
  2905  9640 9d10bc                     sta dos_dirent_longfilename,x
  2906  9643 8e50bc                     stx dos_dirent_longfilename_length
  2907  9646 e8                         inx
  2908  9647 c8                         iny
  2909  9648 c920                       cmp #$20            ;; space indicates end of short name before extension
  2910  964a f005                       beq drce_insert_dot
  2911  964c e008                       cpx #8
  2912  964e d0ee                       bne drce7
  2913  9650 e8                         inx
  2914                          
  2915                          drce_insert_dot:
  2916  9651 ca                         dex
  2917  9652 a92e                       lda #'.'
  2918  9654 9d10bc                     sta dos_dirent_longfilename,x
  2919  9657 8e50bc                     stx dos_dirent_longfilename_length
  2920  965a e8                         inx
  2921                          
  2922                                  ;; copy extension part
  2923                                  ;;
  2924  965b a008                       ldy #fs_fat32_dirent_offset_shortname+8
  2925  965d a300                       ldz #0
  2926  965f b100               drce6:  lda (<dos_scratch_vector),y
  2927  9661 9d10bc                     sta dos_dirent_longfilename,x
  2928  9664 8e50bc                     stx dos_dirent_longfilename_length
  2929  9667 e8                         inx
  2930  9668 c8                         iny
  2931  9669 1b                         inz
  2932  966a c203                       cpz #3  ;; short name extensions are <=3 chars
  2933  966c f008                       beq drce_copied_extension
  2934                          
  2935                                  ;; also terminate extensions early if they are <3 chars
  2936                                  ;;
  2937  966e c920                       cmp #$20
  2938  9670 f004                       beq drce_copied_extension
  2939  9672 e00c                       cpx #8+1+3
  2940  9674 d0e9                       bne drce6
  2941                          
  2942                          drce_copied_extension:
  2943                          
  2944                                  ;; Trim spaces from the end of the filename
  2945  9676 e000                       cpx #0
  2946  9678 f013                       beq @filename0bytes
  2947  967a a920                       lda #$20
  2948  967c dd0fbc                     cmp dos_dirent_longfilename-1,x
  2949  967f d004                       bne @nomorespaces
  2950  9681 ca                         dex
  2951  9682 4c7696                     jmp drce_copied_extension
  2952                          
  2953                          @nomorespaces:
  2954                          
  2955                                  ;; And trim trailing . from file name in case extension
  2956                                  ;; was all spaces. But don't trim it if the filename starts
  2957                                  ;; with ., so that we don't mess up . and .. directories
  2958  9685 bd0fbc                     lda dos_dirent_longfilename-1,x
  2959                                  ;; Is last char a . ?
  2960  9688 c92e                       cmp #$2e
  2961  968a d001                       bne @notrailingdot
  2962                          
  2963                          @hastrailingdot:
  2964                          
  2965                                  ;; Cut . from end of filename
  2966  968c ca                         dex
  2967                          
  2968                          @notrailingdot:
  2969                          
  2970                          @filename0bytes:
  2971                          
  2972                                  ;; null terminate short name for convenience in our debugging
  2973                                  ;;
  2974  968d a900                       lda #$00
  2975  968f 9d10bc                     sta dos_dirent_longfilename,x
  2976                          
  2977                                  ;; record length of short name
  2978  9692 8e50bc                     stx dos_dirent_longfilename_length
  2979                          
  2980                                  ;; fall through
  2981                          
  2982                          drce_already_have_long_name:
  2983                          
  2984                                  ;; now copy attribute field and other useful data
  2985                          
  2986                                  ;; starting cluster
  2987                                  ;;
  2988  9695 a01a                       ldy #fs_fat32_dirent_offset_clusters_low
  2989  9697 b100                       lda (<dos_scratch_vector),y
  2990  9699 8d5ebc                     sta dos_dirent_cluster
  2991  969c c8                         iny
  2992  969d b100                       lda (<dos_scratch_vector),y
  2993  969f 8d5fbc                     sta dos_dirent_cluster+1
  2994                          
  2995  96a2 a014                       ldy #fs_fat32_dirent_offset_clusters_high
  2996  96a4 b100                       lda (<dos_scratch_vector),y
  2997  96a6 8d60bc                     sta dos_dirent_cluster+2
  2998  96a9 c8                         iny
  2999  96aa b100                       lda (<dos_scratch_vector),y
  3000  96ac 8d61bc                     sta dos_dirent_cluster+3
  3001                          
  3002                          
  3003                                  ;; file length in bytes
  3004                                  ;;
  3005  96af a01c                       ldy #fs_fat32_dirent_offset_file_length
  3006  96b1 a200                       ldx #0
  3007                          drce_fl:
  3008  96b3 b100                       lda (<dos_scratch_vector),y
  3009  96b5 9d62bc                     sta dos_dirent_length,x
  3010  96b8 c8                         iny
  3011  96b9 e8                         inx
  3012  96ba e004                       cpx #4
  3013  96bc d0f5                       bne drce_fl
  3014                          
  3015                                  ;; attributes
  3016                                  ;;
  3017  96be a00b                       ldy #fs_fat32_dirent_offset_attributes
  3018  96c0 b100                       lda (<dos_scratch_vector),y
  3019  96c2 8d66bc                     sta dos_dirent_type_and_attribs
  3020                          
  3021                                  +Checkpoint "drce_fl populated fields"
  3022                          
  3023  96c5 201d97                     jsr dos_readdir_advance_to_next_entry
  3024  96c8 b010                       bcs drce_not_eof
  3025                          
  3026                          drce_is_eof:
  3027                          
  3028                                  +Checkpoint "DEBUG drce_is_eof <!>"
  3029                          
  3030                                  ;; We need to pass the error through here to indicate EOF in directory,
  3031                                  ;; but in a way that can be defered to the next call to dos_readdir, because
  3032                                  ;; we have a valid entry right now.  We do this with a special file mode which
  3033                                  ;; is EOF of directory (dos_filemode_end_of_directory)
  3034                                  ;;
  3035  96ca aefabc                     ldx dos_current_file_descriptor_offset
  3036  96cd a981                       lda #dos_filemode_end_of_directory
  3037  96cf 9dbabc                     sta dos_file_descriptors + dos_filedescriptor_offset_mode ,x
  3038                          
  3039  96d2 aefabc                     ldx dos_current_file_descriptor_offset
  3040  96d5 bdbabc                     lda dos_file_descriptors + dos_filedescriptor_offset_mode,x
  3041                          
  3042  96d8 38                         sec
  3043  96d9 60                         rts
  3044                          
  3045                          drce_not_eof:
  3046                          
  3047                                  +Checkpoint "drce_not_eof CHECK<1/3>"
  3048                          
  3049                                  ;; Ignore zero-length filenames (corresponding to empty directory entries)
  3050                                  ;;
  3051  96da ad50bc                     lda dos_dirent_longfilename_length
  3052  96dd c900                       cmp #0
  3053  96df f009                       beq l_dos_readdir
  3054                          
  3055                                  +Checkpoint "drce_not_eof CHECK<2/3>"
  3056                          
  3057  96e1 ad51bc                     lda dos_dirent_shortfilename
  3058  96e4 f004                       beq l_dos_readdir
  3059  96e6 c920                       cmp #$20
  3060  96e8 d003                       bne +
  3061                          l_dos_readdir:
  3062  96ea 4cd594                     jmp dos_readdir
  3063                          +
  3064                                  +Checkpoint "drce_not_eof CHECK<3/3>"
  3065                          
  3066                          !if DEBUG_HYPPO {
  3067                                  ldx dos_dirent_longfilename_length
  3068                                  jsr lfndebug
  3069                          }
  3070                          
  3071  96ed 38                         sec
  3072  96ee 60                         rts
  3073                          
  3074                          ;;         ========================
  3075                          
  3076                          !if DEBUG_HYPPO {
  3077                          lfndebug:
  3078                                  ;; requires .X to be set
  3079                                  ;;
  3080                                                                  ;; convert .X to char-representation for display
  3081                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  3082                                  sty fnmsg1-5
  3083                                  stx fnmsg1-4
  3084                          
  3085                                  ;; Show what we have in the filename so far
  3086                                  ;;
  3087                                  phx        ;; safekeep
  3088                          
  3089                                  ldx #29
  3090                          drce23: lda dos_dirent_longfilename,x
  3091                                  jsr makeprintable
  3092                                  sta fnmsg1,x
  3093                                  dex
  3094                                  bpl drce23
  3095                          
  3096                                  plx        ;; unsafekeep
  3097                          
  3098                                  jsr checkpoint
  3099                                  !8 0
  3100                                  !text "LFN(xx): " ;; the "xx" can be replaced with the name_length
  3101                          fnmsg1: !text ".............................." ;; BG: why only 30 chars?
  3102                                  !8 0
  3103                          
  3104                                  rts
  3105                          }
  3106                          
  3107                          ;;         ========================
  3108                          
  3109                          drd_deleted_or_invalid_entry:
  3110                          
  3111                          !if DEBUG_HYPPO {
  3112                                  tax
  3113                                                                  ;; convert .X to char-representation for display
  3114                                  jsr checkpoint_bytetohex        ;; returns: .X and .Y (Y is MSB, X is LSB, print YX)
  3115                                  sty ddie+0
  3116                                  stx ddie+1
  3117                          
  3118                                  jsr checkpoint
  3119                                  !8 0
  3120                          ddie:   !text "xx drd_deleted_or_invalid_entry"
  3121                                  !8 0
  3122                          }
  3123                          
  3124  96ef 201d97                     jsr dos_readdir_advance_to_next_entry
  3125  96f2 9003                       bcc +
  3126  96f4 4cd594                     jmp dos_readdir
  3127                          +
  3128  96f7 4c2093                     jmp dos_return_error_already_set
  3129                          
  3130                          ;;         ========================
  3131                          
  3132                          lfn_piece_offsets:
  3133  96fa 000d1a2734                 !8 13*0,13*1,13*2,13*3,13*4
  3134                          
  3135                          ;;         ========================
  3136                          
  3137                          dos_dirent_compare_name_to_requested:
  3138                          
  3139                                  ;; print debug message showing what we are comparing
  3140                          
  3141                                  ;; print filename for debug
  3142                          
  3143                                  ;; Do the cheap check of comparing the lengths first
  3144                                  ;;
  3145  96ff ad50bc                     lda dos_dirent_longfilename_length
  3146  9702 cd67bc                     cmp dos_requested_filename_len
  3147  9705 d014                       bne dff3
  3148                          
  3149                                  ;; lengths match, so compare bytes
  3150                                  ;; XXX - Needs to support * and ?
  3151                                  ;; see http:;;6502.org/source/strings/patmatch.htm for a routine to take
  3152                                  ;; inspiration from.
  3153                                  ;;
  3154  9707 ae50bc                     ldx dos_dirent_longfilename_length
  3155  970a ca                         dex
  3156  970b bd68bc             dff4:   lda dos_requested_filename,x
  3157  970e 2041a1                     jsr toupper
  3158  9711 dd10bc                     cmp dos_dirent_longfilename,x
  3159  9714 d005                       bne dff3
  3160  9716 ca                         dex
  3161  9717 10f2                       bpl dff4
  3162                          
  3163                                  ;; File names match, so return success
  3164                          
  3165                                  +Checkpoint "Found the file..."
  3166                          
  3167  9719 38                         sec
  3168  971a 60                         rts
  3169                          
  3170                          dff3:
  3171                                  ;; file names don't match, so return failure
  3172  971b 18                         clc
  3173  971c 60                         rts
  3174                          
  3175                          ;;         ========================
  3176                          
  3177                          dos_readdir_advance_to_next_entry:
  3178                          
  3179  971d acfabc                     ldy dos_current_file_descriptor_offset
  3180                          
  3181  9720 18                         clc
  3182  9721 b9c4bc                     lda dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +0,y
  3183  9724 6920                       adc #$20 ;; length of FAT32/VFAT directory entry
  3184  9726 99c4bc                     sta dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +0,y
  3185  9729 d00b                       bne dratne_done
  3186                          
  3187                                  ;; Increment upper byte
  3188                                  ;;
  3189  972b b9c5bc                     lda dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +1,y
  3190  972e 1a                         inc
  3191  972f c901                       cmp #$01
  3192  9731 d005                       bne drce_end_of_sector
  3193  9733 99c5bc                     sta dos_file_descriptors + dos_filedescriptor_offset_offsetinsector +1,y
  3194                          
  3195                          dratne_done:
  3196  9736 38                         sec
  3197  9737 60                         rts
  3198                          
  3199                          ;;         ========================
  3200                          
  3201                          drce_end_of_sector:
  3202                          
  3203                                  ;; Reset pointer back to start of sector
  3204                                  ;;
  3205  9738 a900                       lda #$00
  3206  973a 99c5bc                     sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+1,y
  3207                          
  3208  973d 200898                     jsr dos_file_advance_to_next_sector
  3209                                  ; since we've changed sectors, read in new sector data
  3210  9740 9003                       bcc @skipreadsector
  3211  9742 20e197                     jsr dos_file_read_current_sector
  3212                          @skipreadsector:
  3213  9745 60                         rts
  3214                          
  3215                          ;;         ========================
  3216                          
  3217                          dos_set_current_file_from_dirent:
  3218                          
  3219                                  ;; copy start cluster from dirent to start and current cluster
  3220                                  ;;
  3221  9746 209d93                     jsr dos_get_free_descriptor
  3222  9749 20ba97                     jsr dos_get_file_descriptor_offset
  3223  974c b003                       bcs +
  3224  974e 4c2093                     jmp dos_return_error_already_set
  3225                          +
  3226                                  ;; set disk id
  3227                                  ;;
  3228  9751 ad03bc                     lda dos_disk_current_disk
  3229  9754 9db9bc                     sta dos_file_descriptors+dos_filedescriptor_offset_diskid,x
  3230                          
  3231                                  ;; set current cluster to start cluster
  3232                                  ;;
  3233  9757 a000                       ldy #0
  3234                          dscffd1:
  3235  9759 b95ebc                     lda dos_dirent_cluster,y
  3236  975c 9dbbbc                     sta dos_file_descriptors+dos_filedescriptor_offset_startcluster,x
  3237  975f 9dbfbc                     sta dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
  3238  9762 e8                         inx
  3239  9763 c8                         iny
  3240  9764 c004                       cpy #4
  3241  9766 d0f1                       bne dscffd1
  3242                          
  3243  9768 20ba97                     jsr dos_get_file_descriptor_offset
  3244  976b b003                       bcs +
  3245  976d 4c2093                     jmp dos_return_error_already_set
  3246                          +
  3247                          
  3248                                  ;; set disk id
  3249                                  ;;
  3250  9770 ad03bc                     lda dos_disk_current_disk
  3251  9773 9db9bc                     sta dos_file_descriptors+dos_filedescriptor_offset_diskid,x
  3252                          
  3253                                  ;; set mode
  3254                                  ;;
  3255  9776 a900                       lda #dos_filemode_readonly
  3256  9778 9dbabc                     sta dos_file_descriptors+dos_filedescriptor_offset_mode,x
  3257                          
  3258                                  ;; set sector in cluster (set to 0)
  3259                                  ;;
  3260  977b a900                       lda #$00
  3261  977d 9dc3bc                     sta dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,x
  3262                          
  3263                                  ;; set offset in sector (set to 0)
  3264                                  ;;
  3265  9780 9dc4bc                     sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+0,x
  3266  9783 9dc5bc                     sta dos_file_descriptors+dos_filedescriptor_offset_offsetinsector+1,x
  3267                          
  3268                                  ;; Get length of file, so that we can
  3269                                  ;; limit load to reported length of file, instead assuming cluster
  3270                                  ;; chain is correct length, and file ends on a cluster boundary
  3271  9786 a203                       ldx #$03
  3272  9788 bd62bc             -       lda dos_dirent_length,x
  3273  978b 9dacbc                     sta dos_bytes_remaining,x
  3274  978e ca                         dex
  3275  978f 10f7                       bpl -
  3276                          
  3277  9791 38                         sec
  3278  9792 60                         rts
  3279                          
  3280                          ;;         ========================
  3281                          
  3282                          dos_open_current_file:
  3283                          
  3284                                  ;; copy start cluster to current cluster, and zero position in file
  3285                                  ;;
  3286  9793 20ba97                     jsr dos_get_file_descriptor_offset
  3287  9796 b003                       bcs +
  3288  9798 4c2093                     jmp dos_return_error_already_set
  3289                          +
  3290                                  ;; Copy start cluster to current cluster
  3291                                  ;;
  3292  979b a003                       ldy #3
  3293  979d bdbbbc             docf1:  lda dos_file_descriptors + dos_filedescriptor_offset_startcluster   ,x
  3294  97a0 9dbfbc                     sta dos_file_descriptors + dos_filedescriptor_offset_currentcluster ,x
  3295  97a3 e8                         inx
  3296  97a4 88                         dey
  3297  97a5 10f6                       bpl docf1
  3298                          
  3299  97a7 20ba97                     jsr dos_get_file_descriptor_offset
  3300  97aa a900                       lda #$00
  3301                          
  3302                                  ;; sectorincluster, offsetinsector, fileoffset are contiguous, which allows
  3303                                  ;; us to clear these more efficiently.
  3304                                  ;;
  3305  97ac a006                       ldy #6
  3306  97ae 9dc3bc             docf2:  sta dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,x
  3307  97b1 e8                         inx
  3308  97b2 88                         dey
  3309  97b3 d0f9                       bne docf2
  3310                          
  3311  97b5 20ba97                     jsr dos_get_file_descriptor_offset
  3312                          
  3313  97b8 38                         sec
  3314  97b9 60                         rts
  3315                          
  3316                          ;;         ========================
  3317                          
  3318                                  ;; Load A & X with the offset of the current file descriptor, relative to
  3319                                  ;; dos_file_descriptors.
  3320                          
  3321                          dos_get_file_descriptor_offset:
  3322                          
  3323  97ba adf9bc                     lda dos_current_file_descriptor
  3324  97bd c904                       cmp #4
  3325  97bf b007                       bcs dos_bad_file_descriptor
  3326  97c1 0a                         asl
  3327  97c2 0a                         asl
  3328  97c3 0a                         asl
  3329  97c4 0a                         asl
  3330  97c5 aa                         tax
  3331  97c6 38                         sec
  3332  97c7 60                         rts
  3333                          
  3334                          ;;         ========================
  3335                          
  3336                          dos_bad_file_descriptor:
  3337                          
  3338  97c8 a989                       lda #dos_errorcode_invalid_file_descriptor
  3339  97ca 4c1d93                     jmp dos_return_error
  3340                          
  3341                          ;;         ========================
  3342                          
  3343                          dos_set_current_cluster_from_file:
  3344                          
  3345                                  ;; copy cluster number in file to current cluster
  3346                                  ;;
  3347  97cd 20ba97                     jsr dos_get_file_descriptor_offset
  3348  97d0 9029                       bcc l2_dos_return_error_already_set
  3349                          
  3350  97d2 a000                       ldy #$00
  3351  97d4 bdbfbc             dfrcs1: lda dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
  3352  97d7 99b4bc                     sta dos_current_cluster,y
  3353  97da e8                         inx
  3354  97db c8                         iny
  3355  97dc c004                       cpy #$04
  3356  97de d0f4                       bne dfrcs1
  3357  97e0 60                         rts
  3358                          
  3359                          ;;         ========================
  3360                          
  3361                          dos_file_read_current_sector:
  3362                          
  3363  97e1 20ed97                     jsr dos_file_update_sector_offset
  3364  97e4 4c2da2                     jmp sd_readsector
  3365                          
  3366                          ;;         ========================
  3367                          
  3368                          dos_file_write_current_sector:
  3369                          
  3370  97e7 20ed97                     jsr dos_file_update_sector_offset
  3371  97ea 4c3ea2                     jmp sd_writesector
  3372                          
  3373                          ;;         ========================
  3374                          
  3375                          dos_file_update_sector_offset:
  3376                          
  3377  97ed 20ba97                    jsr dos_get_file_descriptor_offset
  3378  97f0 20cd97                     jsr dos_set_current_cluster_from_file
  3379  97f3 205d93                     jsr dos_cluster_to_sector
  3380                          
  3381                                  ;; Add sector within cluster
  3382                                  ;;
  3383  97f6 20ba97                     jsr dos_get_file_descriptor_offset
  3384  97f9 b003                       bcs gotFDOffset
  3385                          l2_dos_return_error_already_set:
  3386  97fb 4c2093                     jmp dos_return_error_already_set
  3387                          gotFDOffset:
  3388                          
  3389                                  ;; Set A to the offset of the sectorincluster field of the current
  3390                                  ;; file descriptor
  3391                                  ;;
  3392  97fe 090a                       ora #dos_filedescriptor_offset_sectorincluster
  3393                          
  3394                                  ;; Now put that offset in y, so that we can load the sector number in the
  3395                                  ;; current cluster for the current file descriptor
  3396                                  ;;
  3397  9800 a8                         tay
  3398  9801 b9b9bc                     lda dos_file_descriptors,y
  3399                          
  3400                                  ;; add sector number in cluster to current sector number (which is the
  3401                                  ;; start of the cluster)
  3402                                  ;;
  3403  9804 200d9e                     jsr sdsector_add_uint8
  3404                          
  3405  9807 60                         rts
  3406                          
  3407                          ;;         ========================
  3408                          
  3409                          dos_file_advance_to_next_sector:
  3410                          
  3411                                  ;; Increment file position offset by 2 pages
  3412                                  ;;
  3413  9808 aefabc                     ldx dos_current_file_descriptor_offset
  3414                          
  3415  980b bdc6bc                     lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0 ,x
  3416  980e 18                         clc
  3417  980f 6902                       adc #$02
  3418  9811 9dc6bc                     sta dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0 ,x
  3419  9814 9008                       bcc dfatns1
  3420  9816 fec7bc                     inc dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1 ,x
  3421  9819 d003                       bne dfatns1
  3422  981b fec8bc                     inc dos_file_descriptors + dos_filedescriptor_offset_fileoffset+2 ,x
  3423                          dfatns1:
  3424                          
  3425                                  ;; increase sector
  3426                                  ;;
  3427  981e fec3bc                     inc dos_file_descriptors + dos_filedescriptor_offset_sectorincluster ,x
  3428  9821 bdc3bc                     lda dos_file_descriptors + dos_filedescriptor_offset_sectorincluster ,x
  3429  9824 ac04bc                     ldy dos_disk_table_offset
  3430                          
  3431  9827 d916bb                     cmp dos_disk_table + fs_fat32_sectors_per_cluster ,y
  3432                          
  3433                                  ;; and if necessary, advance to next cluster
  3434                                  ;;
  3435  982a f002                       beq dos_file_advance_to_next_cluster
  3436                          
  3437  982c 38                         sec
  3438  982d 60                         rts
  3439                          
  3440                          ;;         ========================
  3441                          
  3442                          dos_file_advance_to_next_cluster:
  3443                          
  3444                                  ;; set to sector 0 in cluster
  3445                                  ;;
  3446  982e acfabc                     ldy dos_current_file_descriptor_offset
  3447  9831 a900                       lda #$00
  3448  9833 99c3bc                     sta dos_file_descriptors+dos_filedescriptor_offset_sectorincluster,y
  3449                          
  3450                                  ;; read chained cluster number for fs_clusternumber
  3451                          
  3452                                  ;; FAT32 uses 32-bit cluster numbers.
  3453                                  ;; the text below may be misleading, as we have 8 sectors per cluster
  3454                                  ;; 512 / 4 = 128 cluster numbers per sector.
  3455                                  ;; To get the sector of the FAT containin a particular
  3456                                  ;; cluster entry, we thus need to shift the cluster number
  3457                                  ;; right 7 bits.  Then we add the start sector number of the FAT.
  3458                          
  3459  9836 20cd97                     jsr dos_set_current_cluster_from_file
  3460                          
  3461                                  ;; copy cluster to sector number
  3462                                  ;;
  3463  9839 a203                       ldx #$03
  3464                          dfanc1:
  3465  983b bdb4bc                     lda dos_current_cluster,x
  3466  983e 9db0bc                     sta dos_current_sector,x
  3467  9841 ca                         dex
  3468  9842 10f7                       bpl dfanc1
  3469                          
  3470                                  ;; Remember low byte of cluster number so that we can pull the
  3471                                  ;; cluster number for the next cluster out of the FAT sector
  3472                                  ;;
  3473  9844 adb4bc                     lda dos_current_cluster
  3474  9847 8d04bf                     sta dos_scratch_byte_1
  3475                          
  3476  984a 200b99                     jsr dos_cluster_to_fat_sector
  3477                          
  3478  984d 20f098                     jsr dos_remember_sd_sector
  3479                          
  3480                                  ;; copy from current cluster to SD sector address register
  3481                                  ;;
  3482  9850 a203                       ldx #$03
  3483  9852 08                         php
  3484                          dfanc41:
  3485  9853 bdb4bc                     lda dos_current_cluster,x
  3486  9856 9d81d6                     sta $d681,x
  3487  9859 ca                         dex
  3488  985a 10f7                       bpl dfanc41
  3489                          
  3490                          dfanc44:
  3491  985c 28                         plp
  3492  985d bdb4bc                     lda dos_current_cluster,x
  3493  9860 6900                       adc #$00
  3494  9862 9db4bc                     sta dos_current_cluster,x
  3495  9865 08                         php
  3496  9866 e8                         inx
  3497  9867 e004                       cpx #$04
  3498  9869 d0f1                       bne dfanc44
  3499                          
  3500  986b 28                         plp
  3501                          
  3502                                  ;; read FAT sector
  3503                                  ;;
  3504  986c 202da2                     jsr sd_readsector
  3505  986f b003                       bcs @readSectorOk
  3506  9871 4c2093                     jmp dos_return_error_already_set
  3507                          @readSectorOk:
  3508                          
  3509  9874 2018a2                     jsr sd_map_sectorbuffer
  3510                          
  3511                                  ;; now read the right four bytes out.
  3512                                  ;; cluster number needs to be shifted left 2 bits.
  3513                                  ;; we only need the lowest order byte.
  3514                                  ;; Get low byte of old cluster number from dos_scratch_byte_1
  3515                                  ;; where we put it.
  3516                                  ;;
  3517  9877 ad04bf                     lda dos_scratch_byte_1
  3518  987a 0a                         asl
  3519  987b 0a                         asl
  3520  987c aa                         tax
  3521                          
  3522                                  ;; get offset to current cluster field in current file descriptor ...
  3523  987d adfabc                     lda dos_current_file_descriptor_offset
  3524  9880 0906                       ora #dos_filedescriptor_offset_currentcluster
  3525  9882 a8                         tay
  3526                          
  3527                                  ;; ... and keep it handy, because we will need it a few times
  3528                                  ;;
  3529  9883 8c05bf                     sty dos_scratch_byte_2
  3530                          
  3531                                  ;; get offset of current cluster number field in file descriptor
  3532                                  ;; so that we can write the new cluster number in there.
  3533                                  ;;
  3534  9886 ac05bf                     ldy dos_scratch_byte_2
  3535                          
  3536  9889 a300                       ldz #$00
  3537  988b ad04bf                     lda dos_scratch_byte_1
  3538  988e 2940                       and #$40
  3539  9890 d00f                       bne dfanc_high
  3540                          
  3541  9892 bd00de             dfanc6: lda sd_sectorbuffer,x
  3542  9895 99b9bc                     sta dos_file_descriptors,y
  3543  9898 e8                         inx
  3544  9899 c8                         iny
  3545  989a 1b                         inz
  3546  989b c204                       cpz #$04
  3547  989d d0f3                       bne dfanc6
  3548  989f 800d                       bra dfanc_check
  3549                          
  3550                          dfanc_high:
  3551  98a1 bd00df                     lda sd_sectorbuffer+$100,x
  3552  98a4 99b9bc                     sta dos_file_descriptors,y
  3553  98a7 e8                         inx
  3554  98a8 c8                         iny
  3555  98a9 1b                         inz
  3556  98aa c204                       cpz #$04
  3557  98ac d0f3                       bne dfanc_high
  3558                          
  3559                          dfanc_check:
  3560                                  ;; check that resulting cluster number is valid.
  3561                          
  3562                          ;;         jsr debug_show_cluster_number
  3563                          
  3564                                  ;; get current cluster field address again
  3565                                  ;;
  3566  98ae ac05bf                     ldy dos_scratch_byte_2
  3567                          
  3568                                  ;; First, only the lower 28-bits are valid
  3569                                  ;;
  3570  98b1 b9bcbc                     lda dos_file_descriptors+3,y
  3571  98b4 290f                       and #$0f
  3572  98b6 99bcbc                     sta dos_file_descriptors+3,y
  3573                          
  3574                                  ;; Now check for special values:
  3575                                  ;; cluster 0 is invalid
  3576                                  ;;
  3577  98b9 b9bcbc                     lda dos_file_descriptors+3,y
  3578  98bc 19bbbc                     ora dos_file_descriptors+2,y
  3579  98bf 19babc                     ora dos_file_descriptors+1,y
  3580  98c2 19b9bc                     ora dos_file_descriptors,y
  3581  98c5 c900                       cmp #$00
  3582  98c7 f01f                       beq dfanc_fail
  3583                          
  3584                                  ;; $FFFFFF7 = bad cluster
  3585                                  ;; $FFFFFFF = end of file
  3586                                  ;; (we'll treat anything from $FFFFFF0-F as bad/invalid for simplicity)
  3587  98c9 b9bcbc                     lda dos_file_descriptors+3,y
  3588  98cc c90f                       cmp #$0f
  3589  98ce d013                       bne dfanc_ok
  3590  98d0 b9bbbc                     lda dos_file_descriptors+2,y
  3591  98d3 39babc                     and dos_file_descriptors+1,y
  3592  98d6 c9ff                       cmp #$ff
  3593  98d8 d009                       bne dfanc_ok
  3594  98da b9b9bc                     lda dos_file_descriptors,y
  3595  98dd 29f0                       and #$f0
  3596  98df c9f0                       cmp #$f0
  3597  98e1 f005                       beq dfanc_fail
  3598                          
  3599                          dfanc_ok:
  3600                                  ;; cluster number is okay
  3601  98e3 20fc98                     jsr dos_restore_sd_sector
  3602  98e6 38                         sec
  3603  98e7 60                         rts
  3604                          
  3605                          dfanc_fail:
  3606  98e8 20fc98                     jsr dos_restore_sd_sector
  3607  98eb a985                       lda #dos_errorcode_invalid_cluster
  3608  98ed 4c1d93                     jmp dos_return_error
  3609                          
  3610                                  ;; Some routines disturb the current SD card sector in the buffer,
  3611                                  ;; but where the caller might not expect or want this to happen.
  3612                                  ;; For this reason we have the following convenience routines for
  3613                                  ;; stashing and restoring the current ready sector.
  3614                          dos_remember_sd_sector:
  3615  98f0 a203                       ldx #3
  3616  98f2 bd81d6             -	lda $d681,x
  3617  98f5 9d55bd                     sta dos_stashed_sd_sector_number,x
  3618  98f8 ca                         dex
  3619  98f9 10f7                       bpl -
  3620  98fb 60                         rts
  3621                          
  3622                          dos_restore_sd_sector:
  3623  98fc a203                       ldx #3
  3624  98fe bd55bd             -	lda dos_stashed_sd_sector_number,x
  3625  9901 9d81d6                     sta $d681,x
  3626  9904 ca                         dex
  3627  9905 10f7                       bpl -
  3628  9907 202da2                     jsr sd_readsector
  3629  990a 60                         rts
  3630                          
  3631                          
  3632                          ;;         ========================
  3633                          
  3634                          dos_cluster_to_fat_sector:
  3635                                  ;; Take dos_current_cluster, as a cluster number,
  3636                                  ;; and compute the absolute sector number on the SD card
  3637                                  ;; where that cluster must live.
  3638                                  ;; INPUT: dos_current_cluster = cluster number
  3639                                  ;; OUTPUT: dos_current_cluster = absolute sector, which
  3640                                  ;;         contains the FAT sector that has the FAT entry
  3641                                  ;;         corresponding to the requested cluster number.
  3642                          
  3643                                  ;; shift right 7 times = divide by 128
  3644                                  ;;
  3645  990b a007                       ldy #$07
  3646  990d 18                 dfanc2: clc
  3647  990e 6eb7bc                     ror dos_current_cluster+3
  3648  9911 6eb6bc                     ror dos_current_cluster+2
  3649  9914 6eb5bc                     ror dos_current_cluster+1
  3650  9917 6eb4bc                     ror dos_current_cluster+0
  3651  991a 88                         dey
  3652  991b d0f0                       bne dfanc2
  3653                          
  3654                                  ;; add start of partition offset
  3655                                  ;;
  3656  991d ac04bc                     ldy dos_disk_table_offset
  3657  9920 a200                       ldx #$00
  3658  9922 18                         clc
  3659  9923 08                         php
  3660  9924 28                 dfanc3: plp
  3661  9925 bdb4bc                     lda dos_current_cluster,x
  3662  9928 7900bb                     adc dos_disk_table + fs_start_sector ,y
  3663  992b 9db4bc                     sta dos_current_cluster,x
  3664  992e 08                         php
  3665  992f c8                         iny
  3666  9930 e8                         inx
  3667  9931 e004                       cpx #$04
  3668  9933 d0ef                       bne dfanc3
  3669  9935 28                         plp
  3670                          
  3671                                  ;; add start of fat offset
  3672                                  ;;
  3673  9936 ac04bc                     ldy dos_disk_table_offset
  3674  9939 a200                       ldx #$00
  3675  993b 18                         clc
  3676  993c 08                         php
  3677  993d 28                 dfanc4: plp
  3678  993e bdb4bc                     lda dos_current_cluster,x
  3679  9941 790dbb                     adc dos_disk_table + fs_fat32_system_sectors ,y
  3680  9944 9db4bc                     sta dos_current_cluster,x
  3681  9947 08                         php
  3682  9948 c8                         iny
  3683  9949 e8                         inx
  3684  994a e002                       cpx #$02
  3685  994c d0ef                       bne dfanc4
  3686                          
  3687  994e 28                         plp
  3688                          
  3689  994f 60                         rts
  3690                          
  3691                          ;;         ========================
  3692                          
  3693                          !if DEBUG_HYPPO {
  3694                          dos_print_current_cluster:
  3695                          
  3696                                  ;; prints a message to the screen
  3697                                  ;;
  3698                                  ldx #<msg_clusternumber
  3699                                  ldy #>msg_clusternumber
  3700                                  jsr printmessage
  3701                                  ldy #$00
  3702                                  ldz dos_current_cluster+3
  3703                                  jsr printhex
  3704                                  ldz dos_current_cluster+2
  3705                                  jsr printhex
  3706                                  ldz dos_current_cluster+1
  3707                                  jsr printhex
  3708                                  ldz dos_current_cluster+0
  3709                                  jsr printhex
  3710                          
  3711                                  +Checkpoint "dos_print_current_cluster"
  3712                          
  3713                                  rts
  3714                          }
  3715                          
  3716                          ;;         ========================
  3717                          
  3718                          dos_readfileintomemory:
  3719                          
  3720                                  ;; assumes that filename is already set using "dos_setname", which
  3721                                  ;; copies filename string into "dos_requested_filename",
  3722                                  ;;        and sets length into "dos_requested_filename_length".
  3723                                  ;;
  3724                                  ;; assumes that the 32-bit load-address pointer is set by
  3725                                  ;; storing load-address at "dos_file_loadaddress+{0-3}"
  3726                          
  3727                                  ;; print some debug information
  3728                                  ;;
  3729                                  ;;         jsr dos_print_current_cluster
  3730                          
  3731                                  ;; Clear number of sectors read
  3732  9950 a200                       ldx #$00
  3733  9952 8eaabc                     stx dos_sectorsread
  3734  9955 8eabbc                     stx dos_sectorsread+1
  3735                          
  3736  9958 205794                     jsr dos_findfirst
  3737  995b 900e                       bcc l_dos_return_error_already_set
  3738                                  ;; close directory now that we have what we were looking for ...
  3739  995d 20f093                     jsr dos_closefile
  3740                          
  3741  9960 203694                     jsr dos_openfile
  3742  9963 9006                       bcc l_dos_return_error_already_set
  3743                          
  3744  9965 2018a2                     jsr sd_map_sectorbuffer
  3745                          
  3746  9968 4c6e99                     jmp drfim_sector_loop
  3747                          
  3748                          l_dos_return_error_already_set:
  3749  996b 4c2093                     jmp dos_return_error_already_set
  3750                          
  3751                          ;;         ========================
  3752                          
  3753                          drfim_sector_loop:
  3754                          
  3755  996e 20e197                     jsr dos_file_read_current_sector
  3756  9971 903d                       bcc drfim_eof
  3757                          
  3758                                  ;; copy sector to memory
  3759                                  ;;
  3760                          
  3761                                  ;; Work out how many bytes of this page we need to read
  3762  9973 20b699                     jsr dos_load_y_based_on_dos_bytes_remaining
  3763                          
  3764  9976 a200                       ldx #$00
  3765  9978 a300                       ldz #$00
  3766                          
  3767                                  ;; Actually write the bytes to memory that have been loaded
  3768                          drfim_rr1:
  3769  997a bd00de                     lda sd_sectorbuffer,x                ;; is $DE00
  3770  997d ea9218                     sta [<dos_file_loadaddress],z
  3771  9980 1b                         inz ;; dest offset
  3772  9981 e8                         inx ;; src offset
  3773  9982 88                         dey ;; bytes in page to copy
  3774  9983 d0f5                       bne drfim_rr1
  3775                          
  3776  9985 e319                       inw <dos_file_loadaddress+1
  3777                          
  3778                                  ;; Work out how many bytes of this page we need to read
  3779  9987 20b699                     jsr dos_load_y_based_on_dos_bytes_remaining
  3780                          
  3781                                  ;; Actually write the bytes to memory that have been loaded
  3782                          drfim_rr1b:
  3783  998a bd00df                     lda sd_sectorbuffer+$100,x        ;; is $DF00
  3784  998d ea9218                     sta [<dos_file_loadaddress],z
  3785  9990 1b                         inz ;; dest offset
  3786  9991 e8                         inx ;; src offset
  3787  9992 88                         dey ;; bytes in page to copy
  3788  9993 d0f5                       bne drfim_rr1b
  3789                          
  3790  9995 200898                     jsr dos_file_advance_to_next_sector
  3791  9998 9016                       bcc drfim_eof
  3792                          
  3793                                  ;; We only allow loading into a 16MB space
  3794                                  ;; Provided that we check the load address before starting,
  3795                                  ;; this ensures that a user-land request cannot load a huge file
  3796                                  ;; that eventually overwrites the hypervisor and results in privilege
  3797                                  ;; escalation.
  3798                                  ;; This restriction to a 16MB space is implemented by only incrementing the middle 2 bytes of
  3799                                  ;; the address, instead of all 3 upper bytes.
  3800                                  ;;
  3801  999a e319                       inw <dos_file_loadaddress+1
  3802                          
  3803                                  ;; Increment number of sectors read (16 bit valie)
  3804                                  ;;
  3805  999c eeaabc                     inc dos_sectorsread
  3806  999f d0cd                       bne drfim_sector_loop
  3807                          
  3808  99a1 eeabbc                     inc dos_sectorsread+1
  3809                                  ;; see if there is another sector
  3810  99a4 d0c8                       bne drfim_sector_loop
  3811                          
  3812  99a6 20f093                     jsr dos_closefile
  3813                          
  3814                                  ;; File is >65535 sectors (32MB), report error
  3815                                  ;;
  3816  99a9 a983                       lda #dos_errorcode_file_too_long
  3817  99ab 4c1d93                     jmp dos_return_error
  3818                          
  3819                          ;;         ========================
  3820                          
  3821                          drfim_eof_pop_pc:
  3822  99ae 68                         pla
  3823  99af 68                         pla
  3824                          
  3825                          drfim_eof:
  3826                          
  3827  99b0 20f093                     jsr dos_closefile
  3828  99b3 4c1693                     jmp dos_return_success
  3829                          
  3830                          dos_load_y_based_on_dos_bytes_remaining:
  3831  99b6 a000                       ldy #$00
  3832  99b8 adadbc                     lda dos_bytes_remaining+1
  3833  99bb 0daebc                     ora dos_bytes_remaining+2
  3834  99be 0dafbc                     ora dos_bytes_remaining+3
  3835  99c1 d00e                       bne +
  3836  99c3 adacbc                     lda dos_bytes_remaining+0
  3837                                  ;; If no more bytes to read, then jump to EOF
  3838  99c6 f0e6                       beq drfim_eof_pop_pc
  3839  99c8 acacbc                     ldy dos_bytes_remaining+0
  3840  99cb a900                       lda #$00
  3841  99cd 8dacbc                     sta  dos_bytes_remaining+0
  3842  99d0 60                         rts
  3843                          +
  3844  99d1 adadbc                     lda dos_bytes_remaining+1
  3845  99d4 38                         sec
  3846  99d5 e901                       sbc #$01
  3847  99d7 8dadbc                     sta dos_bytes_remaining+1
  3848  99da adaebc                     lda dos_bytes_remaining+2
  3849  99dd e900                       sbc #0
  3850  99df 8daebc                     sta dos_bytes_remaining+2
  3851  99e2 adafbc                     lda dos_bytes_remaining+3
  3852  99e5 e900                       sbc #0
  3853  99e7 8dafbc                     sta dos_bytes_remaining+3
  3854  99ea 60                         rts
  3855                          
  3856                          dos_updatereturnsize:
  3857                          
  3858                          ;; 	ldx dos_bytes_remaining+3
  3859                          ;; 	jsr checkpoint_bytetohex
  3860                          ;; 	sty lenhex+0
  3861                          ;; 	stx lenhex+1
  3862                          ;; 	ldx dos_bytes_remaining+2
  3863                          ;; 	jsr checkpoint_bytetohex
  3864                          ;; 	sty lenhex+2
  3865                          ;; 	stx lenhex+3
  3866                          ;; 	ldx dos_bytes_remaining+1
  3867                          ;; 	jsr checkpoint_bytetohex
  3868                          ;; 	sty lenhex+4
  3869                          ;; 	stx lenhex+5
  3870                          ;; 	ldx dos_bytes_remaining+0
  3871                          ;; 	jsr checkpoint_bytetohex
  3872                          ;; 	sty lenhex+6
  3873                          ;; 	stx lenhex+7
  3874                          
  3875                          ;; 	jsr checkpoint
  3876                          ;; 	!8 0
  3877                          ;; 	ascii("$")
  3878                          ;; lenhex:
  3879                          ;; 	ascii("%%%%%%%% bytes remaining.")
  3880                          ;; 	!8 0
  3881                          
  3882  99eb adacbc                     lda dos_bytes_remaining+0
  3883  99ee 0dadbc                     ora dos_bytes_remaining+1
  3884  99f1 0daebc                     ora dos_bytes_remaining+2
  3885  99f4 0dafbc                     ora dos_bytes_remaining+3
  3886  99f7 d00a                       bne +
  3887                          
  3888                                  ;; End of file: So zero bytes returned
  3889  99f9 a900                       lda #$00
  3890  99fb 8d41d6                     sta hypervisor_x
  3891  99fe 8d42d6                     sta hypervisor_y
  3892  9a01 18                         clc
  3893  9a02 60                         rts
  3894                          
  3895                          +
  3896                                  ;; Indicate how many bytes we are returning
  3897  9a03 a200                       ldx #<$0200
  3898  9a05 a002                       ldy #>$0200
  3899                          
  3900  9a07 adaebc                     lda dos_bytes_remaining+2
  3901  9a0a 0dafbc                     ora dos_bytes_remaining+3
  3902  9a0d d017                       bne +   ;; lots more to read
  3903  9a0f adadbc                     lda dos_bytes_remaining+1
  3904  9a12 c902                       cmp #2
  3905  9a14 b010                       bcs +   ;; at least a whole sector more to read
  3906                          
  3907                                  ;; Only a fractional part of a sector to read, so zero out remaining
  3908                          
  3909                                  ;; Update number of bytes for fractional sector read
  3910  9a16 aeacbc                     ldx dos_bytes_remaining+0
  3911  9a19 acadbc                     ldy dos_bytes_remaining+1
  3912                          
  3913  9a1c a900                       lda #$00
  3914  9a1e 8dacbc                     sta dos_bytes_remaining+0
  3915                                  ;; Actually make it look like 1 sector to go, so we decrement that to zero
  3916                                  ;; immediately below
  3917  9a21 a902                       lda #$02
  3918  9a23 8dadbc                     sta dos_bytes_remaining+1
  3919                                  ;; FALL THROUGH
  3920                          +
  3921                          
  3922                                  ;; Deduct one sector from the remaining
  3923  9a26 adadbc                     lda dos_bytes_remaining+1
  3924  9a29 38                         sec
  3925  9a2a e902                       sbc #2
  3926  9a2c 8dadbc                     sta dos_bytes_remaining+1
  3927  9a2f adaebc                     lda dos_bytes_remaining+2
  3928  9a32 e900                       sbc #0
  3929  9a34 8daebc                     sta dos_bytes_remaining+2
  3930  9a37 adafbc                     lda dos_bytes_remaining+3
  3931  9a3a e900                       sbc #0
  3932  9a3c 8dafbc                     sta dos_bytes_remaining+3
  3933                          
  3934                                  ;; Store number of bytes read in X and Y for calling process
  3935  9a3f 8e41d6                     stx hypervisor_x
  3936  9a42 8c42d6                     sty hypervisor_y
  3937                          
  3938  9a45 2018a2                     jsr sd_map_sectorbuffer
  3939                          
  3940  9a48 60                         rts
  3941                          
  3942                          dos_readfile:
  3943                          
  3944  9a49 20eb99                     jsr dos_updatereturnsize
  3945  9a4c b001                       bcs +
  3946  9a4e 60                         rts
  3947                          
  3948                          +	;; Now read sector and return
  3949  9a4f 20e197                     jsr dos_file_read_current_sector
  3950  9a52 b00d                       bcs drwf_readwritesuccess
  3951  9a54 60                         rts
  3952                          
  3953                          ;;         ========================
  3954                          
  3955                          dos_writefile:
  3956                          
  3957  9a55 20eb99                     jsr dos_updatereturnsize
  3958  9a58 b001                       bcs +
  3959  9a5a 60                         rts
  3960                          
  3961                          +	;; Now write sector and return
  3962  9a5b 20e797                     jsr dos_file_write_current_sector
  3963  9a5e b001                       bcs drwf_readwritesuccess
  3964  9a60 60                         rts
  3965                          
  3966                          drwf_readwritesuccess:
  3967  9a61 200898                     jsr dos_file_advance_to_next_sector
  3968                          
  3969  9a64 38                         sec
  3970  9a65 60                         rts
  3971                          
  3972                          ;;         ========================
  3973                          
  3974                          dos_rmfile:
  3975  9a66 20c394                     jsr dos_readdir_retreivelastentry
  3976  9a69 2018a2                     jsr sd_map_sectorbuffer
  3977  9a6c 20e197                     jsr dos_file_read_current_sector
  3978                          
  3979  9a6f ad0ebc                     lda dos_direntstart_offsetinsector+0
  3980  9a72 8500                       sta <(dos_scratch_vector+0)
  3981  9a74 ad0fbc                     lda dos_direntstart_offsetinsector+1
  3982  9a77 18                         clc
  3983  9a78 69de                       adc #$de   ;; high byte of SD card sector buffer
  3984  9a7a 8501                       sta <(dos_scratch_vector+1)
  3985                          
  3986  9a7c a000                       ldy #$00
  3987  9a7e a9e5                       lda #$e5
  3988  9a80 9100                       sta (<dos_scratch_vector),y
  3989                          
  3990  9a82 209ea1                     jsr write_non_mbr_sector
  3991  9a85 20afa1                     jsr sd_wait_for_ready
  3992                          
  3993                                  ;; Work out where it will be in the 2nd FAT
  3994  9a88 ad04bc                     lda dos_disk_table_offset
  3995  9a8b 0909                       ora #fs_fat32_length_of_fat
  3996  9a8d a8                         tay
  3997  9a8e a200                       ldx #0
  3998  9a90 bd81d6             -       lda $d681,x
  3999  9a93 7900bb                     adc dos_disk_table,y
  4000  9a96 c8                         iny
  4001  9a97 e8                         inx
  4002  9a98 e004                       cpx #4
  4003  9a9a d0f4                       bne -
  4004                          
  4005                                  ;; Write FAT sector to FAT2
  4006  9a9c 209ea1                     jsr write_non_mbr_sector
  4007  9a9f 20afa1                     jsr sd_wait_for_ready
  4008                          
  4009  9aa2 a203                       ldx #$03
  4010  9aa4 bd5ebc             -       lda dos_dirent_cluster+0,x
  4011  9aa7 9db4bc                     sta dos_current_cluster+0,x
  4012  9aaa ca                         dex
  4013  9aab 10f7                       bpl -
  4014                          
  4015                                  ; start clearing fat entries until eof or fail
  4016  9aad 20b79a             -       jsr dos_rmfile_rmchainentry
  4017  9ab0 9003                       bcc +
  4018  9ab2 4cad9a                     jmp -
  4019                          
  4020  9ab5 38                 +       sec
  4021  9ab6 60                         rts
  4022                          
  4023                          dos_rmfile_rmchainentry:
  4024                          
  4025                                  ;; Remember low byte of cluster number so that we can pull the
  4026                                  ;; cluster number for the next cluster out of the FAT sector
  4027  9ab7 adb4bc                     lda dos_current_cluster
  4028  9aba 8d04bf                     sta dos_scratch_byte_1
  4029                          
  4030  9abd 200b99                     jsr dos_cluster_to_fat_sector
  4031                          
  4032                                  ;; copy from current cluster to SD sector address register
  4033  9ac0 a203                       ldx #$03
  4034  9ac2 08                         php
  4035  9ac3 bdb4bc             drf2:   lda dos_current_cluster,x
  4036  9ac6 9d81d6                     sta $d681,x
  4037  9ac9 ca                         dex
  4038  9aca 10f7                       bpl drf2
  4039                          
  4040  9acc 28                 drf3:   plp
  4041  9acd bdb4bc                     lda dos_current_cluster,x
  4042  9ad0 6900                       adc #$00                                ; carry (set/cleared at end of dos_cluster_to_fat_sector)
  4043  9ad2 9db4bc                     sta dos_current_cluster,x
  4044  9ad5 08                         php
  4045  9ad6 e8                         inx
  4046  9ad7 e004                       cpx #$04
  4047  9ad9 d0f1                       bne drf3
  4048                          
  4049  9adb 28                         plp
  4050                          
  4051                                  ;; read FAT sector
  4052  9adc 202da2                     jsr sd_readsector
  4053  9adf b003                       bcs +
  4054  9ae1 4c2093                     jmp dos_return_error_already_set
  4055                          
  4056  9ae4 2018a2             +       jsr sd_map_sectorbuffer
  4057                          
  4058                                  ;; now read the right four bytes out.
  4059                                  ;; cluster number needs to be shifted left 2 bits.
  4060                                  ;; we only need the lowest order byte.
  4061                                  ;; Get low byte of old cluster number from dos_scratch_byte_1
  4062                                  ;; where we put it.
  4063  9ae7 ad04bf                     lda dos_scratch_byte_1          ; 63 entries in half of fat sector = 111111
  4064  9aea 0a                         asl
  4065  9aeb 0a                         asl
  4066  9aec aa                         tax                             ; we've multiplied by 2 and gotten rid of the high sector bit ($40)
  4067                          
  4068                                  ;; get offset to current cluster field in current file descriptor ...
  4069  9aed adfabc                     lda dos_current_file_descriptor_offset
  4070  9af0 0906                       ora #dos_filedescriptor_offset_currentcluster
  4071  9af2 a8                         tay
  4072                          
  4073                                  ;; ... and keep it handy, because we will need it a few times
  4074  9af3 8c05bf                     sty dos_scratch_byte_2
  4075                          
  4076                                  ;; get offset of current cluster number field in file descriptor
  4077                                  ;; so that we can write the new cluster number in there.
  4078  9af6 ac05bf                     ldy dos_scratch_byte_2
  4079                          
  4080  9af9 a300                       ldz #$00
  4081  9afb ad04bf                     lda dos_scratch_byte_1
  4082  9afe 2940                       and #$40
  4083  9b00 d012                       bne drf_high
  4084                          
  4085                          drf_low:
  4086  9b02 bd00de                     lda sd_sectorbuffer,x
  4087  9b05 99b9bc                     sta dos_file_descriptors,y
  4088  9b08 990018                     sta $1800,y
  4089  9b0b e8                         inx
  4090  9b0c c8                         iny
  4091  9b0d 1b                         inz
  4092  9b0e c204                       cpz #$04
  4093  9b10 d0f0                       bne drf_low
  4094  9b12 800d                       bra drf_check
  4095                          
  4096                          drf_high:
  4097  9b14 bd00df                     lda sd_sectorbuffer+$100,x
  4098  9b17 99b9bc                     sta dos_file_descriptors,y
  4099  9b1a e8                         inx
  4100  9b1b c8                         iny
  4101  9b1c 1b                         inz
  4102  9b1d c204                       cpz #$04
  4103  9b1f d0f3                       bne drf_high
  4104                          
  4105                          drf_check:
  4106                                  ;; get current cluster field address again
  4107  9b21 ac05bf                     ldy dos_scratch_byte_2
  4108                          
  4109                                  ;; First, only the lower 28-bits are valid
  4110  9b24 b9bcbc                     lda dos_file_descriptors+3,y
  4111  9b27 290f                       and #$0f
  4112  9b29 99bcbc                     sta dos_file_descriptors+3,y
  4113                          
  4114                                  ;; Now check for special values:
  4115                                  ;; cluster 0 is invalid (can this ever happen in a cluster chain?)
  4116  9b2c b9bcbc                     lda dos_file_descriptors+3,y
  4117  9b2f 19bbbc                     ora dos_file_descriptors+2,y
  4118  9b32 19babc                     ora dos_file_descriptors+1,y
  4119  9b35 19b9bc                     ora dos_file_descriptors,y
  4120  9b38 c900                       cmp #$00
  4121  9b3a f024                       beq drf_fail
  4122                          
  4123                                  ;; $?FFFFFF7 = bad cluster
  4124                                  ;; $?FFFFFF8-$?FFFFFFF = end of file
  4125                                  ;; (we'll treat anything from $FFFFFF0-F as eof/bad/invalid for simplicity)
  4126  9b3c b9bcbc                     lda dos_file_descriptors+3,y
  4127  9b3f c90f                       cmp #$0f
  4128  9b41 d013                       bne drf_ok                              ; not $0f -> regular data file
  4129  9b43 b9bbbc                     lda dos_file_descriptors+2,y
  4130  9b46 39babc                     and dos_file_descriptors+1,y
  4131  9b49 c9ff                       cmp #$ff
  4132  9b4b d009                       bne drf_ok                              ; not $ffff -> regular data file
  4133  9b4d b9b9bc                     lda dos_file_descriptors,y
  4134  9b50 29f0                       and #$f0
  4135  9b52 c9f0                       cmp #$f0
  4136  9b54 f005                       beq drf_eof                             ; $0ffffff? -> eof marker
  4137                          
  4138                          drf_ok:
  4139  9b56 20629b                     jsr drf_clearwriteandincreasesector
  4140  9b59 38                         sec
  4141  9b5a 60                         rts
  4142                          
  4143                          drf_eof:
  4144  9b5b 20629b                     jsr drf_clearwriteandincreasesector
  4145  9b5e 18                         clc
  4146  9b5f 60                         rts
  4147                          
  4148                          drf_fail:
  4149  9b60 18                         clc
  4150  9b61 60                         rts
  4151                          
  4152                          drf_clearwriteandincreasesector
  4153  9b62 ad04bf                     lda dos_scratch_byte_1
  4154  9b65 0a                         asl
  4155  9b66 0a                         asl
  4156  9b67 aa                         tax
  4157                          
  4158  9b68 a300                       ldz #$00
  4159  9b6a ad04bf                     lda dos_scratch_byte_1
  4160  9b6d 2940                       and #$40
  4161  9b6f d00d                       bne drf_ok_clearinhighsector
  4162                          
  4163                          drf_ok_clearinlowsector:
  4164  9b71 a900                       lda #$00
  4165  9b73 9d00de             -       sta sd_sectorbuffer,x
  4166  9b76 e8                         inx
  4167  9b77 1b                         inz
  4168  9b78 c204                       cpz #$04
  4169  9b7a d0f7                       bne -
  4170  9b7c 800b                       bra drf_ok_cleardone
  4171                          
  4172                          drf_ok_clearinhighsector:
  4173  9b7e a900                       lda #$00
  4174  9b80 9d00df             -       sta sd_sectorbuffer+$100,x
  4175  9b83 e8                         inx
  4176  9b84 1b                         inz
  4177  9b85 c204                       cpz #$04
  4178  9b87 d0f7                       bne -
  4179                          
  4180                          drf_ok_cleardone:
  4181  9b89 203ea2                     jsr sd_writesector
  4182  9b8c b9b9bc                     lda dos_file_descriptors+0,y
  4183  9b8f 8db4bc                     sta dos_current_cluster+0
  4184  9b92 b9babc                     lda dos_file_descriptors+1,y
  4185  9b95 8db5bc                     sta dos_current_cluster+1
  4186  9b98 b9bbbc                     lda dos_file_descriptors+2,y
  4187  9b9b 8db6bc                     sta dos_current_cluster+2
  4188  9b9e b9bcbc                     lda dos_file_descriptors+3,y
  4189  9ba1 8db7bc                     sta dos_current_cluster+3
  4190  9ba4 60                         rts
  4191                          
  4192                          ;;         ========================
  4193                          
  4194                          dos_fstat
  4195                          
  4196                                  ;; rewind to start of directory entry
  4197  9ba5 20c394                     jsr dos_readdir_retreivelastentry
  4198  9ba8 2018a2                     jsr sd_map_sectorbuffer
  4199  9bab 20e197                     jsr dos_file_read_current_sector
  4200                          
  4201  9bae a020                       ldy #32
  4202  9bb0 adfabc                     lda dos_current_file_descriptor_offset
  4203  9bb3 090b                       ora #dos_filedescriptor_offset_offsetinsector
  4204  9bb5 aa                         tax
  4205  9bb6 bdb9bc                     lda dos_file_descriptors,x
  4206  9bb9 9106                       sta (<hypervisor_userspace_copy_vector),y       ; write directory entry offset to userland+32
  4207  9bbb 8500                       sta <dos_scratch_vector
  4208  9bbd bdbabc                     lda dos_file_descriptors+1,x
  4209  9bc0 c8                         iny
  4210  9bc1 9106                       sta (<hypervisor_userspace_copy_vector),y       ; write directory entry offset to userland+33
  4211  9bc3 18                         clc
  4212  9bc4 69de                       adc #$de   ;; high byte of SD card sector buffer
  4213  9bc6 8501                       sta <(dos_scratch_vector+1)
  4214                          
  4215  9bc8 a000                       ldy #0                                       ;; copy first 32 bytes of directory entry to userland+0
  4216  9bca b100               tdfs:   lda (<dos_scratch_vector),y
  4217  9bcc 9106                       sta (<hypervisor_userspace_copy_vector),y
  4218  9bce c8                         iny
  4219  9bcf c020                       cpy #32
  4220  9bd1 d0f7                       bne tdfs
  4221                          
  4222  9bd3 38                         sec
  4223  9bd4 60                         rts
  4224                          
  4225                          ;;         ========================
  4226                          
  4227                          dos_setname:
  4228                          
  4229                                  ;; INPUT: .X .Y = pointer to filename,
  4230                                  ;;                 filename string must be terminated with $00
  4231                                  ;;                 filename string must be <= $3F chars
  4232                          
  4233  9bd5 8600                       stx <dos_scratch_vector
  4234  9bd7 8401                       sty <(dos_scratch_vector+1)
  4235  9bd9 a000                       ldy #$00
  4236                          
  4237  9bdb b100               lr11:   lda (<dos_scratch_vector),y
  4238  9bdd 9968bc                     sta dos_requested_filename,y
  4239  9be0 f00e                       beq dsn_eon
  4240  9be2 c8                         iny
  4241  9be3 c040                       cpy #$40
  4242  9be5 d0f4                       bne lr11
  4243                          
  4244  9be7 a900                       lda #0
  4245  9be9 8d67bc                     sta dos_requested_filename_len
  4246  9bec a981                       lda #dos_errorcode_name_too_long
  4247  9bee 18                         clc
  4248  9bef 60                         rts
  4249                          
  4250                          dsn_eon:
  4251  9bf0 8c67bc                     sty dos_requested_filename_len
  4252                          
  4253  9bf3 38                         sec
  4254  9bf4 60                         rts
  4255                          
  4256                          ;;         ========================
  4257                          
  4258                                  ;; Flags lookup tables
  4259                                  ;; drive 0    drive 1    drive 0+1  drive 0+1
  4260                          dos_attach_imgena_bits          ;; $d68b
  4261  9bf5 07383f3f                   !8 %00000111, %00111000, %00111111, %00111111
  4262                          dos_attach_typeflg_bits         ;; $d68b/a
  4263  9bf9 4080c0c0                   !8 %01000000, %10000000, %11000000, %11000000
  4264                          dos_attach_realdrv_bits         ;; $d6a1
  4265  9bfd 01040505                   !8 %00000001, %00000100, %00000101, %00000101
  4266                          
  4267                          dos_attach:
  4268                                  ;; NEW CALL DOS 1.3
  4269                                  ;;
  4270                                  ;; handles both attaching and detaching images and real drives
  4271                                  ;;
  4272                                  ;; X.0 - DRVNUM  select drive 0 or 1
  4273                                  ;; X.1 - BOTHDRV (MODE=detach) selects both drives
  4274                                  ;; X.6 - NOREAL  (MODE=detach) don't attach real drive if set
  4275                                  ;; X.7 - MODE    select mode 0 - attach, 1 - detach
  4276                          
  4277                                  ;; set the attach bits according to the selected drives
  4278  9c01 8a                         txa
  4279  9c02 3002                       bmi @detach_multi_drive ;; only detach supports both drives at once
  4280  9c04 2901                       and #$01                ;; limit to 1
  4281                          @detach_multi_drive:
  4282  9c06 2903                       and #$03                ;; limit to 3
  4283  9c08 a8                         tay                     ;; offset into dos_attach_*_bits tables
  4284                          
  4285  9c09 8a                         txa                     ;; sets N and Z flags
  4286  9c0a 1035                       bpl dos_diskattach      ;; bit 7 not set (N flag), so we want to attach
  4287                          
  4288  9c0c 2940                       and #$40
  4289  9c0e aa                         tax                     ;; we only need the noreal flag later
  4290                          
  4291                                  ;; now we detach the drives
  4292  9c0f b9f99b                     lda dos_attach_typeflg_bits,y
  4293  9c12 1c8ad6                     trb $d68a               ;; clear d64/d71 flags
  4294  9c15 19f59b                     ora dos_attach_imgena_bits,y
  4295  9c18 1c8bd6                     trb $d68b		;; clear mount, d81/d65 flags
  4296                          
  4297  9c1b b9fd9b                     lda dos_attach_realdrv_bits,y
  4298  9c1e e040                       cpx #$40                ;; check for noreal flag
  4299  9c20 f007                       beq @attach_detach_noreal
  4300  9c22 0ca1d6                     tsb $d6a1               ;; enable real drive(s)
  4301  9c25 a900                       lda #0
  4302  9c27 8005                       bra @attach_detach_flags
  4303                          @attach_detach_noreal:
  4304  9c29 1ca1d6                     trb $d6a1               ;; disable real drive(s)
  4305  9c2c a940                       lda #d81_image_flag_noreal
  4306                          
  4307                                  ;; set mount flags in currenttask
  4308                          @attach_detach_flags:
  4309  9c2e c000                       cpy #$00
  4310  9c30 d005                       bne @attach_detach_1
  4311                          @attach_detach_both:
  4312  9c32 8d11bd                     sta currenttask_d81_image0_flags
  4313  9c35 8007                       bra @attach_detach_flags_done
  4314                          @attach_detach_1:
  4315  9c37 8d12bd                     sta currenttask_d81_image1_flags
  4316  9c3a c002                       cpy #$02
  4317  9c3c b0f4                       bcs @attach_detach_both
  4318                          @attach_detach_flags_done:
  4319                          
  4320  9c3e 4c1693                     jmp dos_return_success
  4321                          
  4322                          dos_diskattach:
  4323                                  ;; dos_attach_bits determines on which drive it works
  4324                                  ;;
  4325                                  ;; Assumes only that D81 file name has been set with dos_setname.
  4326                                  ;;
  4327  9c41 8438                       sty <dos_attach_offset  ;; save Y offset into dos_attach_*_bits
  4328                          
  4329                                  ;; Check if the filename of the disk image is too long
  4330  9c43 ae67bc                     ldx dos_requested_filename_len
  4331  9c46 e020                       cpx #d81_image_max_namelen
  4332  9c48 9005                       bcc @d81lenok
  4333  9c4a a981                       lda #dos_errorcode_name_too_long
  4334  9c4c 4c1d93                     jmp dos_return_error
  4335                          
  4336                          @d81lenok
  4337  9c4f 204a94                     jsr dos_findfile
  4338  9c52 b003                       bcs @d81a1
  4339                          
  4340                                  ;; dos_findfile sets the error
  4341  9c54 4c2093                     jmp dos_return_error_already_set
  4342                          
  4343                          ;;         ========================
  4344                          
  4345                          @d81a1:
  4346                                  ;; Why do we call closefile here?
  4347                                  ;; -> because dos_findfile/first only closes on file_not_found
  4348  9c57 20f093                     jsr dos_closefile
  4349                          
  4350  9c5a 20109d                     jsr dos_checkimage
  4351  9c5d b003                       bcs @d81a1a
  4352  9c5f 4c2093                     jmp dos_return_error_already_set
  4353                          
  4354                          @d81a1a:
  4355                                  ;; copy sector number from $D681 to DxSTARTSEC (D68C or D690)
  4356                                  ;;
  4357  9c62 a303                       ldz #$03                ;; disk 0 is D68C-D68F
  4358  9c64 a538                       lda <dos_attach_offset  ;; fetch disk offset
  4359  9c66 f00b                       beq @attach_disk_0
  4360  9c68 a307                       ldz #$07                ;; disk 1 is D690-D693
  4361                          
  4362  9c6a a901                       lda #%00000001
  4363  9c6c 2c8bd6                     bit $d68b               ;; check if disk 0 is image
  4364  9c6f f020                       beq @attach_copy_sector ;; no image -> proceed
  4365  9c71 8007                       bra @attach_check_double
  4366                          
  4367                          @attach_disk_0:
  4368  9c73 a908                       lda #%00001000
  4369  9c75 2c8bd6                     bit $d68b               ;; check if disk 1 is image
  4370  9c78 f017                       beq @attach_copy_sector ;; no image -> proceed
  4371                          
  4372                          @attach_check_double
  4373  9c7a 6b                         tza
  4374  9c7b 4904                       eor #$04
  4375  9c7d a8                         tay
  4376  9c7e a203                       ldx #$03
  4377  9c80 bd81d6             -       lda $d681,x		;; resolved sector number
  4378  9c83 d98cd6                     cmp $d68c,y  		;; sector number of disk image
  4379  9c86 d009                       bne @attach_copy_sector
  4380  9c88 88                         dey
  4381  9c89 ca                         dex
  4382  9c8a 10f4                       bpl -
  4383                          
  4384                                  ;; same sector number, error out
  4385  9c8c a98f                       lda #dos_errorcode_double_attach
  4386  9c8e 4c1d93                     jmp dos_return_error
  4387                          
  4388                          @attach_copy_sector:
  4389  9c91 6b                         tza
  4390  9c92 a8                         tay
  4391  9c93 a203                       ldx #$03
  4392  9c95 bd81d6             -       lda $d681,x		;; resolved sector number
  4393  9c98 998cd6                     sta $d68c,y  		;; sector number of disk image
  4394  9c9b 88                         dey
  4395  9c9c ca                         dex
  4396  9c9d 10f6                       bpl -
  4397                          
  4398                                  ;; disable real floppy
  4399  9c9f a438                       ldy <dos_attach_offset
  4400  9ca1 b9fd9b                     lda dos_attach_realdrv_bits,y
  4401  9ca4 1ca1d6                     trb $d6a1
  4402                          
  4403                                  ;; Set flags to indicate it is mounted (and read-write).
  4404                                  ;; clear D65 mega disk flag,
  4405                                  ;; But don't mess up the flags for the 2nd drive
  4406  9ca7 b9f59b                     lda dos_attach_imgena_bits,y
  4407  9caa 0c8bd6                     tsb $d68b
  4408                                  ;; Clear D64 flag
  4409  9cad b9f99b                     lda dos_attach_typeflg_bits,y
  4410  9cb0 aa                         tax
  4411  9cb1 1c8ad6                     trb $d68a
  4412                          
  4413                                  ;; Check what dos_checkimage detected
  4414  9cb4 a52b                       lda <disk_lasttype
  4415  9cb6 c940                       cmp #64
  4416  9cb8 d006                       bne @not_d64
  4417                          
  4418                                  ;; Set D64 flag
  4419  9cba 8a                         txa
  4420  9cbb 0c8ad6                     tsb $d68a
  4421  9cbe 8015                       bra @d81attach_typeset
  4422                          
  4423                          @not_d64:
  4424  9cc0 c947                       cmp #71
  4425  9cc2 d009                       bne @not_d71
  4426                          
  4427                                  ;; D71 disk image
  4428                                  ;; Set both the D64 and the D65 flags to mean "big D64" = D71 image
  4429  9cc4 8a                         txa
  4430  9cc5 0c8ad6                     tsb $d68a
  4431  9cc8 0c8bd6                     tsb $d68b
  4432  9ccb 8008                       bra @d81attach_typeset
  4433                          
  4434                          @not_d71:
  4435  9ccd c941                       cmp #65
  4436  9ccf d004                       bne @d81attach_typeset
  4437                          
  4438                                  ;; D65 disk image
  4439                                  ;; Set megadisk flag
  4440  9cd1 8a                         txa
  4441  9cd2 0c8bd6                     tsb $d68b
  4442                          
  4443                          @d81attach_typeset:
  4444  9cd5 e080                       cpx #$80
  4445  9cd7 f01b                       beq @d81attach1_typeset
  4446                          
  4447                                  +Checkpoint "dos_attach 0 <success>"
  4448                          
  4449                                  ;; Save name and set mount flag for disk image in process descriptor block
  4450  9cd9 a905                       lda #(d81_image_flag_mounted | d81_image_flag_write_en)
  4451  9cdb 8d11bd                     sta currenttask_d81_image0_flags
  4452                          
  4453  9cde ae67bc                     ldx dos_requested_filename_len
  4454                          
  4455                                  ;; Name not too long, save name and length
  4456  9ce1 8e13bd                     stx currenttask_d81_image0_namelen
  4457  9ce4 a200                       ldx #0
  4458  9ce6 bd68bc             -       lda dos_requested_filename,x
  4459  9ce9 9d15bd                     sta currenttask_d81_image0_name,x
  4460  9cec e8                         inx
  4461  9ced ec13bd                     cpx currenttask_d81_image0_namelen
  4462  9cf0 d0f4                       bne -
  4463                          
  4464  9cf2 8019                       bra @attach_success
  4465                          
  4466                          @d81attach1_typeset:
  4467                          
  4468                                  +Checkpoint "dos_attach 1 <success>"
  4469                          
  4470                                  ;; Save name and set mount flag for disk image in process descriptor block
  4471  9cf4 a905                       lda #(d81_image_flag_mounted | d81_image_flag_write_en)
  4472  9cf6 8d12bd                     sta currenttask_d81_image1_flags
  4473                          
  4474  9cf9 ae67bc                     ldx dos_requested_filename_len
  4475                          
  4476                                  ;; Name not too long, save name and length
  4477  9cfc 8e14bd                     stx currenttask_d81_image1_namelen
  4478  9cff a200                       ldx #0
  4479  9d01 bd68bc             -       lda dos_requested_filename,x
  4480  9d04 9d35bd                     sta currenttask_d81_image1_name,x
  4481  9d07 e8                         inx
  4482  9d08 ec14bd                     cpx currenttask_d81_image1_namelen
  4483  9d0b d0f4                       bne -
  4484                          
  4485                          @attach_success:
  4486  9d0d 4c1693                     jmp dos_return_success
  4487                          
  4488                          dos_checkimage:
  4489                                  ;; now we need to check that the file is long enough,
  4490                                  ;; and also that the clusters are contiguous.
  4491                          
  4492                                  ;; Start by opening the file
  4493                                  ;;
  4494  9d10 204697                     jsr dos_set_current_file_from_dirent
  4495  9d13 9005                       bcc @fileNotOpenedOk
  4496                          
  4497  9d15 203694                     jsr dos_openfile
  4498  9d18 b003                       bcs @fileOpenedOk
  4499                          @fileNotOpenedOk:
  4500  9d1a 4c2093                     jmp dos_return_error_already_set
  4501                          @fileOpenedOk:
  4502                          
  4503                                  ;; work out how many clusters we need
  4504                                  ;; We need 1600 sectors, so halve for every zero tail
  4505                                  ;; bit in sectors per cluster.  we can do this because
  4506                                  ;; clusters in FAT must be 2^n sectors.
  4507                                  ;;
  4508                                  ;; TODO: D65 clusters are not calculated yet, but hardcoded below
  4509                                  ;;
  4510  9d1d a900                       lda #$00
  4511  9d1f 8536                       sta <d81_clustercount
  4512  9d21 8537                       sta <d81_clustercount+1
  4513  9d23 a940                       lda #<1600
  4514  9d25 8530                       sta <d81_clustersneeded
  4515  9d27 a906                       lda #>1600
  4516  9d29 8531                       sta <d81_clustersneeded+1
  4517                                  ;; 1541 - rounded up to 512b sectors 344*512 = 176128, D64 = 174848
  4518  9d2b a958                       lda #<344
  4519  9d2d 8532                       sta <d64_clustersneeded
  4520  9d2f a901                       lda #>344
  4521  9d31 8533                       sta <d64_clustersneeded+1
  4522                                  ;; 1571 - rounded up to 512b sectors 688*512 = 352256, D71 = 349696
  4523  9d33 a9b0                       lda #<688
  4524  9d35 8534                       sta <d71_clustersneeded
  4525  9d37 a902                       lda #>688
  4526  9d39 8535                       sta <d71_clustersneeded+1
  4527                          
  4528                                  ;; get sectors per cluster of disk
  4529                                  ;;
  4530  9d3b ae04bc                     ldx dos_disk_table_offset
  4531  9d3e bd16bb                     lda dos_disk_table+fs_fat32_sectors_per_cluster,x
  4532  9d41 4b                         taz
  4533                          
  4534  9d42 6b                 l94:    tza
  4535  9d43 2901                       and #$01
  4536  9d45 d012                       bne d81firstcluster
  4537  9d47 6b                         tza
  4538  9d48 4a                         lsr
  4539  9d49 4b                         taz
  4540  9d4a 4631                       lsr <d81_clustersneeded+1
  4541  9d4c 6630                       ror <d81_clustersneeded
  4542  9d4e 4633                       lsr <d64_clustersneeded+1
  4543  9d50 6632                       ror <d64_clustersneeded
  4544  9d52 4635                       lsr <d71_clustersneeded+1
  4545  9d54 6634                       ror <d71_clustersneeded
  4546  9d56 4c429d                     jmp l94
  4547                          
  4548                          d81firstcluster:
  4549                                  ;; Get current cluster of D81 file, so that
  4550                                  ;; we can check that clusters in file are contiguous
  4551                                  ;;
  4552  9d59 aefabc                     ldx dos_current_file_descriptor_offset
  4553  9d5c a000                       ldy #0
  4554                          
  4555  9d5e bdbfbc             l94b:   lda dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
  4556  9d61 992cbf                     sta d81_clusternumber,y
  4557  9d64 e8                         inx
  4558  9d65 c8                         iny
  4559  9d66 c004                       cpy #4
  4560  9d68 d0f4                       bne l94b
  4561                          
  4562                          d81nextcluster:
  4563                                  ;; Now read through clusters and make sure that all is
  4564                                  ;; well.
  4565                          
  4566                                  ;; check that it matches expected cluster number
  4567                                  ;;
  4568  9d6a aefabc                     ldx dos_current_file_descriptor_offset
  4569  9d6d a000                       ldy #0
  4570                          
  4571  9d6f bdbfbc             l94a:   lda dos_file_descriptors+dos_filedescriptor_offset_currentcluster,x
  4572  9d72 d92cbf                     cmp d81_clusternumber,y
  4573  9d75 f003                       beq not_a_frag
  4574  9d77 4c059e                     jmp d81isfragged
  4575                          not_a_frag:
  4576  9d7a e8                         inx
  4577  9d7b c8                         iny
  4578  9d7c c004                       cpy #4
  4579  9d7e d0ef                       bne l94a
  4580                          
  4581                                  ;; increment number of clusters found so far
  4582                                  ;;
  4583  9d80 e636                       inc <d81_clustercount
  4584  9d82 d004                       bne l96
  4585  9d84 e637                       inc <d81_clustercount+1
  4586  9d86 f078                       beq d81wronglength      ;; overflow means wrong length
  4587                          l96:
  4588                          
  4589                                  ;; increment expected cluster number
  4590                                  ;;
  4591  9d88 18                         clc
  4592  9d89 a52c                       lda <d81_clusternumber
  4593  9d8b 6901                       adc #$01
  4594  9d8d 852c                       sta <d81_clusternumber
  4595  9d8f a52d                       lda <d81_clusternumber+1
  4596  9d91 6900                       adc #$00
  4597  9d93 852d                       sta <d81_clusternumber+1
  4598  9d95 a52e                       lda <d81_clusternumber+2
  4599  9d97 6900                       adc #$00
  4600  9d99 852e                       sta <d81_clusternumber+2
  4601  9d9b a52f                       lda <d81_clusternumber+3
  4602  9d9d 6900                       adc #$00
  4603  9d9f 852f                       sta <d81_clusternumber+3
  4604                          
  4605  9da1 202e98                     jsr dos_file_advance_to_next_cluster
  4606  9da4 b0c4                       bcs d81nextcluster
  4607                          
  4608                                  +Checkpoint "dos_checkimage <measured end of image>"
  4609                          
  4610  9da6 20f093                     jsr dos_closefile
  4611                          
  4612                                  ;; we have read to end of D81 file, and it is contiguous
  4613                                  ;; now check that it is the right length
  4614                          
  4615                                  ;; It might also be a D64 (1541) or D71 (1571) disk image,
  4616                                  ;; so check for 683x256/4096 = 42.6875 = 43 clusters or
  4617                                  ;; double that for D71
  4618  9da9 a537                       lda <d81_clustercount+1
  4619  9dab c533                       cmp <d64_clustersneeded+1
  4620  9dad d00c                       bne not_1541
  4621  9daf a536                       lda <d81_clustercount
  4622  9db1 c532                       cmp <d64_clustersneeded
  4623  9db3 d004                       bne not_1541_2
  4624                          
  4625                                  ;;  IS a d64 sized file
  4626  9db5 a940                       lda #64
  4627  9db7 802e                       bra d81_is_good
  4628                          
  4629                          not_1541_2:
  4630  9db9 a537                       lda <d81_clustercount+1
  4631                          not_1541:
  4632  9dbb c535                       cmp <d71_clustersneeded+1
  4633  9dbd d00c                       bne not_1571
  4634  9dbf a536                       lda <d81_clustercount
  4635  9dc1 c534                       cmp <d71_clustersneeded
  4636  9dc3 d004                       bne not_1571_2
  4637                          
  4638                                  ;; IS a d71 sized file
  4639  9dc5 a947                       lda #71
  4640  9dc7 801e                       bra d81_is_good
  4641                          
  4642                          not_1571_2:
  4643  9dc9 a537                       lda <d81_clustercount+1
  4644                          not_1571:
  4645                                  ;; First check if we read enough for 85 tracks x 64 sectors x 2 sides = 5,570,560 bytes
  4646                                  ;; = 1,360 clusters = $0550 clusters
  4647                                  ;; XXX - This currently assumes 8 sectors per cluster = 4KB sectors
  4648  9dcb c905                       cmp #$05
  4649  9dcd d00c                       bne not_mega_floppy
  4650  9dcf a536                       lda <d81_clustercount
  4651  9dd1 c950                       cmp #$50
  4652  9dd3 d004                       bne not_mega_floppy_2
  4653                          
  4654  9dd5 a941                       lda #65
  4655  9dd7 800e                       bra d81_is_good
  4656                          
  4657                          not_mega_floppy_2:
  4658  9dd9 a531                       lda <d81_clustersneeded+1
  4659                          not_mega_floppy:
  4660                                  ;; D81 image?
  4661  9ddb c537                       cmp <d81_clustercount+1
  4662  9ddd d021                       bne d81wronglength
  4663  9ddf a530                       lda <d81_clustersneeded
  4664  9de1 c536                       cmp <d81_clustercount
  4665  9de3 d01b                       bne d81wronglength
  4666                          
  4667  9de5 a951                       lda #81
  4668                          
  4669                          d81_is_good:
  4670                                  ;; disk image size is good. save type on stack for later
  4671  9de7 852b                       sta <disk_lasttype
  4672                          
  4673                                  ;; Get cluster number again, convert to sector, and copy to
  4674                                  ;; SD controller FDC emulation disk image offset registers
  4675                                  ;;
  4676  9de9 aefabc                     ldx dos_current_file_descriptor_offset
  4677  9dec a000                       ldy #0
  4678                          
  4679  9dee bdbbbc             l94c:   lda dos_file_descriptors+dos_filedescriptor_offset_startcluster,x
  4680  9df1 99b4bc                     sta dos_current_cluster,y
  4681  9df4 e8                         inx
  4682  9df5 c8                         iny
  4683  9df6 c004                       cpy #4
  4684  9df8 d0f4                       bne l94c
  4685                          
  4686  9dfa 205d93                     jsr dos_cluster_to_sector
  4687                          
  4688  9dfd 4c1693                     jmp dos_return_success
  4689                          
  4690                          ;;         ========================
  4691                          
  4692                          d81wronglength:
  4693                                  +Checkpoint "dos_attach <wrong length>"
  4694                          
  4695  9e00 a98a                       lda #dos_errorcode_image_wrong_length
  4696  9e02 4c1d93                     jmp dos_return_error
  4697                          
  4698                          ;;         ========================
  4699                          
  4700                          d81isfragged:
  4701                                  +Checkpoint "dos_attach <fragmented>"
  4702                          
  4703                                  ;; close dangeling open descriptor
  4704  9e05 20f093                     jsr dos_closefile
  4705                          
  4706  9e08 a98b                       lda #dos_errorcode_image_fragmented
  4707  9e0a 4c1d93                     jmp dos_return_error
  4708                          
  4709                          ;;         ========================
  4710                          
  4711                          sdsector_add_uint8:
  4712                          
  4713  9e0d 48                         pha
  4714  9e0e a900                       lda #0
  4715  9e10 aa                         tax
  4716  9e11 a8                         tay
  4717  9e12 4b                         taz
  4718  9e13 68                         pla
  4719                                  ;; FALL THROUGH to sdsector_add_uint32
  4720                          
  4721                          sdsector_add_uint32:
  4722                          
  4723                                  ;; Add the 32-bit value contained in A,X,Y,Z to
  4724                                  ;; $D681-$D684, the SD card sector number.
  4725                                  ;;
  4726  9e14 18                         clc
  4727  9e15 6d81d6                     adc $D681
  4728  9e18 8d81d6                     sta $D681
  4729  9e1b 8a                         txa
  4730  9e1c 6d82d6                     adc $d682
  4731  9e1f 8d82d6                     sta $d682
  4732  9e22 98                         tya
  4733  9e23 6d83d6                     adc $d683
  4734  9e26 8d83d6                     sta $d683
  4735  9e29 6b                         tza
  4736  9e2a 6d84d6                     adc $d684
  4737  9e2d 8d84d6                     sta $d684
  4738  9e30 a300                       ldz #$00
  4739  9e32 60                         rts
  4740                          
  4741                          ;;         ========================
  4742                          
  4743                          sdsector_add_uint32_from_disktable:
  4744                          
  4745  9e33 0d04bc                     ora dos_disk_table_offset
  4746  9e36 a8                         tay
  4747  9e37 a200                       ldx #$00
  4748  9e39 18                         clc
  4749  9e3a 08                         php
  4750  9e3b 28                 l23:    plp
  4751  9e3c bd81d6                     lda $D681,x
  4752  9e3f 7900bb                     adc dos_disk_table,y
  4753  9e42 9d81d6                     sta $D681,x
  4754  9e45 08                         php
  4755  9e46 c8                         iny
  4756  9e47 e8                         inx
  4757  9e48 e004                       cpx #$04
  4758  9e4a d0ef                       bne l23
  4759  9e4c 28                         plp
  4760  9e4d 60                         rts
  4761                          
  4762                          ;;         ========================
  4763                          
  4764                          makeprintable:
  4765                                  ;; Convert unprintable ASCII characters to question marks
  4766                          
  4767  9e4e c920                       cmp #$20
  4768  9e50 9005                       bcc unprintable
  4769  9e52 c97f                       cmp #$7f
  4770  9e54 b001                       bcs unprintable
  4771  9e56 60                         rts
  4772                          
  4773                          unprintable:
  4774  9e57 a93f                       lda #$3f
  4775  9e59 60                         rts
  4776                          
  4777                          ;;         ========================

; ******** Source: src/hyppo/main.asm
   388                          ;!src "dos_write.asm"   ; LV - commented out because doesn't seem to be used
   389                          
   390                          ;; /*  -------------------------------------------------------------------
   391                          ;;     Virtual memory and memory management
   392                          ;;     ---------------------------------------------------------------- */

; ******** Source: mem.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          ;; Display error and infinite loop on page fault
     7                          page_fault:
     8  9e5a 20a4a4                     jsr reset_machine_state
     9  9e5d a28a                       ldx #<msg_pagefault
    10  9e5f a09e                       ldy #>msg_pagefault
    11  9e61 20bcaa                     jsr printmessage
    12  9e64 a000                       ldy #$00
    13                                  ;; Print PC
    14  9e66 ab49d6                     ldz $d649
    15  9e69 2035ab                     jsr printhex
    16  9e6c ab48d6                     ldz $d648
    17  9e6f 2035ab                     jsr printhex
    18                                  ;; and MAPLO state
    19  9e72 ab4fd6                     ldz $d64f
    20  9e75 2035ab                     jsr printhex
    21  9e78 ab4ad6                     ldz $d64a
    22  9e7b 2035ab                     jsr printhex
    23  9e7e ab49d6                     ldz $d649
    24  9e81 2035ab                     jsr printhex
    25                          
    26  9e84 ee20d0             pf1:    inc $d020
    27  9e87 4c849e                     jmp pf1
    28                          
    29                          msg_pagefault:
    30  9e8a 5041474520464155...        !text "PAGE FAULT: PC=$$$$, MAP=$$.$$$$.00     "
    31                          
    32                          memory_trap:
    33  9eb2 78                         sei
    34  9eb3 d8                         cld
    35  9eb4 29fe                       and #$fe
    36  9eb6 aa                         tax
    37  9eb7 7cba9e                     jmp (memory_trap_table,x)
    38                          
    39                          memory_trap_table:
    40                                  ;; $00-$0E
    41  9eba 429f                       !16 rom_writeprotect
    42  9ebc 3a9f                       !16 rom_writeenable
    43  9ebe 3582                       !16 invalid_subfunction
    44  9ec0 3582                       !16 invalid_subfunction
    45  9ec2 3582                       !16 invalid_subfunction
    46  9ec4 3582                       !16 invalid_subfunction
    47  9ec6 3582                       !16 invalid_subfunction
    48  9ec8 3582                       !16 invalid_subfunction
    49                          
    50                                  ;; $10-$1E
    51  9eca 3582                       !16 invalid_subfunction
    52  9ecc 3582                       !16 invalid_subfunction
    53  9ece 3582                       !16 invalid_subfunction
    54  9ed0 3582                       !16 invalid_subfunction
    55  9ed2 3582                       !16 invalid_subfunction
    56  9ed4 3582                       !16 invalid_subfunction
    57  9ed6 3582                       !16 invalid_subfunction
    58  9ed8 3582                       !16 invalid_subfunction
    59                          
    60                                  ;; $20-$2E
    61  9eda 3582                       !16 invalid_subfunction
    62  9edc 3582                       !16 invalid_subfunction
    63  9ede 3582                       !16 invalid_subfunction
    64  9ee0 3582                       !16 invalid_subfunction
    65  9ee2 3582                       !16 invalid_subfunction
    66  9ee4 3582                       !16 invalid_subfunction
    67  9ee6 3582                       !16 invalid_subfunction
    68  9ee8 3582                       !16 invalid_subfunction
    69                          
    70                                  ;; $30-$3E
    71  9eea 3582                       !16 invalid_subfunction
    72  9eec 3582                       !16 invalid_subfunction
    73  9eee 3582                       !16 invalid_subfunction
    74  9ef0 3582                       !16 invalid_subfunction
    75  9ef2 3582                       !16 invalid_subfunction
    76  9ef4 3582                       !16 invalid_subfunction
    77  9ef6 3582                       !16 invalid_subfunction
    78  9ef8 3582                       !16 invalid_subfunction
    79                          
    80                                  ;; $40-$4E
    81  9efa 3582                       !16 invalid_subfunction
    82  9efc 3582                       !16 invalid_subfunction
    83  9efe 3582                       !16 invalid_subfunction
    84  9f00 3582                       !16 invalid_subfunction
    85  9f02 3582                       !16 invalid_subfunction
    86  9f04 3582                       !16 invalid_subfunction
    87  9f06 3582                       !16 invalid_subfunction
    88  9f08 3582                       !16 invalid_subfunction
    89                          
    90                                  ;; $50-$5E
    91  9f0a 3582                       !16 invalid_subfunction
    92  9f0c 3582                       !16 invalid_subfunction
    93  9f0e 3582                       !16 invalid_subfunction
    94  9f10 3582                       !16 invalid_subfunction
    95  9f12 3582                       !16 invalid_subfunction
    96  9f14 3582                       !16 invalid_subfunction
    97  9f16 3582                       !16 invalid_subfunction
    98  9f18 3582                       !16 invalid_subfunction
    99                          
   100                                  ;; $60-$6E
   101  9f1a 3582                       !16 invalid_subfunction
   102  9f1c 3582                       !16 invalid_subfunction
   103  9f1e 3582                       !16 invalid_subfunction
   104  9f20 3582                       !16 invalid_subfunction
   105  9f22 3582                       !16 invalid_subfunction
   106  9f24 3582                       !16 invalid_subfunction
   107  9f26 3582                       !16 invalid_subfunction
   108  9f28 3582                       !16 invalid_subfunction
   109                          
   110                                  ;; $70-$7E
   111  9f2a 3582                       !16 invalid_subfunction
   112  9f2c 3582                       !16 invalid_subfunction
   113  9f2e 3582                       !16 invalid_subfunction
   114  9f30 3582                       !16 invalid_subfunction
   115  9f32 3582                       !16 invalid_subfunction
   116  9f34 3582                       !16 invalid_subfunction
   117  9f36 3582                       !16 invalid_subfunction
   118  9f38 3582                       !16 invalid_subfunction
   119                          
   120                          rom_writeenable:
   121  9f3a a904                       lda #$04
   122  9f3c 1c7dd6                     trb hypervisor_feature_enables
   123  9f3f 4c1682                     jmp return_from_trap_with_success
   124                          
   125                          rom_writeprotect:
   126  9f42 a904                       lda #$04
   127  9f44 0c7dd6                     tsb hypervisor_feature_enables
   128  9f47 4c1682                     jmp return_from_trap_with_success
   129                          

; ******** Source: src/hyppo/main.asm
   394                          
   395                          ;; /*  -------------------------------------------------------------------
   396                          ;;     Task (process) management
   397                          ;;     ---------------------------------------------------------------- */

; ******** Source: task.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                  ;; Return the next free task ID
     7                                  ;; XXX - Task ID $FF is hypervisor/operating system
     8                                  ;; XXX - For now just lie, and always say task $00 is next.
     9                                  ;; We should have a process allocation table that we consult.
    10                                  ;; (actual suspended processes should be held on SD card in files)
    11                          
    12                          task_get_next_taskid:
    13                          
    14  9f4a a900                       lda #$00
    15  9f4c 60                         rts
    16                          
    17                          ;;         ========================
    18                          
    19                          task_set_c64_memorymap:
    20                          
    21                                  ;; set contents of CPU registers for exit from hypervisor mode
    22                          
    23  9f4d a900                       lda #$00
    24  9f4f 8d40d6                     sta hypervisor_a
    25  9f52 8d41d6                     sta hypervisor_x
    26  9f55 8d42d6                     sta hypervisor_y
    27  9f58 8d43d6                     sta hypervisor_z
    28  9f5b 8d44d6                     sta hypervisor_b
    29  9f5e a9ff                       lda #$ff
    30  9f60 8d45d6                     sta hypervisor_spl
    31  9f63 a901                       lda #$01
    32  9f65 8d46d6                     sta hypervisor_sph
    33  9f68 a9f7                       lda #$f7     ;; All flags except decimal mode
    34  9f6a 8d47d6                     sta hypervisor_flags
    35  9f6d a900                       lda #$00
    36  9f6f 8d4bd6                     sta hypervisor_maplolo
    37  9f72 8d4ad6                     sta hypervisor_maplohi
    38  9f75 8d4dd6                     sta hypervisor_maphilo
    39  9f78 8d4cd6                     sta hypervisor_maphihi
    40  9f7b 8d4ed6                     sta hypervisor_maplomb
    41  9f7e 8d4fd6                     sta hypervisor_maphimb
    42  9f81 a93f                       lda #$3f
    43  9f83 8d50d6                     sta hypervisor_cpuport00
    44  9f86 8d51d6                     sta hypervisor_cpuport01
    45                          
    46  9f89 a900                       lda #$00
    47  9f8b 8d52d6                     sta hypervisor_iomode    ;; C64 IO map
    48                          
    49                                  ;; Unmap SD sector buffer
    50  9f8e a982                       lda #$82
    51  9f90 8d80d6                     sta $D680
    52                          
    53                                  ;; Unmap 2nd KB colour RAM
    54  9f93 a901                       lda #$01
    55  9f95 1c30d0                     trb $d030
    56                          
    57                                  ;; Clear 16-bit text mode, but keep CRT emulation and horizontal filter settings
    58  9f98 a9d7                       lda #$d7
    59  9f9a 1c54d0                     trb $d054
    60                          
    61                                  ;; 40 column mode normal C64 screen
    62  9f9d a900                       lda #$00
    63  9f9f 8d30d0                     sta $d030
    64  9fa2 8d31d0                     sta $d031
    65  9fa5 ad00dd                     lda $dd00
    66  9fa8 0903                       ora #$03
    67  9faa 8d00dd                     sta $dd00
    68  9fad a9c0                       lda #$c0    ;; also enable raster delay to match rendering with interrupts more correctly
    69  9faf 8d5dd0                     sta $d05d
    70  9fb2 a91b                       lda #$1b
    71  9fb4 8d11d0                     sta $d011
    72  9fb7 a9c8                       lda #$c8
    73  9fb9 8d16d0                     sta $d016
    74  9fbc a914                       lda #$14
    75  9fbe 8d18d0                     sta $d018
    76                          
    77                                  ;; XXX - disable C65 ROM maps
    78  9fc1 60                         rts
    79                          
    80                          ;;         ========================
    81                          
    82                          task_set_pc_to_reset_vector:
    83                          
    84                                  ;; Set PC from $FFFC in ROM, i.e., $802FFFC
    85  9fc2 a2fc                       ldx #<reset_vector
    86  9fc4 a0ff                       ldy #>reset_vector
    87  9fc6 a302                       ldz #$02
    88  9fc8 a900                       lda #$00
    89  9fca 203eac                     jsr longpeek
    90  9fcd ad00bc                     lda hyppo_scratchbyte0
    91  9fd0 8d48d6                     sta hypervisor_pcl
    92  9fd3 a2fc                       ldx #<reset_vector
    93  9fd5 e8                         inx
    94  9fd6 a0ff                       ldy #>reset_vector
    95  9fd8 a302                       ldz #$02
    96  9fda a900                       lda #$00
    97  9fdc 203eac                     jsr longpeek
    98  9fdf ad00bc                     lda hyppo_scratchbyte0
    99  9fe2 8d49d6                     sta hypervisor_pch
   100                          
   101  9fe5 60                         rts
   102                          
   103                          ;;         ========================
   104                          
   105                                  ;; Set dummy C64 NMI vector
   106                                  ;; This avoid a nasty crash if NMI is called during hyppo
   107                                  ;; Points to a RTI instruction in $FEC1
   108                          
   109                          task_dummy_nmi_vector:
   110                          
   111  9fe6 a9c1                       lda #<$FEC1
   112  9fe8 8d1803                     sta $0318
   113  9feb a9fe                       lda #>$FEC1
   114  9fed 8d1903                     sta $0319
   115  9ff0 60                         rts
   116                          
   117                          ;;         ========================
   118                          
   119                                  ;; Set all page entries and current page number to all zeroes
   120                                  ;; so that we don't think any page is loaded.
   121                                  ;; XXX - Is all zeroes the best value here?  Physical page 0 is $00000000, which
   122                                  ;; is in chipram. It might be legitimate to try to map that.  Perhaps we should set
   123                                  ;; the pages to $FFFF instead (but that would reduce available VM space by 16KB).
   124                                  ;; Physical page 0 is probably reasonable for now. We can revisit as required.
   125                          
   126                          task_clear_pagetable:
   127                          
   128  9ff1 a900                       lda #$00
   129  9ff3 a25d                       ldx #<hypervisor_vm_currentpage_lo
   130  9ff5 9d00d6             tcp1:   sta $d600,x
   131  9ff8 e8                         inx
   132  9ff9 e070                       cpx #<hypervisor_vm_pagetable3_physicalpage_hi+1
   133  9ffb d0f8                       bne tcp1
   134  9ffd 60                         rts
   135                          
   136                          ;;         ========================
   137                          
   138                          task_erase_processcontrolblock:
   139                          
   140                                  ;; Erase process control block
   141                                  ;;
   142  9ffe a200                       ldx #$00
   143  a000 8a                         txa
   144  a001 9d00bd             tabs1:        sta currenttask_block,x
   145  a004 e8                         inx
   146  a005 d0fa                       bne tabs1
   147  a007 20f19f                     jsr task_clear_pagetable
   148                          
   149                                  ;; Mark all files as closed
   150                          
   151  a00a 4c7190                     jmp dos_clear_filedescriptors
   152                          
   153                          ;;         ========================
   154                          
   155                          task_new_processcontrolblock:
   156                          
   157  a00d 20fe9f                     jsr task_erase_processcontrolblock
   158  a010 204a9f                     jsr task_get_next_taskid
   159  a013 8d00bd                     sta currenttask_id
   160  a016 60                         rts
   161                          
   162                          ;;         ========================
   163                          
   164                                  ;; Initialise memory to indicate a new blank task.
   165                                  ;; (actually, it will be a task preconfigured for C64/C65 mode)
   166                          
   167                          task_asblankslate:
   168                          
   169  a017 200da0                     jsr task_new_processcontrolblock
   170                          
   171  a01a 204d9f                     jsr task_set_c64_memorymap
   172  a01d 60                         rts
   173                          
   174                          task_set_as_system_task:
   175                                  ;; Task ID is reserved for the hypervisor and its helpers, and prevents freezing
   176  a01e a9ff                       lda #$ff
   177  a020 8d00bd                     sta currenttask_id
   178  a023 60                         rts
   179                          
   180                          ;;         ========================
   181                          
   182                          ethernet_remote_trap:
   183                                  ;; By sending a magic ethernet key press frame while the 2nd dip switch is set
   184                                  ;; will cause this trap to occur, if the key code is 1111111111111 (which
   185                                  ;; corresponds to no real key.
   186                                  ;; In response to this, we setup C64 mode, load ETHLOAD.M65 and then exit to it,
   187                                  ;; effectively passing control to the contents of the following ethernet frames.
   188  a024 207190                     jsr dos_clear_filedescriptors
   189  a027 204a9f                     jsr task_get_next_taskid
   190  a02a 8d00bd                     sta currenttask_id
   191  a02d 204d9f                     jsr task_set_c64_memorymap
   192                          
   193  a030 a20f                       ldx #<txt_ETHLOAD
   194  a032 a0b4                       ldy #>txt_ETHLOAD
   195  a034 20d59b                     jsr dos_setname
   196                          
   197                                  ;; bring directory back to root, just in-case user loaded a .d81 from another directory
   198  a037 ae02bc                     ldx dos_default_disk
   199  a03a 203c93                     jsr dos_cdroot
   200                          
   201                                  ;; Prepare 32-bit pointer for loading etherload at $FF87E00,
   202                                  ;; This location is the last 512 bytes of the 32KB colour RAM we
   203                                  ;; can assume all models possess, and should result in the code not
   204                                  ;; getting in the way of loading programs of almost any size.
   205                                  ;;
   206  a03d a900                       lda #$00
   207  a03f 8518                       sta <dos_file_loadaddress+0
   208  a041 a97e                       lda #$7e
   209  a043 8519                       sta <dos_file_loadaddress+1
   210  a045 a9f8                       lda #$f8
   211  a047 851a                       sta <dos_file_loadaddress+2
   212  a049 a90f                       lda #$0f
   213  a04b 851b                       sta <dos_file_loadaddress+3
   214                          
   215                          @tryAgain:
   216  a04d 205099                     jsr dos_readfileintomemory
   217  a050 ee20d0                     inc $d020
   218  a053 90f8                       bcc @tryAgain
   219  a055 ce20d0                     dec $d020
   220                          
   221  a058 204d9f                     jsr task_set_c64_memorymap
   222  a05b 20e69f                     jsr task_dummy_nmi_vector
   223                          
   224                                  ;; Now enable MAP of colour RAM at $8000-$9FFF
   225                                  ;; $FF87E00 - $8000 = $FF7FE00
   226  a05e a9ff                       lda #$ff
   227  a060 8d4fd6                     sta hypervisor_maphimb
   228  a063 3a                         dec
   229  a064 8d4dd6                     sta hypervisor_maphilo
   230  a067 a917                       lda #$17
   231  a069 8d4cd6                     sta hypervisor_maphihi
   232                          
   233                          
   234                                  ;; set entry point to $8000, i.e, the start
   235                                  ;; of the 8KB block of colour RAM we map at $8000-$9fff
   236  a06c a900                       lda #<$8000
   237  a06e 8d48d6                     sta hypervisor_pcl
   238  a071 a980                       lda #>$8000
   239  a073 8d49d6                     sta hypervisor_pch
   240                          
   241  a076 4cd1a0                     jmp safe_exit_to_loaded_program
   242                          
   243                          unstable_illegal_opcode_trap:
   244                          kill_opcode_trap:
   245                                  ;; For now, just launch the freezer if an illegal opcode is hit that
   246                                  ;; we can't work with.
   247                                  ;; (Ideally later we will allow some clever tricks with at least the KIL
   248                                  ;; opcodes, e.g., to call the hypervisor from C64 mode)
   249                          
   250                                  ;; FALL THROUGH
   251                          
   252                          restore_press_trap:
   253                          
   254                                  ;; Check if we are already in the freezer?
   255  a079 ad00bd                     lda currenttask_id
   256  a07c c9ff                       cmp #$ff
   257  a07e d003                       bne non_hypervisor_task
   258                          
   259                                  ;; Don't allow freezing if we are in a hypervisor task
   260  a080 8d7fd6                     sta hypervisor_enterexit_trigger
   261                          
   262                          non_hypervisor_task:
   263                          
   264                                  ;; Clear colour RAM at $DC00 flag, as it causes no end of trouble
   265  a083 a901                       lda #$01
   266  a085 1c30d0                     trb $D030
   267                                  ;; and DMA audio
   268  a088 a900                       lda #$00
   269  a08a 8d11d7                     sta $d711
   270                          
   271                                  ;; Freeze to slot 0
   272  a08d aa                         tax ;;   <- uses $00 in A from above
   273  a08e a8                         tay ;;   <- uses $00 in A from above
   274  a08f 209086                     jsr freeze_to_slot
   275                          
   276                                  ;; Now mark that we are in a system task, so that the freezer can't be frozen
   277  a092 201ea0                     jsr task_set_as_system_task
   278                          
   279                                  ;; Load freeze program
   280  a095 2030a8                     jsr attempt_loadcharrom
   281  a098 204aa8                     jsr attempt_loadc65rom
   282                          
   283  a09b a203                       ldx #<txt_FREEZER
   284  a09d a0b4                       ldy #>txt_FREEZER
   285  a09f 20d59b                     jsr dos_setname
   286                          
   287                                  ;; TODO: preserve current directory, so that we can restore it later
   288                          
   289                                  ;; bring directory back to root, just in-case user loaded a .d81 from another directory
   290  a0a2 ae02bc                     ldx dos_default_disk
   291  a0a5 203c93                     jsr dos_cdroot
   292                          
   293                                  ;; Prepare 32-bit pointer for loading freezer program ($000007FF)
   294                                  ;; (i.e. $0801 - 2 byte header, so we can use a normal PRG file)
   295                                  ;;
   296  a0a8 a900                       lda #$00
   297  a0aa 851a                       sta <dos_file_loadaddress+2
   298  a0ac 851b                       sta <dos_file_loadaddress+3
   299  a0ae a907                       lda #$07
   300  a0b0 8519                       sta <dos_file_loadaddress+1
   301  a0b2 a9ff                       lda #$ff
   302  a0b4 8518                       sta <dos_file_loadaddress+0
   303                          
   304                          @tryAgain:
   305  a0b6 205099                     jsr dos_readfileintomemory
   306  a0b9 ee20d0                     inc $d020
   307  a0bc 90f8                       bcc @tryAgain
   308  a0be ce20d0                     dec $d020
   309                          
   310  a0c1 204d9f                     jsr task_set_c64_memorymap
   311  a0c4 20e69f                     jsr task_dummy_nmi_vector
   312                          
   313                                  ;; set entry point and memory config
   314  a0c7 a90d                       lda #<2061
   315  a0c9 8d48d6                     sta hypervisor_pcl
   316  a0cc a908                       lda #>2061
   317  a0ce 8d49d6                     sta hypervisor_pch
   318                          
   319                          safe_exit_to_loaded_program:
   320                                  ;; Make $FFD2 vector at $0326 point to an RTS, so that if the freezer
   321                                  ;; is built using CC65's C64 profile, the call to $FFD2 to set lower-case mode
   322                                  ;; doesn't do something terrible.
   323  a0d1 a9ff                       lda #<$03FF
   324  a0d3 8d2603                     sta $0326
   325  a0d6 a903                       lda #>$03FF
   326  a0d8 8d2703                     sta $0327
   327  a0db a960                       lda #$60 ;; = RTS
   328  a0dd 8dff03                     sta $03FF
   329                          
   330                                  ;; Similarly neuter IRQ/BRK and NMI vectors, in part because the call to $FFD2 above
   331                                  ;; will do a CLI, and thus any pending IRQ will immediately trigger, and since the freezer
   332                                  ;; is running without the kernal initialising things, it would otherwise use the IRQ
   333                                  ;; vector from whatever was being frozen.  Clearly this is a bad thing.
   334  a0e0 a9fc                       lda #<$03FC
   335  a0e2 8d1403                     sta $0314
   336  a0e5 8d1603                     sta $0316
   337  a0e8 8d1803                     sta $0318
   338  a0eb a903                       lda #>$03FC
   339  a0ed 8d1503                     sta $0315
   340  a0f0 8d1703                     sta $0317
   341  a0f3 8d1903                     sta $0319
   342  a0f6 a94c                       lda #$4C   ;; JMP $EA81
   343  a0f8 8dfc03                     sta $03FC
   344  a0fb a981                       lda #<$EA81
   345  a0fd 8dfd03                     sta $03FD
   346  a100 a9ea                       lda #>$EA81
   347  a102 8dfe03                     sta $03FE
   348                          
   349                                  ;; Disable IRQ/NMI sources
   350  a105 a97f                       lda #$7f
   351  a107 8d0ddc                     sta $DC0D
   352  a10a 8d0ddd                     sta $DD0D
   353  a10d a900                       lda #$00
   354  a10f 8d1ad0                     sta $D01A
   355                          
   356                                  ;; return from hypervisor, causing freeze menu to start
   357                                  ;;
   358  a112 8d7fd6                     sta hypervisor_enterexit_trigger
   359                          
   360                          ;;         ========================
   361                          
   362                          protected_hardware_config:
   363                          
   364                                  ;; store config info passed from register a
   365  a115 ad40d6                     lda hypervisor_a
   366  a118 8d72d6                     sta hypervisor_secure_mode_flags
   367                          
   368                                  ;; bump border colour so that we know something has happened
   369                                  ;;
   370                          
   371  a11b 8d7fd6                     sta hypervisor_enterexit_trigger
   372                          
   373                          ;;         ========================
   374                          
   375                          matrix_mode_toggle:
   376                          
   377  a11e ad72d6                     lda hypervisor_secure_mode_flags
   378                                  ;; We want to toggle bit 6 only.
   379  a121 4940                       eor #$40
   380  a123 8d72d6                     sta hypervisor_secure_mode_flags
   381                          
   382  a126 8d7fd6                     sta hypervisor_enterexit_trigger

; ******** Source: src/hyppo/main.asm
   399                          
   400                          ;; /*  -------------------------------------------------------------------
   401                          ;;     Secure mode / compartmentalised operation management
   402                          ;;     ---------------------------------------------------------------- */

; ******** Source: securemode.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          securemode_trap:
     7                          
     8                                  ;; XXX - The following is what we SHOULD do for the complete system to work:
     9                                  ;; XXX Freeze current process to slot
    10                                  ;; XXX Find the requested service
    11                                  ;; XXX Load the requested service
    12                          
    13                                  ;; Set secure mode flag, and set PC and memory map in the secure service
    14                          
    15                                  ;; XXX - What we WILL do for now, is just enable secure mode, and set the PC to
    16                                  ;; $8000.
    17                          
    18                                  ;; First, disable access to cartridge, force 50MHz mode and 4502 CPU personality
    19  a129 a932                       lda #$32
    20  a12b 8d7dd6                     sta hypervisor_feature_enables
    21                          
    22                                  ;; Second, disable all protecteed IO access, and mark matrix mode and secure mode.
    23                                  ;; This also freezes the CPU until the monitor acknowledges that the CPU is in
    24                                  ;; secure mode.  Only after that will the remainder of this routine proceed,
    25                                  ;; and thus allow the secure program to run.
    26                                  ;; XXX - This means that a little piece of the hypervisor is still running when we
    27                                  ;; go into the secure compartment.  For this reason, the CPU needs to be blocked
    28                                  ;; from writing to hypervisor_secure_mode_flags when in that state.
    29  a12e a9c0                       lda #$c0
    30  a130 8d72d6                     sta hypervisor_secure_mode_flags
    31                          
    32                          
    33                                  ;; At this point, the monitor detects that we have asked for secure mode, and will
    34                                  ;; ask for the user to either accept or reject.  If they accept, the CPU will be
    35                                  ;; resumed into the loaded service.  If not, all memory will be erased, before the
    36                                  ;; CPU is resumed.  For now, a rejected action will just require a reboot. But
    37                                  ;; later, we will have the monitor tell the hypervisor by synthesising an appropriate
    38                                  ;; trap after wiping memory, presumbly by causing a write to a $D65x register.
    39  a133 4c0082                     jmp nosuchtrap
    40                          
    41                          
    42                          leave_securemode_trap:
    43                          
    44                                  ;; If we get here, we have left a secure compartment, with either memory erased
    45                                  ;; or intact.  Either way, we should hand control back to the user, and disable
    46                                  ;; matrix mode display.
    47                          
    48                                  ;; XXX - Debug
    49  a136 ee21d0                     inc $d021
    50                          
    51  a139 a900                       lda #$00
    52  a13b 8d72d6                     sta hypervisor_secure_mode_flags
    53                          
    54  a13e 4c0082                     jmp nosuchtrap

; ******** Source: src/hyppo/main.asm
   404                          
   405                          ;; /*  -------------------------------------------------------------------
   406                          ;;     SD-Card and FAT related functions
   407                          ;;     ---------------------------------------------------------------- */

; ******** Source: sdfat.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          
     5                          ;;     These routines provide support for FAT32 and SDCARD support.
     6                          ;;     ---------------------------------------------------------------- */
     7                          
     8                          ;; /*  -------------------------------------------------------------------
     9                          ;;     FAT file system routines
    10                          ;;     ---------------------------------------------------------------- */
    11                          toupper:
    12                                  ;; convert ASCII character to upper case
    13                                  ;;
    14                                  ;; INPUT:  .A is the ASCII char to convert up uppercase
    15                                  ;; OUTPUT: .A will hold the resulting uppersace
    16  a141 c961                       cmp #$61  ; #$60 = ` char (just before lower-case 'a')
    17  a143 9006                       bcc tu1   ; branch if < #$60
    18  a145 c97b                       cmp #$7b  ; #$7a = 'z' char
    19  a147 b002                       bcs tu1   ; branch if > #$7a
    20  a149 295f                       and #$5f  ; 's' = %01110011 & %01011111 = 'S' = %01010011
    21  a14b 60                 tu1:    rts
    22                          
    23                          ;; /*  -------------------------------------------------------------------
    24                          ;;     MBP / partition routines
    25                          
    26                          ;;     Read master boot record. Does not sanity check anything.
    27                          ;;     ---------------------------------------------------------------- */
    28                          readmbr:
    29                                  ;; begin by resetting SD card
    30                                  ;;
    31                          
    32                                  +Checkpoint "Resetting SDCARD"
    33                          
    34  a14c 20c4a1                     jsr sd_resetsequence
    35  a14f b001                       bcs l7
    36                                  +Checkpoint "FAILED resetting SDCARD"
    37                          
    38  a151 60                         rts
    39                          
    40                          l7:     ;; MBR is sector 0
    41                                  ;;
    42  a152 a900                       lda #$00
    43  a154 8d81d6                     sta sd_address_byte0 ;; is $D681
    44  a157 8d82d6                     sta sd_address_byte1 ;; is $d682
    45  a15a 8d83d6                     sta sd_address_byte2 ;; is $d683
    46  a15d 8d84d6                     sta sd_address_byte3 ;; is $d684
    47                          
    48                                  ;; Work out if SD card or SDHC card
    49                                  ;; SD cards only read on 512 byte aligned addresses.
    50                                  ;; SDHC addresses by sector, so all addresses are valid
    51                          
    52                                  ;; Clear SDHC flag to begin with (flag persists through reset)
    53  a160 a940                       lda #$40
    54  a162 8d80d6                     sta $d680
    55                          
    56                                  ;; Attempt non-aligned read
    57  a165 a902                       lda #$02
    58  a167 8d81d6                     sta sd_address_byte0
    59  a16a 8d80d6                     sta $d680
    60                          
    61                          sdhccheckwait:
    62  a16d 20fca1                     jsr sdreadytest
    63  a170 b017                       bcs issdhc
    64  a172 d0f9                       bne sdhccheckwait
    65                          
    66                                  ;; Normal SD (SDSC) card
    67                          
    68  a174 a900                       lda #$00
    69  a176 8d81d6                     sta sd_address_byte0
    70                          
    71                                  ;; Reset after SDHC test for normal SD mode
    72  a179 20c4a1                     jsr sd_resetsequence
    73                          
    74                                  ;; XXX - We no longer support standard SD cards, so
    75                                  ;; we display an error and infinite loop.
    76                          
    77  a17c a2e7                       ldx #<msg_foundsdcard
    78  a17e a0b0                       ldy #>msg_foundsdcard
    79  a180 20bcaa                     jsr printmessage
    80                          
    81                          @unsupportedcard:
    82  a183 ee20d0                     inc $D020
    83  a186 4c83a1                     jmp @unsupportedcard
    84                          
    85                          issdhc:
    86  a189 a20a                       ldx #<msg_foundsdhccard
    87  a18b a0b1                       ldy #>msg_foundsdhccard
    88  a18d 20bcaa                     jsr printmessage
    89                          
    90                                  ;; set SDHC flag
    91  a190 a941                       lda #$41
    92  a192 8d80d6                     sta $d680
    93                          
    94  a195 4c2da2                     jmp sd_readsector
    95                          
    96                          ;; /*  -------------------------------------------------------------------
    97                          ;;     SD Card access routines
    98                          ;;     ---------------------------------------------------------------- */
    99                          
   100                          sd_open_write_gate:
   101  a198 a957                       lda #$57
   102  a19a 8d80d6                     sta $d680
   103  a19d 60                         rts
   104                          
   105                          write_non_mbr_sector:
   106  a19e 2098a1                     jsr sd_open_write_gate
   107  a1a1 4ca9a1                     jmp write_sector_trigger
   108                          write_mbr_sector:
   109  a1a4 a94d                       lda #$4D
   110  a1a6 8d80d6                     sta $d680
   111                          write_sector_trigger:
   112  a1a9 a903                       lda #$03
   113  a1ab 8d80d6                     sta $d680
   114  a1ae 60                         rts
   115                          
   116                          
   117                          sd_wait_for_ready:
   118  a1af 20eea1                     jsr sdtimeoutreset
   119  a1b2 20fca1             @loop:  jsr sdreadytest
   120  a1b5 90fb                       bcc @loop
   121  a1b7 60                         rts
   122                          
   123                          sd_wait_for_ready_reset_if_required:
   124                                  ;; Wait until the SD card is ready. If it doesn't get ready,
   125                                  ;; then continuously reset it until it does become ready.
   126  a1b8 20afa1                     jsr sd_wait_for_ready
   127  a1bb b006                       bcs @isReady
   128  a1bd 20c4a1                     jsr sd_resetsequence
   129  a1c0 4cb8a1                     jmp sd_wait_for_ready_reset_if_required
   130                          @isReady:
   131  a1c3 60                         rts
   132                          
   133                          sd_resetsequence:
   134                                  ;; write $00 to $D680 to start reset
   135                                  ;;
   136                          
   137                                  ;; Assert and release reset
   138  a1c4 a900                       lda #$00
   139  a1c6 8d80d6                     sta $D680
   140  a1c9 a901                       lda #$01
   141  a1cb 8d80d6                     sta $D680
   142                          
   143                                  ;; Wait for SD card to become ready
   144  a1ce 20afa1             re2:    jsr sd_wait_for_ready
   145  a1d1 b003                       bcs re2done        ;; success, so return
   146  a1d3 d0f9                       bne re2                ;; not timed out, so keep trying
   147  a1d5 60                         rts                ;; timeout, so return
   148                          
   149                          re2done:
   150  a1d6 2018a2                     jsr sd_map_sectorbuffer
   151                          
   152                          redone:
   153  a1d9 38                         sec
   154  a1da 60                         rts
   155                          
   156                          ;;         ========================
   157                          
   158                                  ;; Watch for ethernet packets while waiting for the SD card.
   159                                  ;; this allows loading of code into the hypervisor for testing and
   160                                  ;; bare-metal operation.
   161                                  ;;
   162                          sdwaitawhile:
   163  a1db 20eea1                     jsr sdtimeoutreset
   164                          
   165  a1de ee20bf             sw1:    inc sdcounter+0
   166  a1e1 d0fb                       bne sw1
   167  a1e3 ee21bf                     inc sdcounter+1
   168  a1e6 d0f6                       bne sw1
   169  a1e8 ee22bf                     inc sdcounter+2
   170  a1eb d0f1                       bne sw1
   171  a1ed 60                         rts
   172                          
   173                          ;;         ========================
   174                          
   175                          sdtimeoutreset:
   176                                  ;; count to timeout value when trying to read from SD card
   177                                  ;; (if it is too short, the SD card won't reset)
   178                                  ;;
   179  a1ee a900                       lda #$00
   180  a1f0 8d20bf                     sta sdcounter+0
   181  a1f3 8d21bf                     sta sdcounter+1
   182  a1f6 a9f3                       lda #$f3
   183  a1f8 8d22bf                     sta sdcounter+2
   184  a1fb 60                         rts
   185                          
   186                          ;;         ========================
   187                          
   188                          sdreadytest:
   189                                  ;; check if SD card is ready, or if timeout has occurred
   190                                  ;; C is set if ready.
   191                                  ;; Z is set if timeout has occurred.
   192                                  ;;
   193  a1fc ad80d6                     lda $d680
   194  a1ff 2903                       and #$03
   195  a201 f013                       beq sdisready
   196  a203 ee20bf                     inc sdcounter+0
   197  a206 d00c                       bne sr1
   198  a208 ee21bf                     inc sdcounter+1
   199  a20b d007                       bne sr1
   200  a20d ee22bf                     inc sdcounter+2
   201  a210 d002                       bne sr1
   202                          
   203                                  ;; timeout
   204                                  ;;
   205  a212 a900                       lda #$00 ;; set Z
   206                          
   207  a214 18                 sr1:    clc
   208  a215 60                         rts
   209                          
   210                          sdisready:
   211  a216 38                         sec
   212  a217 60                         rts
   213                          
   214                          ;;         ========================
   215                          
   216                          sd_map_sectorbuffer:
   217                          
   218                                  ;; BG this clobbers .A, maybe we should protect .A as the UNMAP-function does? (see below)
   219                          
   220                                  ;; Clear colour RAM at $DC00 flag, as this prevents mapping of sector buffer at $DE00
   221  a218 a901                       lda #$01
   222  a21a 1c30d0                     trb $D030
   223                          
   224                                  ;; Actually map the sector buffer
   225  a21d a981                       lda #$81
   226  a21f 8d80d6                     sta $D680
   227  a222 38                         sec
   228  a223 60                         rts
   229                          
   230                          ;;         ========================
   231                          
   232                          sd_unmap_sectorbuffer:
   233                          
   234  a224 48                         pha
   235  a225 a982                       lda #$82
   236  a227 8d80d6                     sta $D680
   237  a22a 68                         pla
   238  a22b 38                         sec
   239  a22c 60                         rts
   240                          
   241                          
   242                          ;;         ========================
   243                          
   244                          ;; /*  -------------------------------------------------------------------
   245                          ;;     Below functions are self-contained
   246                          ;;     ---------------------------------------------------------------- */
   247                          
   248                                  ;; Assumes fixed sector number (or byte address in case of SD cards) is loaded into $D681 - $D684
   249                          
   250                          sd_readsector:
   251  a22d 204da2                     jsr sd_rws_checkbusy
   252                          sd_readsector_retry:                               ;; ask for sector to be read
   253  a230 a902                       lda #$02
   254  a232 8d80d6                     sta $d680
   255  a235 2055a2                     jsr sd_rws_checksuccess
   256  a238 b003                       bcs +
   257  a23a 4c30a2                     jmp sd_readsector_retry
   258  a23d 60                 +       rts
   259                          
   260                          ;;      ========================
   261                          
   262                          sd_writesector:
   263                                  !if DEBUG_HYPPO {
   264                                      jsr printsectoraddress             ;; print out debug info to screen
   265                                      ;; jsr dumpsectoraddress                 ;; checkpoint message
   266                                  }
   267                          
   268  a23e 204da2                     jsr sd_rws_checkbusy
   269                          sd_writesector_retry:                              ;; ask for sector to be written
   270  a241 209ea1                     jsr write_non_mbr_sector
   271  a244 2055a2                     jsr sd_rws_checksuccess
   272  a247 b003                       bcs +
   273  a249 4c41a2                     jmp sd_writesector_retry
   274  a24c 60                 +       rts
   275                          
   276                          ;;      ========================
   277                          
   278                          sd_rws_checkbusy:
   279  a24d ad80d6                     lda $d680                                 ;; check if sd card is busy
   280  a250 2901                       and #$01
   281  a252 d014                       bne sd_rws_busyfail
   282  a254 60                         rts
   283                          
   284                          ;;      ========================
   285                          
   286                          sd_rws_checksuccess:
   287  a255 20eea1                     jsr sdtimeoutreset                        ;; wait for sector to be read/written
   288                          sd_rws_checksuccessloop:
   289  a258 20fca1                     jsr sdreadytest
   290  a25b b004                       bcs sd_rws_success                        ;; yes, sdcard is ready
   291  a25d d0f9                       bne sd_rws_checksuccessloop               ;; not ready, and Z=0, so still busy -> check if ready again
   292  a25f f002                       beq sd_rws_retry                          ;; not ready, and Z=1, so not busy any more -> timeout, so reread sector
   293                          sd_rws_success:
   294  a261 38                         sec
   295  a262 60                         rts
   296                          
   297                          ;;      ========================
   298                          
   299                          sd_rws_retry:
   300                                  +Checkpoint "ERROR rereadwritesector:"    ;; reset sd card and try again
   301  a263 20c4a1                     jsr sd_resetsequence
   302  a266 18                         clc
   303  a267 60                         rts
   304                          
   305                          sd_rws_busyfail:
   306  a268 a907                       lda #dos_errorcode_readwrite_timeout
   307  a26a 8dfcbc                     sta dos_error_code
   308                                  +Checkpoint "ERROR rwsbusyfail:"
   309  a26d 18                         clc
   310  a26e 60                         rts
   311                          
   312                          ;; /*  -------------------------------------------------------------------
   313                          ;;     Above functions are self-contained
   314                          ;;     ---------------------------------------------------------------- */
   315                          
   316                          sd_inc_sectornumber:
   317                          
   318                                  ;; PGS 20190225 - SD SC card support deprecated. Only SD HC supported.
   319                          
   320                                  ;; SDHC card mode: add 1
   321                                  ;;
   322                          
   323  a26f ee81d6                     inc sd_address_byte0
   324  a272 d00d                       bne s1
   325  a274 ee82d6                     inc sd_address_byte1
   326  a277 d008                       bne s1
   327  a279 ee83d6                     inc sd_address_byte2
   328  a27c d003                       bne s1
   329  a27e ee84d6                     inc sd_address_byte3
   330  a281 60                 s1:     rts
   331                          
   332                          ;;         ========================

; ******** Source: src/hyppo/main.asm
   409                          
   410                          ;; /*  -------------------------------------------------------------------
   411                          ;;     Virtualised F011 access (used for disk over serial monitor)
   412                          ;;     ---------------------------------------------------------------- */

; ******** Source: virtual_f011.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          f011_virtual_read:
     7                          
     8                                  ;; Reset buffer pointers and stop SD card from reading
     9                                  ;; from card and overwriting what we load
    10  a282 a901                       lda #$01
    11  a284 8d81d0                     sta $D081
    12                          
    13  a287 a980                       lda #$80
    14  a289 0c86d0                     tsb $D086
    15                          
    16                                  ;; We write the job details to the uart monitor interface.
    17                                  ;; Assume uart monitor interface is at 2mbits = 20 cycles
    18                                  ;; per char, so we need to add a short delay between each char
    19  a28c ad84d0                     lda $d084
    20  a28f 0980                       ora #$80
    21  a291 8d7cd6                     sta $d67C
    22                          
    23  a294 20bfa2                     jsr wait5usec
    24  a297 ad85d0                     lda $d085
    25  a29a 0980                       ora #$80
    26  a29c 8d7cd6                     sta $D67C
    27                          
    28  a29f 20bfa2                     jsr wait5usec
    29  a2a2 ad86d0                     lda $D086
    30  a2a5 0980                       ora #$80
    31  a2a7 8d7cd6                     sta $D67C
    32                          
    33  a2aa 20bfa2                     jsr wait5usec
    34  a2ad a921                       lda #$21
    35  a2af 8d7cd6                     sta $D67C
    36                          
    37                                  ;; Wait for monitor_load to clear bit 7 of side register to indicate that
    38                                  ;; it has done the job
    39  a2b2 ad86d0             fvr3:   lda $d086
    40  a2b5 30fb                       bmi fvr3
    41                          
    42                          fvr_same_as_last_time:
    43                                  ;; Set floppy flags as appropriate to look like FDC has just successfully read a
    44                                  ;; sector
    45  a2b7 a935                       lda #$35
    46  a2b9 8dafd6                     sta f011_flag_stomp
    47                          
    48  a2bc 8d7fd6                     sta hypervisor_enterexit_trigger
    49                          
    50                          wait5usec:
    51                                  ;; 40MHz = 40 cycles / usec, so we need 200 cycles
    52                                  ;; JSR/RTS is ~10 cycles
    53                                  ;; 64 iterations of 3 cycles = ~192 cycles
    54                                  ;; so should be about right
    55  a2bf a240                       ldx #$40
    56  a2c1 ca                 -       dex
    57  a2c2 d0fd                       bne -
    58  a2c4 60                         rts
    59                          
    60                          f011_virtual_write:
    61                          
    62                                  ;; Reset buffer pointers and stop SD card from reading
    63                                  ;; from card and overwriting what we load
    64  a2c5 a901                       lda #$01
    65  a2c7 8d81d0                     sta $D081
    66                          
    67  a2ca a940                       lda #$40
    68  a2cc 0c86d0                     tsb $D086
    69                          
    70                                  ;; We write the job details to the uart monitor interface.
    71                                  ;; Assume uart monitor interface is at 2mbits = 20 cycles
    72                                  ;; per char, so we need to add a short delay between each char
    73  a2cf ad84d0                     lda $d084
    74  a2d2 0980                       ora #$80
    75  a2d4 8d7cd6                     sta $d67C
    76                          
    77  a2d7 20bfa2                     jsr wait5usec
    78  a2da ad85d0                     lda $d085
    79  a2dd 0980                       ora #$80
    80  a2df 8d7cd6                     sta $D67C
    81                          
    82  a2e2 20bfa2                     jsr wait5usec
    83  a2e5 ad86d0                     lda $D086
    84  a2e8 0980                       ora #$80
    85  a2ea 8d7cd6                     sta $D67C
    86                          
    87  a2ed 20bfa2                     jsr wait5usec
    88  a2f0 a95c                       lda #$5C
    89  a2f2 8d7cd6                     sta $D67C
    90                          
    91  a2f5 ad86d0             fvw1:   lda $d086
    92  a2f8 29c0                       and #$c0
    93  a2fa d0f9                       bne fvw1
    94                          
    95  a2fc a916                       lda #$16
    96  a2fe 8dafd6                     sta f011_flag_stomp
    97                          
    98                                  ;; Return from hypervisor
    99                                  ;;
   100  a301 8d7fd6             fvw2:   sta hypervisor_enterexit_trigger
   101                          

; ******** Source: src/hyppo/main.asm
   414                          
   415                          ;; /*  -------------------------------------------------------------------
   416                          ;;     Audio mixer control functions
   417                          ;;     ---------------------------------------------------------------- */

; ******** Source: audiomix.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          audiomix_setup:
     6                          
     7                                  ;; Set all audio mixer coefficients to silent by default
     8  a304 a200                       ldx #$00
     9  a306 8a                         txa
    10                          aml1:
    11  a307 20c5a3                     jsr audiomix_setcoefficient
    12  a30a e8                         inx
    13  a30b d0fa                       bne aml1
    14                          
    15                                  ;; Set master volume to max for L & R channels on M65R2 audio jack
    16  a30d a9ff                       lda #$ff
    17  a30f a2fe                       ldx #$fe
    18  a311 20e0a3                     jsr audiomix_set2coefficients
    19  a314 a2de                       ldx #$de
    20  a316 20e0a3                     jsr audiomix_set2coefficients
    21                                  ;; And also for speaker / HDMI audio outputs
    22                                  ;; Now we have a fun problem: Internal speakers need it MUCH louder than HDMI
    23                                  ;; and we wouldn't be able to set the two independently.
    24  a319 a9ff                       lda #$ff
    25  a31b a21e                       ldx #$1e
    26  a31d 20e0a3                     jsr audiomix_set2coefficients
    27  a320 a23e                       ldx #$3e
    28  a322 20e0a3                     jsr audiomix_set2coefficients
    29                          
    30  a325 20b1a3                     jsr audio_set_stereo
    31                          
    32                                  ;; Set OPL / FM / SFX / Adlib volume to max on all channels
    33  a328 a90c                       lda #$0c
    34                          fmvolloop:
    35  a32a aa                         tax
    36  a32b a9ff                       lda #$ff
    37  a32d 20e0a3                     jsr audiomix_set2coefficients
    38  a330 8a                         txa
    39  a331 18                         clc
    40  a332 6920                       adc #$20
    41  a334 90f4                       bcc fmvolloop
    42                          
    43                          
    44                          audio_set_mono:
    45                                  ;; Left and right SID volume levels
    46                                  ;; for stereo operation
    47  a336 a9be                       lda #$be
    48  a338 a2c0                       ldx #$c0
    49  a33a 20d8a3                     jsr audiomix_set4coefficients
    50  a33d a2d0                       ldx #$d0
    51  a33f 20d8a3                     jsr audiomix_set4coefficients
    52  a342 a2f0                       ldx #$f0
    53  a344 20d8a3                     jsr audiomix_set4coefficients
    54  a347 a2e0                       ldx #$e0
    55  a349 20d8a3                     jsr audiomix_set4coefficients
    56  a34c a200                       ldx #$00
    57  a34e 20d8a3                     jsr audiomix_set4coefficients
    58  a351 a210                       ldx #$10
    59  a353 20d8a3                     jsr audiomix_set4coefficients
    60  a356 a220                       ldx #$20
    61  a358 20d8a3                     jsr audiomix_set4coefficients
    62  a35b a230                       ldx #$30
    63  a35d 20d8a3                     jsr audiomix_set4coefficients
    64  a360 60                         rts
    65                          
    66                          audiomix_set_sid_lr_coefficients:
    67  a361 a2c0                       ldx #$c0
    68  a363 20e0a3                     jsr audiomix_set2coefficients
    69  a366 a2d0                       ldx #$d0
    70  a368 20e0a3                     jsr audiomix_set2coefficients
    71  a36b a2e2                       ldx #$e2
    72  a36d 20e0a3                     jsr audiomix_set2coefficients
    73  a370 a2f2                       ldx #$f2
    74  a372 20e0a3                     jsr audiomix_set2coefficients
    75  a375 a200                       ldx #$00
    76  a377 20e0a3                     jsr audiomix_set2coefficients
    77  a37a a210                       ldx #$10
    78  a37c 20e0a3                     jsr audiomix_set2coefficients
    79  a37f a222                       ldx #$22
    80  a381 20e0a3                     jsr audiomix_set2coefficients
    81  a384 a232                       ldx #$32
    82  a386 4ce0a3                     jmp audiomix_set2coefficients
    83                          
    84                          audiomix_set_sid_rl_coefficients:
    85  a389 a2c2                       ldx #$c2
    86  a38b 20e0a3                     jsr audiomix_set2coefficients
    87  a38e a2d2                       ldx #$d2
    88  a390 20e0a3                     jsr audiomix_set2coefficients
    89  a393 a2e0                       ldx #$e0
    90  a395 20e0a3                     jsr audiomix_set2coefficients
    91  a398 a2f0                       ldx #$f0
    92  a39a 20e0a3                     jsr audiomix_set2coefficients
    93  a39d a202                       ldx #$02
    94  a39f 20e0a3                     jsr audiomix_set2coefficients
    95  a3a2 a212                       ldx #$12
    96  a3a4 20e0a3                     jsr audiomix_set2coefficients
    97  a3a7 a220                       ldx #$20
    98  a3a9 20e0a3                     jsr audiomix_set2coefficients
    99  a3ac a230                       ldx #$30
   100  a3ae 4ce0a3                     jmp audiomix_set2coefficients
   101                          
   102                          audio_set_stereo:
   103                                  ;; Left and right SID volume levels
   104                                  ;; for stereo operation
   105  a3b1 a9be                       lda #$be
   106  a3b3 2061a3                     jsr audiomix_set_sid_lr_coefficients
   107  a3b6 a940                       lda #$40
   108  a3b8 4c89a3                     jmp audiomix_set_sid_rl_coefficients
   109                          
   110                          audio_set_stereomirrored:
   111                                  ;; Left and right SID volume levels
   112                                  ;; for stereo operation
   113  a3bb a940                       lda #$40
   114  a3bd 2061a3                     jsr audiomix_set_sid_lr_coefficients
   115  a3c0 a9be                       lda #$be
   116  a3c2 4c89a3                     jmp audiomix_set_sid_rl_coefficients
   117                          
   118                          audiomix_setcoefficient:
   119  a3c5 8ef4d6                     stx audiomix_addr
   120                          
   121                                  ;; wait 17 cycles before writing (16 + start of read instruction)
   122                                  ;; to give time to audio mixer to fetch the 16-bit coefficient, before
   123                                  ;; we write to half of it (which requires the other half loaded, so that the
   124                                  ;; write to the 16-bit register gets the correct other half).
   125                                  ;; note that bit $1234 gets replaced in hyppo by monitor_load when doing
   126                                  ;; hot-patching, so we can't use that instruction for the delay
   127                          
   128                                  ;; simple solution: write to address register several times to spend the time.
   129                                  ;; 16 cycles here. then the sta of the data gives us 3 more cycles, so we are fine.
   130  a3c8 8ef4d6                     stx audiomix_addr
   131  a3cb 8ef4d6                     stx audiomix_addr
   132  a3ce 8ef4d6                     stx audiomix_addr
   133  a3d1 8ef4d6                     stx audiomix_addr
   134                          
   135                                  ;; update coefficient
   136  a3d4 8df5d6                     sta audiomix_data
   137  a3d7 60                         rts
   138                          
   139                          audiomix_set4coefficients:
   140  a3d8 20c5a3                     jsr audiomix_setcoefficient
   141  a3db e8                         inx
   142  a3dc 20c5a3                     jsr audiomix_setcoefficient
   143  a3df e8                         inx
   144                          audiomix_set2coefficients:
   145  a3e0 20c5a3                     jsr audiomix_setcoefficient
   146  a3e3 e8                         inx
   147  a3e4 4cc5a3                     jmp audiomix_setcoefficient

; ******** Source: src/hyppo/main.asm
   419                          
   420                          ;; /*  -------------------------------------------------------------------
   421                          ;;     Target-specific register setup
   422                          ;;     ---------------------------------------------------------------- */

; ******** Source: targetsetup.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                  ;; Setup functions for MEGAphone.
     7                                  ;; Basically setup the I2C IO expanders with sensible values, turning
     8                                  ;; all peripherals on.
     9                          
    10                          targetspecific_setup:
    11                          
    12                                  ;; Setup common I2C area 32-bit pointer
    13  a3e7 a900                       lda #<$7000
    14  a3e9 8d10bf                     sta zptempv32+0
    15  a3ec a970                       lda #>$7000
    16  a3ee 8d11bf                     sta zptempv32+1
    17  a3f1 a9fd                       lda #<$0FFD
    18  a3f3 8d12bf                     sta zptempv32+2
    19  a3f6 a90f                       lda #>$0FFD
    20  a3f8 8d13bf                     sta zptempv32+3
    21                          
    22                                  ;; Apply I2C settings based on target ID
    23  a3fb ad29d6                     lda $d629
    24  a3fe c903                       cmp #$03
    25  a400 f00d                       beq mega65r3_i2c_setup
    26  a402 c904                       cmp #$04
    27  a404 f008                       beq mega65r4_i2c_setup
    28  a406 ad29d6                     lda $d629
    29  a409 c920                       cmp #$20
    30  a40b f02c                       beq megaphone_r1_i2c_setup
    31  a40d 60                         rts
    32                          
    33                          mega65r4_i2c_setup:
    34                                  ;; XXX - Add setup for MEGA65R4 board here
    35  a40e 60                         rts
    36                          
    37                          mega65r3_i2c_setup:
    38                          
    39  a40f a971                       lda #>$7100
    40  a411 8d11bf                     sta zptempv32+1
    41  a414 a900                       lda #$00
    42  a416 8d20d0                     sta $d020
    43  a419 a000                       ldy #$00
    44                          
    45                          mps3_loop:
    46  a41b b98aa4                     lda mega65r3_i2c_settings,y
    47  a41e c9ff                       cmp #$ff
    48  a420 d003                       bne +
    49  a422 a300                       ldz #$00
    50                          
    51  a424 60                         rts
    52                          +
    53  a425 4b                         taz
    54  a426 c8                         iny
    55  a427 b98aa4                     lda mega65r3_i2c_settings,y
    56  a42a c8                         iny
    57                          
    58                          
    59                                  ;; Keep writing it until it gets written
    60                          -
    61  a42b ea9210                      sta [<zptempv32],z
    62                          
    63  a42e ee20d0                     inc $d020
    64  a431 ead210                     cmp [<zptempv32],z
    65  a434 d0f5                       bne -
    66                          
    67  a436 4c1ba4                     jmp mps3_loop
    68                          
    69                          megaphone_r1_i2c_setup:
    70                          
    71                                  ;; Start with backscreen very dim, to avoid inrush current
    72                                  ;; causing FGPA power rail to sag.
    73  a439 a901                       lda #$01
    74  a43b 8df0d6                     sta $d6f0
    75                          
    76  a43e a900                       lda #$00
    77  a440 8d20d0                     sta $d020
    78  a443 a000                       ldy #$00
    79                          mps_loop:
    80  a445 b968a4                     lda megaphone_r1_i2c_settings,y
    81  a448 c9ff                       cmp #$ff
    82  a44a d008                       bne +
    83  a44c a300                       ldz #$00
    84                          
    85                                  ;; Set full brightness on LCD on exit
    86  a44e a9ff                       lda #$ff
    87  a450 8df0d6                     sta $d6f0
    88                          
    89  a453 60                         rts
    90                          +
    91  a454 4b                         taz
    92  a455 c8                         iny
    93  a456 b968a4                     lda megaphone_r1_i2c_settings,y
    94  a459 c8                         iny
    95                          
    96                          
    97                                  ;; Keep writing it until it gets written
    98                          -
    99  a45a ea9210                     sta [<zptempv32],z
   100                          
   101                                  ;; Wait for I2C register to get written
   102                          
   103  a45d ee20d0                     inc $d020
   104                          
   105  a460 ead210                     cmp [<zptempv32],z
   106  a463 d0f5                       bne -
   107                          
   108                          
   109  a465 4c45a4                     jmp mps_loop
   110                          
   111                          
   112                          megaphone_r1_i2c_settings:
   113                                  ;; LCD panel
   114  a468 1640                       !8 $16,$40 ;; Port 0 to output, except LCD backlight line, that we now control via an FPGA pin
   115  a46a 1700                       !8 $17,$00 ;; Port 1 to output
   116  a46c 12bf                       !8 $12,$bf ;; Enable power to all sub-systems ($BF = $FF - $40)
   117  a46e 1320                       !8 $13,$20 ;; Power up headphones amplifier
   118                          
   119                                  ;; Speaker amplifier configuration
   120  a470 35ff                       !8 $35,$FF   ;; Left volume initial mute
   121  a472 36ff                       !8 $36,$FF   ;; Right volume initial mute
   122  a474 3020                       !8 $30,$20
   123  a476 3100                       !8 $31,$00
   124  a478 3202                       !8 $32,$02
   125  a47a 3300                       !8 $33,$00
   126  a47c 3410                       !8 $34,$10
   127  a47e 3780                       !8 $37,$80
   128  a480 380c                       !8 $38,$0C
   129  a482 3999                       !8 $39,$99
   130  a484 3560                       !8 $35,$60   ;; Left volume set ($FF = mute, $40 = full volume)
   131  a486 3660                       !8 $36,$60   ;; Right volume set ($FF = mute, $40 = full volume)
   132                          
   133                          
   134  a488 ffff                       !8 $FF,$FF ;; End of list marker
   135                          
   136                          mega65r3_i2c_settings:
   137                                  ;; Speaker amplifier configuration
   138  a48a e1ff                       !8 $e1,$FF   ;; Left volume initial mute
   139  a48c e2ff                       !8 $e2,$FF   ;; Right volume initial mute
   140  a48e dc20                       !8 $dc,$20
   141  a490 dd00                       !8 $dd,$00
   142  a492 de02                       !8 $de,$02
   143  a494 df00                       !8 $df,$00
   144  a496 e010                       !8 $e0,$10
   145  a498 e380                       !8 $e3,$80
   146  a49a e40c                       !8 $e4,$0C
   147  a49c e599                       !8 $e5,$99
   148  a49e e120                       !8 $e1,$20   ;; Left volume set ($FF = mute, $40 = full volume, $00 = +24dB)
   149  a4a0 e220                       !8 $e2,$20   ;; Right volume set ($FF = mute, $40 = full volume, $00 = +24dB)
   150                          
   151                          
   152  a4a2 ffff                       !8 $FF,$FF ;; End of list marker

; ******** Source: src/hyppo/main.asm
   424                          
   425                          ;; /*  -------------------------------------------------------------------
   426                          ;;     CPU Hypervisor Entry Point on reset
   427                          ;;     ---------------------------------------------------------------- */
   428                          
   429                          reset_machine_state:
   430                                  ;; get CPU state sensible
   431  a4a4 78                         sei
   432  a4a5 d8                         cld
   433  a4a6 03                         see
   434                          
   435                                  ;; ;; Disable reset watchdog (this happens simply by writing anything to
   436                                  ;; ;; this register)
   437                                  ;; ;; Enable /EXROM and /GAME from cartridge port (bit 0)
   438                                  ;; ;; enable flat 32-bit addressing (bit 1)
   439                                  ;; ;; do not engage ROM write protect (yet) (bit 2)
   440                                  ;; ;; do make ASC/DIN / CAPS LOCK control CPU speed (bit 3)
   441                                  ;; ;; do not force CPU to full speed (bit 4)
   442                                  ;; ;; also force 4502 CPU personality (6502 personality is still incomplete) (bit 5)
   443                                  ;; ;; and clear any pending IRQ or NMI event (bit 6)
   444                                  ;; ;;
   445                                  ;; ;; (The watchdog was added to catch reset problems where the machine
   446                                  ;; ;; would run off somewhere odd instead of resetting properly. Now it
   447                                  ;; ;; will auto-reset after 65535 cycles if the watchdog is not cleared).
   448                                  ;; ;;
   449                          
   450  a4a7 a96b                       lda #$6b    ;; 01101011
   451  a4a9 8d7dd6                     sta hypervisor_feature_enables
   452                          
   453                                  ;; Reset ethernet to clear any queued packets from before reset
   454                                  ;; and ack 1 packet to get the controller into the right state
   455  a4ac a900                       lda #$00
   456  a4ae 8de0d6                     sta $d6e0
   457  a4b1 a903                       lda #$03
   458  a4b3 8de0d6                     sta $d6e0
   459  a4b6 8de1d6                     sta $d6e1
   460  a4b9 a900                       lda #$00
   461  a4bb 8de1d6                     sta $d6e1
   462                          
   463                          
   464                                  ;; Enable cartridge /EXROM and /GAME lines in CPU addressing
   465  a4be a902                       lda #$02
   466  a4c0 0cfbd7                     tsb $d7fb
   467                          
   468                                  ;; /EXROM and /GAME follow cartridge port
   469  a4c3 a93f                       lda #$3f
   470  a4c5 8dfdd7                     sta $d7fd
   471                          
   472  a4c8 2004a3                     jsr audiomix_setup
   473                                  ;; enable audio amplifier
   474  a4cb a901                       lda #$01
   475  a4cd 8dfed6                     sta audioamp_ctl
   476                          
   477                                  ;; Return keyboard LEDs to automatic control
   478  a4d0 a900                       lda #$00
   479  a4d2 8d1dd6                     sta $d61d
   480                                  ;; Disable VIC-IV debug modes
   481  a4d5 8d66d0                     sta $d066
   482                                  ;; Clear system partition present flag
   483  a4d8 8dfebc                     sta syspart_present
   484                                  ;; disable IRQ/NMI sources
   485  a4db 8d1ad0                     sta $D01A
   486  a4de a97f                       lda #$7f
   487  a4e0 8d7fd0                     sta $d07f                   ; Hide VIC-IV cross-hairs
   488  a4e3 8d0ddc                     sta $DC0D
   489  a4e6 8d0ddd                     sta $DD0D
   490                          
   491                                  ;; clear UART interrupt status
   492  a4e9 ad06d6                     lda uart65_irq_flag
   493                          
   494                                  ;; switch to fast mode
   495                                  ;; 1. C65 fast-mode enable, and disable extended attributes
   496  a4ec a940                       lda #$40
   497  a4ee 8d31d0                     sta $d031
   498                                  ;; 2. MEGA65 48MHz enable (requires C65 or C128 fast mode to truly enable, hence the above)
   499  a4f1 a9c5                       lda #$c5
   500  a4f3 0c54d0                     tsb $d054
   501                          
   502                                  ;; Setup I2C peripherals on the MEGAphone platform
   503  a4f6 20e7a3                     jsr targetspecific_setup
   504                          
   505                                  ;; sprites off, and normal mode, 256-colour char data from chipram
   506  a4f9 a900                       lda #$00
   507  a4fb 8d15d0                     sta $d015
   508  a4fe 8d63d0                     sta $d063
   509  a501 8d55d0                     sta $d055
   510  a504 8d6bd0                     sta $d06b
   511  a507 8d57d0                     sta $d057
   512  a50a a9f0                       lda #$f0
   513  a50c aa                         tax
   514  a50d 1c49d0                     trb $d049
   515  a510 8a                         txa
   516  a511 1c4bd0                     trb $d04b
   517  a514 8a                         txa
   518  a515 1c4dd0                     trb $d04d
   519  a518 8a                         txa
   520  a519 1c4fd0                     trb $d04f
   521                          
   522                                  ;; We DO NOT need to mess with $01, because
   523                                  ;; the 4510 starts up with hyppo mapped at $8000-$BFFF
   524                                  ;; enhanced ($FFD3xxx) IO page mapped at $D000,
   525                                  ;; and fast RAM elsewhere.
   526                          
   527                                  ;; Map SD card sector buffer to SD card, not floppy drive
   528  a51c a980                       lda #$80
   529  a51e 8d89d6                     sta sd_buffer_ctrl
   530                          
   531                                  ;; Access cartridge IO area to force EXROM probe on R1 PCBs
   532                                  ;; XXX DONT READ $DExx ! This is a known crash causer for Action Replay
   533                                  ;; cartridges.  $DF00 should be okay, however.
   534                                  ;; XXX $DFxx can also be a problem for other cartridges, so we shouldn't do either.
   535                                  ;; this will mean cartridges don't work on the R1 PCB, but as that is no longer being
   536                                  ;; developed for, we can just ignore that now, and not touch anything.
   537                                  ;;lda $df00
   538                          
   539  a521 205ca9                     jsr resetdisplay
   540  a524 2012aa                     jsr erasescreen
   541  a527 20c2a9                     jsr resetpalette
   542                          
   543                                  ;; note that this first message does not get displayed correctly
   544                                  +Checkpoint "reset_machine_state"
   545                                  ;; but this second message does
   546                                  +Checkpoint "reset_machine_state"
   547                          
   548  a52a 60                         rts
   549                          
   550                          ;; /*  -------------------------------------------------------------------
   551                          ;;     CPU Hypervisor reset/trap routines
   552                          ;;     ---------------------------------------------------------------- */
   553                          reset_entry:
   554  a52b 78                         sei
   555                          
   556                                   ;; Put ZP and stack back where they belong
   557  a52c a9bf                       lda #$bf
   558  a52e 5b                         tab
   559  a52f a0be                       ldy #$be
   560  a531 2b                         tys
   561  a532 a2ff                       ldx #$ff
   562  a534 9a                         txs
   563                          
   564                                  ;; Clear mapping of lower memory area
   565  a535 a200                       ldx #$00
   566  a537 a900                       lda #$00
   567  a539 a000                       ldy #$00
   568  a53b a33f                       ldz #$3f
   569  a53d 5c                         map
   570  a53e ea                         eom
   571                          
   572                          !if DEBUG_HYPPO {
   573                                  !src "debugtests.asm"
   574                          }
   575                          
   576  a53f 20a4a4                     jsr reset_machine_state
   577                          
   578                                  ;; If banner is in flash, load it _immediately_
   579  a542 20c5a7                     jsr tryloadbootlogofromflash
   580                          
   581                                  ;; display welcome screen
   582                                  ;;
   583  a545 a21f                       ldx #<msg_hyppo
   584  a547 a0b0                       ldy #>msg_hyppo
   585  a549 20bcaa                     jsr printmessage
   586                          
   587                                  ;; leave a blank line below hyppo banner
   588                                  ;;
   589  a54c a2b7                       ldx #<msg_blankline
   590  a54e a0b3                       ldy #>msg_blankline
   591  a550 20bcaa                     jsr printmessage
   592                          
   593                                  ;; Display GIT commit
   594                                  ;;
   595  a553 a298                       ldx #<msg_gitcommit
   596  a555 a0b3                       ldy #>msg_gitcommit
   597  a557 20bcaa                     jsr printmessage
   598                          
   599                                  ;; Magic instruction used by monitor_load to work out where
   600                                  ;; to patch. Monitor_load changes bit to JMP when patching for
   601                                  ;; SD-cardless operation
   602  a55a 2c5cab                     bit go64
   603  a55d 2c3412                     bit $1234
   604                          
   605                                  ;; Display help text
   606  a560 ad78a5                     lda first_boot_flag_instruction
   607  a563 c94c                       cmp #$4c
   608  a565 f00a                       beq not_first_boot_message
   609  a567 a23f                       ldx #<msg_hyppohelpfirst
   610  a569 a0b0                       ldy #>msg_hyppohelpfirst
   611  a56b 20bcaa                     jsr printmessage
   612  a56e 4c78a5                     jmp first_boot_flag_instruction
   613                          
   614                          not_first_boot_message:
   615  a571 a265                       ldx #<msg_hyppohelpnotfirst
   616  a573 a0b0                       ldy #>msg_hyppohelpnotfirst
   617  a575 20bcaa                     jsr printmessage
   618                          
   619                                  ;; Work out if we are on first reset.  If so, then try switching to bitstream in 2nd slot.
   620                          
   621                          try_flash_menu:
   622                                  ;; Use first boot code path only once
   623                                  ;; WARNING: Self modifying code!
   624                          first_boot_flag_instruction:
   625  a578 2cc7a5                     bit dont_launch_flash_menu
   626                          
   627                                  ;; On first boot, we start the flash menu regardless
   628                                  ;; (The flash menu will work out whether to switch bitstream or not)
   629                          
   630                          launch_flash_menu:
   631                          
   632                                  ;; Disable digital audio when launching flash menu
   633  a57b 2065ad                     jsr safe_video_mode
   634                          
   635                                  ;; Disable cartridge, the flash menu does not run with cart enabled!
   636  a57e a902                       lda #$02
   637  a580 1cfbd7                     trb $d7fb
   638                          
   639                                  ;; Store where the flash menu should jump to if it doesn't need to do anything.
   640  a583 a990                       lda #<return_from_flashmenu
   641  a585 8d80cf                     sta $cf80
   642  a588 a9a5                       lda #>return_from_flashmenu
   643  a58a 8d81cf                     sta $cf81
   644                                  ;; Then actually start it.
   645                                  ;; NOTE: Flash menu runs in hypervisor mode, so can't use memory beyond $7FFF etc.
   646                                  ;; (and is immune to attempts to freeze it)
   647                          
   648  a58d 4c4dae                     jmp flash_menu
   649                          
   650                          return_from_flashmenu:
   651                          
   652                                  ;; Here we have been given control back from the flash menu program.
   653                                  ;; So we have to put some things back to continue the kickstart boot process.
   654                          
   655                                  ;; Put ZP and stack back where they belong
   656  a590 a9bf                       lda #$bf
   657  a592 5b                         tab
   658  a593 a0be                       ldy #$be
   659  a595 2b                         tys
   660  a596 a2ff                       ldx #$ff
   661  a598 9a                         txs
   662                          
   663  a599 a9ff                       lda #$ff
   664  a59b 8d02d7                     sta $d702
   665  a59e a9ff                       lda #$ff
   666  a5a0 8d04d7                     sta $d704  ;; dma list is in top MB of address space
   667                          
   668                                  ;; Don't forget to reset colour RAM also
   669  a5a3 a901                       lda #$01
   670  a5a5 0c30d0                     tsb $d030
   671  a5a8 a9aa                       lda #>erasescreendmalist
   672  a5aa 8d01d7                     sta $d701
   673                                  ;; set bottom 8 bits of address and trigger DMA.
   674                                  ;;
   675  a5ad a9a1                       lda #<erasescreendmalist
   676  a5af 8d05d7                     sta $d705
   677  a5b2 a901                       lda #$01
   678  a5b4 1c30d0                     trb $d030
   679                          
   680                                  ;; And finally, the screen data
   681  a5b7 a9ae                       lda #>screenrestore_dmalist
   682  a5b9 8d01d7                     sta $d701
   683                                  ;; Trigger enhanced DMA
   684  a5bc a9d0                       lda #<screenrestore_dmalist
   685  a5be 8d05d7                     sta $d705
   686                          
   687  a5c1 205ca9                     jsr resetdisplay
   688                          
   689  a5c4 4cc7a5                     jmp dont_launch_flash_menu
   690                          
   691                          dont_launch_flash_menu:
   692  a5c7 ad10d6                     lda ascii_key_in
   693  a5ca c909                       cmp #$09
   694  a5cc f007                       beq noflash_menu
   695  a5ce ad11d6                     lda buckykey_status
   696  a5d1 2920                       and #$20
   697  a5d3 f00d                       beq fpga_has_been_reconfigured
   698                          
   699                                  ;; Tell user what to do if they can't access the flash menu
   700                          noflash_menu:
   701  a5d5 a2e2                       ldx #<msg_noflashmenu
   702  a5d7 a0af                       ldy #>msg_noflashmenu
   703  a5d9 20bcaa                     jsr printmessage
   704  a5dc ee20d0                     inc $d020
   705                          nfm1:
   706  a5df 4cdfa5                     jmp nfm1
   707                          
   708                          
   709                          fpga_has_been_reconfigured:
   710                          
   711                                  ;; We can't trust that the flash menu is still in memory by this point, so do nothing.
   712                                  ;; (This also means if you choose "safe mode" factory bitstream, and then reset, it
   713                                  ;; won't try to run upgraded bitstream again.)
   714                          
   715                                  ;; wait 0.1 msec for things to settle after power-up
   716  a5e2 20dba1                     jsr sdwaitawhile
   717                          
   718                                  ;; check keyboard for 0-9 down to select alternate rom
   719                                  ;;
   720  a5e5 20f3ac                     jsr keyboardread
   721                          
   722                          ;;         ========================
   723                          
   724                          normalboot:
   725                          
   726                          ; add a test if the ESC key is held down
   727                          ; if so, make an endless loop so that a person debugging
   728                          ; and turn trace mode on, move the pc (with 'g<addr>') to skip
   729                          ; over the loop and then comfortably step through early
   730                          ; hypervisor code.
   731  a5e8 a2ff                       ldx #$ff    ;; make a few attempts are reading keyscan early
   732                          
   733                          @earlyscan:
   734  a5ea 20c9ac                     jsr scankeyboard
   735  a5ed 9006                       bcc @earlycheckkey
   736                                  ;; no key pressed yet
   737  a5ef ca                         dex
   738  a5f0 d0f8                       bne @earlyscan
   739  a5f2 4cffa5                     jmp @skipearlycheck  ;; no key was pressed, despite looping for a while to wait for it
   740                          
   741                          @earlycheckkey:
   742  a5f5 c91b                       cmp #$1b    ;; was ESCAPE key pressed?
   743  a5f7 d006                       bne @skipearlycheck
   744                          
   745                          @loopendlessly
   746  a5f9 ee20d0                     inc $d020
   747  a5fc 4cf9a5                     jmp @loopendlessly
   748                          
   749                          @skipearlycheck:
   750                          
   751                                  ;; Setup process control block and non-OS process ID upon entering the
   752                                  ;; hypervisor.
   753  a5ff 200da0                     jsr task_new_processcontrolblock
   754                          
   755                          !if DEBUG_HYPPO {
   756                                  jsr dump_disk_count        ;; debugging to Checkpoint
   757                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
   758                          }
   759                          
   760                                  ;; Try to read the MBR from the SD card to ensure SD card is happy
   761                                  ;;
   762  a602 a2c8                       ldx #<msg_tryingsdcard
   763  a604 a0b0                       ldy #>msg_tryingsdcard
   764  a606 20bcaa                     jsr printmessage
   765                          
   766                                  ;; Work out if we are using primary or secondard SD card
   767                          
   768                                  ;; First try resetting card 1 (external)
   769                                  ;; so that if you have an external card, it will be used in preference
   770  a609 a9c1                       lda #$c1
   771  a60b 8d80d6                     sta $d680
   772  a60e a900                       lda #$00
   773  a610 8d80d6                     sta $d680
   774  a613 a901                       lda #$01
   775  a615 8d80d6                     sta $d680
   776                          
   777  a618 a203                       ldx #$03
   778                          morewaiting:
   779  a61a 20dba1                     jsr sdwaitawhile
   780                          
   781  a61d ad80d6                     lda $d680
   782  a620 2903                       and #$03
   783  a622 d00c                       bne trybus0
   784                          
   785  a624 da                         phx
   786                          
   787  a625 a261                       ldx #<msg_usingcard1
   788  a627 a0b3                       ldy #>msg_usingcard1
   789  a629 20bcaa                     jsr printmessage
   790                          
   791  a62c fa                         plx
   792                          
   793  a62d 4c62a6                     jmp tryreadmbr
   794                          trybus0:
   795  a630 ca                         dex
   796  a631 d0e7                       bne morewaiting
   797                          
   798  a633 a9c0                       lda #$c0
   799  a635 8d80d6                     sta $d680
   800                          
   801  a638 a24d                       ldx #<msg_tryingcard0
   802  a63a a0b3                       ldy #>msg_tryingcard0
   803  a63c 20bcaa                     jsr printmessage
   804                          
   805                                  ;; Try resetting card 0
   806  a63f a900                       lda #$00
   807  a641 8d80d6                     sta $d680
   808  a644 a901                       lda #$01
   809  a646 8d80d6                     sta $d680
   810                          
   811  a649 a203                       ldx #$03
   812                          @morewaiting2:
   813  a64b 20dba1                     jsr sdwaitawhile
   814                          
   815  a64e ad80d6                     lda $d680
   816  a651 2903                       and #$03
   817  a653 f00d                       beq tryreadmbr
   818                          
   819  a655 ca                         dex
   820  a656 d0f3                       bne @morewaiting2
   821                          
   822                                  ;; No working SD card -- we can just try booting to BASIC, since we
   823                                  ;; now include our open-source ROM
   824  a658 a23f                       ldx #<msg_nosdcard
   825  a65a a0b1                       ldy #>msg_nosdcard
   826  a65c 20bcaa                     jsr printmessage
   827  a65f 4c5cab                     jmp go64
   828                          
   829                          tryreadmbr:
   830  a662 204ca1                     jsr readmbr
   831  a665 b01b                       bcs gotmbr
   832                          
   833                                  ;; check for keyboard input to jump to utility menu
   834  a667 20c9ac                     jsr scankeyboard
   835  a66a b007                       bcs nokey2
   836  a66c c920                       cmp #$20
   837  a66e d003                       bne nokey2
   838  a670 4c70ad                     jmp utility_menu
   839                          nokey2:
   840                          
   841                                  ;; Oops, cant read MBR
   842                                  ;; display debug message to screen
   843                                  ;;
   844  a673 a209                       ldx #<msg_retryreadmbr
   845  a675 a0b0                       ldy #>msg_retryreadmbr
   846  a677 20bcaa                     jsr printmessage
   847                          
   848                                  ;; put sd card sector buffer back after scanning
   849                                  ;; keyboard
   850  a67a a981                       lda #$81
   851  a67c 0c80d6                     tsb sd_ctrl
   852                          
   853                                  ;; display debug message to uart
   854                                  ;;
   855                                  +Checkpoint "re-try reading MBR of sdcard"
   856                          
   857  a67f 4c62a6                     jmp tryreadmbr
   858                          
   859                          ;;         ========================
   860                          
   861                          gotmbr:
   862                                  ;; good, was able to read the MBR
   863                          
   864                                  ;; Scan SD card for partitions and mount them.
   865                                  ;;
   866  a682 20d693                     jsr dos_clearall
   867  a685 208d90                     jsr dos_read_partitiontable
   868                          
   869                                  ;; then print out some useful information
   870                                  ;;
   871  a688 a27a                       ldx #<msg_diskcount
   872  a68a a0b1                       ldy #>msg_diskcount
   873  a68c 20bcaa                     jsr printmessage
   874                                  ;;
   875  a68f a000                       ldy #$00
   876  a691 ab01bc                     ldz dos_disk_count
   877  a694 2035ab                     jsr printhex
   878                                  ;;
   879  a697 a000                       ldy #$00
   880  a699 ab02bc                     ldz dos_default_disk
   881  a69c 2035ab                     jsr printhex
   882                          
   883                          !if DEBUG_HYPPO {
   884                                  jsr dump_disk_count     ;; debugging to Checkpoint
   885                                  jsr dumpcurrentfd       ;; debugging to Checkpoint
   886                          ;;             jsr print_disk_table        ; debugging to Screen
   887                          }
   888                          
   889                          ;;         ========================
   890                          
   891                                  ;; If we have no disks, offer the utility menu
   892  a69f ad01bc                     lda dos_disk_count
   893  a6a2 d003                       bne @thereIsADisk
   894  a6a4 4c70ad                     jmp utility_menu
   895                          @thereIsADisk:
   896                          
   897                                  ;; Go to root directory on default disk
   898  a6a7 2049a7                     jsr cdroot_and_complain_if_fails
   899                          
   900                          mountsystemdiskok:
   901                          
   902                          loadbannerfromsd:
   903                                  ;; Load and display boot logo
   904                          
   905  a6aa 201fa8                     jsr setup_banner_load_pointer
   906                          
   907  a6ad a2f8                       ldx #<txt_BOOTLOGOM65
   908  a6af a0b3                       ldy #>txt_BOOTLOGOM65
   909  a6b1 20d59b                     jsr dos_setname
   910                          
   911                                  ;; print debug message
   912                                  ;;
   913                                  +Checkpoint "  try-loading BOOTLOGO"
   914                          
   915  a6b4 205099                     jsr dos_readfileintomemory
   916  a6b7 b00f                       bcs logook
   917                          
   918                          ;;         ========================
   919                          
   920                                  ;; FAILED: print debug message
   921                                  ;;
   922                                  +Checkpoint "  FAILED-loading BOOTLOGO"
   923                          
   924                                  ;; print debug message
   925                                  ;;
   926  a6b9 a208                       ldx #<msg_nologo
   927  a6bb a0b3                       ldy #>msg_nologo
   928  a6bd 20bcaa                     jsr printmessage
   929  a6c0 a000                       ldy #$00
   930  a6c2 abfcbc                     ldz dos_error_code
   931  a6c5 2035ab                     jsr printhex
   932                          
   933                                  +Checkpoint "FAILED loading BOOTLOGO"
   934                          
   935                          ;;         ========================
   936                          
   937                          logook:
   938                                  ;; Loaded banner, so copy palette into place
   939  a6c8 2076aa                     jsr setbannerpalette
   940                          
   941                                  ;; iterate through directory entries looking for ordinary file
   942                                  ;; HICKUP.M65 to load into hypervisor memory ...
   943                                  ;; ... but only if we are not running a hick-up'd hyppo now.
   944                                  ;;
   945  a6cb ad7ed6                     lda hypervisor_hickedup_flag        ;; $d67e = register for hickup-state (00=virgin, else already-hicked)
   946  a6ce 100a                       bpl allowhickup
   947                          
   948                                  ;; already hicked
   949                                  ;;
   950  a6d0 a2ee                       ldx #<msg_alreadyhicked
   951  a6d2 a0b2                       ldy #>msg_alreadyhicked
   952  a6d4 20bcaa                     jsr printmessage
   953                          
   954  a6d7 4c64a7                     jmp posthickup
   955                          
   956                          ;;         ========================
   957                          
   958                          allowhickup:        ;; BG was label nextdirectoryentry3:
   959                          
   960                                  ;; Prepare 32-bit pointer for loading hickup @ $0004000
   961                                  ;;
   962                                  ;; We load it at $4000, which is mapped to first 64KB RAM, and then
   963                                  ;; have a routine also in RAM that we use to copy the loaded data
   964                                  ;; back onto the Hyppo "ROM" space, so that there are no problems
   965                                  ;; with the copying code being changed while it being replaced.
   966                                  ;;
   967  a6da a900                       lda #$00
   968  a6dc 8518                       sta <dos_file_loadaddress+0
   969  a6de a940                       lda #$40
   970  a6e0 8519                       sta <dos_file_loadaddress+1
   971  a6e2 a900                       lda #$00
   972  a6e4 851a                       sta <dos_file_loadaddress+2
   973  a6e6 a900                       lda #$00
   974  a6e8 851b                       sta <dos_file_loadaddress+3
   975                          
   976  a6ea a2ed                       ldx #<txt_HICKUPM65
   977  a6ec a0b3                       ldy #>txt_HICKUPM65
   978  a6ee 20d59b                     jsr dos_setname
   979                          
   980                                  ;; print debug message
   981                                  ;;
   982                                  +Checkpoint "  try-loading HICKUP"
   983                          
   984  a6f1 205099                     jsr dos_readfileintomemory
   985  a6f4 906e                       bcc nohickup
   986                          
   987                          ;;         ========================
   988                          
   989                                  ;; We have loaded a hickup file, so jump into it.
   990                          
   991                                  ;; print debug message
   992                                  ;;
   993                                  +Checkpoint "  loaded OK HICKUP"
   994                          
   995                          ;;                 ldx #<msg_hickuploaded
   996                          ;;                 ldy #>msg_hickuploaded
   997                          ;;                 jsr printmessage
   998                          
   999  a6f6 a000                       ldy #$00
  1000  a6f8 ab1300                     ldz <zptempv32+3        ;; BG what is in this register? Where is the data set?
  1001  a6fb 2035ab                     jsr printhex
  1002  a6fe ab1200                     ldz <zptempv32+2
  1003  a701 2035ab                     jsr printhex
  1004  a704 ab1100                     ldz <zptempv32+1
  1005  a707 2035ab                     jsr printhex
  1006  a70a ab1000                     ldz <zptempv32+0
  1007  a70d 2035ab                     jsr printhex
  1008                          
  1009                          dohickup:
  1010                                  ;; Use DMAgic to copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
  1011                                  ;; (We have to copy the routine to do this to RAM, since we will
  1012                                  ;; be replacing ourselves)
  1013  a710 a200                       ldx #$00
  1014  a712 bd1ea7             krc:        lda hickuproutine,x
  1015  a715 9d0030                     sta $3000,x
  1016  a718 e8                         inx
  1017  a719 d0f7                       bne krc
  1018  a71b 4c0030                     jmp $3000
  1019                          
  1020                          ;;         ========================
  1021                          
  1022                          hickuproutine:
  1023                                  ;; The following routine gets copied as-is to $3000 and run from there.
  1024                                  ;; The DMA list is still available in the hyppo ROM when it gets
  1025                                  ;; called, so we can just use it there, instead of working out where
  1026                                  ;; it gets copied to
  1027                          
  1028                                  ;; NOTE that only 256-bytes are copied, so the hickuproutine and hickupdmalist
  1029                                  ;;      cannot exceed this limit, else revise the krc routine.
  1030                          
  1031                                  ;; Set bottom 22 bits of DMA list address as for C65
  1032                                  ;; (8MB address range).  Hyppo ROM is at $FFF8000, so $FF goes
  1033                                  ;; in high-byte area
  1034                                  ;;
  1035  a71e a9ff                       lda #$ff
  1036  a720 8d02d7                     sta $d702
  1037  a723 a9ff                       lda #$ff
  1038  a725 8d04d7                     sta $d704  ;; dma list is in top MB of address space
  1039  a728 a9a7                       lda #>hickupdmalist
  1040  a72a 8d01d7                     sta $d701
  1041                                  ;; Trigger enhanced DMA
  1042  a72d a938                       lda #<hickupdmalist
  1043  a72f 8d05d7                     sta $d705
  1044                          
  1045                                  ;; copy complete, so mark ourselves upgraded, and jump into hypervisor
  1046                                  ;; as though we were just reset.
  1047                          
  1048                                  ;; (it doesn't matter what gets written to this register, it is just the fact that it has been
  1049                                  ;; written to, that sets the flag).
  1050                                  ;;
  1051  a732 8d7ed6                     sta hypervisor_hickedup_flag        ;; mark ourselves as having hicked up, (00=virgin, else already-hicked)
  1052  a735 4c0081                     jmp $8100
  1053                          
  1054                          ;;         ========================
  1055                          
  1056                          hickupdmalist:
  1057                                  ;; MEGA65 Enhanced DMA options
  1058  a738 0a                         !8 $0A  ;; Request format is F018A
  1059  a739 8000                       !8 $80,$00 ;; Source is $00xxxxx
  1060  a73b 81ff                       !8 $81,$FF ;; Destination is $FF
  1061  a73d 00                         !8 $00  ;; No more options
  1062                                  ;; copy $0004000-$0007FFF to $FFF8000-$FFFBFFF
  1063                                  ;; F018A DMA list
  1064                                  ;; (MB offsets get set in routine)
  1065  a73e 00                         !8 $00 ;; copy + last request in chain
  1066  a73f 0040                       !16 $4000 ;; size of copy is 16KB
  1067  a741 0040                       !16 $4000 ;; starting at $4000
  1068  a743 00                         !8 $00   ;; of bank $0
  1069  a744 0080                       !16 $8000 ;; destination address is $8000
  1070  a746 0f                         !8 $0F   ;; of bank $F
  1071  a747 0000                       !16 $0000 ;; modulo (unused)
  1072                          
  1073                          ;;         ========================
  1074                          
  1075                          cdroot_and_complain_if_fails:
  1076                          
  1077  a749 ae02bc                     ldx dos_default_disk
  1078  a74c 203c93                     jsr dos_cdroot
  1079  a74f b011                       bcs @cdroot_ok
  1080                          
  1081                                  ;; failed
  1082                                  ;;
  1083  a751 a22d                       ldx #<msg_cdrootfailed
  1084  a753 a0b3                       ldy #>msg_cdrootfailed
  1085  a755 20bcaa                     jsr printmessage
  1086  a758 a000                       ldy #$00
  1087  a75a abfcbc                     ldz dos_error_code
  1088  a75d 2035ab                     jsr printhex
  1089  a760 18                         clc
  1090  a761 60                         rts
  1091                          
  1092                                  +Checkpoint "FAILED CDROOT"
  1093                          @cdroot_ok:
  1094  a762 38                         sec
  1095  a763 60                         rts
  1096                          
  1097                          couldntopenhickup:
  1098                          
  1099                          nohickup:
  1100                          ;;                 ldx #<msg_nohickup
  1101                          ;;                 ldy #>msg_nohickup
  1102                          ;;                 jsr printmessage
  1103                          
  1104                          posthickup:
  1105                          
  1106                                  ;; MILESTONE: Have file system properties.
  1107                          
  1108                                  ;; Look for MEGA65.D81 to mount for F011 emulation
  1109                          
  1110                                  ;; print debug message
  1111                                  ;;
  1112                          !if DEBUG_HYPPO {
  1113                                  +Checkpoint "  Here we are POST-HICKUP"
  1114                          
  1115                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
  1116                          }
  1117                          
  1118                                  ;; for now indicate that there is no disk in drive
  1119                                  ;; (unless we notice that floppy access has been virtualised)
  1120  a764 ad59d6                     lda hypervisor_hardware_virtualisation
  1121  a767 2901                       and #$01
  1122  a769 d005                       bne f011Virtualised
  1123  a76b a900                       lda #$00
  1124  a76d 8d8bd6                     sta sd_f011_en        ;; f011 emulation
  1125                          f011Virtualised:
  1126                          
  1127                                  ;; Go to root directory on default disk
  1128                                  ;;
  1129  a770 2049a7                     jsr cdroot_and_complain_if_fails
  1130                          
  1131                                  ;; Re-set virtual screen row length after touching $D06F
  1132  a773 a950                       lda #80
  1133  a775 8d58d0                     sta $d058
  1134                          
  1135                                  ;; Check internal drive / SD card status, and don't mount D81 if set to use internal drive
  1136                                  ;; Not only would this be a waste of time, it also stomps the $D6A1 bit 0 that indicates
  1137                                  ;; to use the internal drive.
  1138                                  ;; this also assumes that nothing is going on with the second drive, and as no
  1139                                  ;; production has a second drive, we put it in a defined state by setting it as noreal
  1140                                  ;; TODO: add mount options for the second drive to configure
  1141  a778 a940                       lda #d81_image_flag_noreal
  1142  a77a 8d12bd                     sta currenttask_d81_image1_flags
  1143  a77d a900                       lda #0
  1144  a77f 8d14bd                     sta currenttask_d81_image1_namelen
  1145  a782 ada1d6                     lda $d6a1
  1146  a785 2901                       and #$01
  1147  a787 d01d                       bne @dontMountD81
  1148                          
  1149                                  ;; set name of file we are looking for
  1150                                  ;;
  1151  a789 a2dc                       ldx #<txt_MEGA65D81
  1152  a78b a0b3                       ldy #>txt_MEGA65D81
  1153  a78d 20d59b                     jsr dos_setname
  1154                          
  1155                                  ;; print debug message
  1156                                  ;;
  1157                                  +Checkpoint "  try-mounting MEGA65.D81"
  1158                          
  1159  a790 204a94                     jsr dos_findfile
  1160  a793 9014                       bcc d81attachfail
  1161  a795 20f093                     jsr dos_closefile
  1162                          
  1163  a798 a200                       ldx #$00
  1164  a79a 20019c                     jsr dos_attach
  1165  a79d 900a                       bcc d81attachfail
  1166                          
  1167  a79f a24f                       ldx #<msg_d81mounted
  1168  a7a1 a0b2                       ldy #>msg_d81mounted
  1169  a7a3 20bcaa                     jsr printmessage
  1170                          
  1171                                  ;; print debug message
  1172                                  ;;
  1173                                  +Checkpoint "  mounted MEGA65.D81"
  1174                          
  1175                          @dontMountD81:
  1176                                  ;; all done, move on to loading the ROM
  1177                                  ;;
  1178  a7a6 4c7aa8                     jmp loadrom
  1179                          
  1180                          ;;         ========================
  1181                          
  1182                          d81attachfail:
  1183                                  ;; we couldn't find the D81 file
  1184                                  ;; set no real drive flag
  1185  a7a9 a940                       lda #d81_image_flag_noreal
  1186  a7ab 8d11bd                     sta currenttask_d81_image0_flags
  1187  a7ae a900                       lda #0
  1188  a7b0 8d13bd                     sta currenttask_d81_image0_namelen
  1189                                  ;; and tell the user
  1190  a7b3 a230                       ldx #<msg_nod81
  1191  a7b5 a0b2                       ldy #>msg_nod81
  1192  a7b7 20bcaa                     jsr printmessage
  1193  a7ba a000                       ldy #$00
  1194  a7bc abfcbc                     ldz dos_error_code
  1195  a7bf 2035ab                     jsr printhex
  1196                          
  1197                                  ;; debug
  1198                                  +Checkpoint "couldnt mount/attach MEGA65.D81"
  1199                          
  1200  a7c2 4c7aa8                     jmp loadrom
  1201                          
  1202                          ;;         ========================
  1203                          
  1204                          tryloadbootlogofromflash:
  1205                          
  1206  a7c5 201fa8                     jsr setup_banner_load_pointer
  1207  a7c8 2018a2                     jsr sd_map_sectorbuffer
  1208                          
  1209                                  ;;  Check if we have BANNER.M65 embedded in flash.
  1210                          
  1211                                  ;; Load first sector of flash to check for banner present
  1212                                  ;; byte.
  1213  a7cb a900                       lda #$00
  1214  a7cd a203                       ldx #3
  1215                          @zoop:
  1216  a7cf 9d81d6                     sta $d681,x
  1217  a7d2 ca                         dex
  1218  a7d3 10fa                       bpl @zoop
  1219  a7d5 a953                       lda #$53
  1220  a7d7 8d80d6                     sta $d680
  1221                                  ;; Wait a little while for flash to read
  1222                          @zoop2:
  1223  a7da ca                         dex
  1224  a7db d0fd                       bne @zoop2
  1225  a7dd ad71de                     lda $de71
  1226  a7e0 c901                       cmp #$01
  1227  a7e2 f003                       beq loadbannerfromflash
  1228  a7e4 4c24a2                     jmp sd_unmap_sectorbuffer
  1229                          
  1230                          loadbannerfromflash:
  1231                                  ;; Load and display boot logo
  1232                                  ;; Logo will be at $7F8000-$7FFFFF
  1233                          
  1234  a7e7 a980                       lda #$80
  1235  a7e9 8d82d6                     sta $d682
  1236  a7ec a97f                       lda #$7f
  1237  a7ee 8d83d6                     sta $d683
  1238  a7f1 a900                       lda #$00
  1239  a7f3 8d81d6                     sta $d681
  1240  a7f6 8d84d6                     sta $d684
  1241                          
  1242  a7f9 2018a2                     jsr sd_map_sectorbuffer
  1243                          
  1244                          nextflashbannersector:
  1245                          
  1246  a7fc a953                       lda #$53
  1247  a7fe 8d80d6                     sta $d680
  1248                                  ;; No need to wait long here, because our copy routine is so slow
  1249                                  ;; Use the #$53 above
  1250                          @zzminus:
  1251  a801 3a                         dec
  1252  a802 10fd                       bpl @zzminus
  1253                                  ;; Leaves A=$00 which we use below for TAx/z to save bytes
  1254                          
  1255                          stashbannersector:
  1256                          
  1257                                  ;;  Advance $100 bytes to next flash sector
  1258  a804 ee82d6                     inc $d682
  1259                          
  1260  a807 a200                       ldx #0
  1261  a809 a300                       ldz #0
  1262                          
  1263                                  ;; Actually write the bytes to memory that have been loaded
  1264                          zdrfim_rr1:
  1265  a80b bd00de                     lda sd_sectorbuffer,x                ;; is $DE00
  1266  a80e ea9218                     sta [<dos_file_loadaddress],z
  1267  a811 1b                         inz ;; dest offset
  1268  a812 e8                         inx ;; src offset
  1269  a813 d0f6                       bne zdrfim_rr1
  1270                          
  1271  a815 e619                       inc <dos_file_loadaddress+1
  1272  a817 d0e3                       bne nextflashbannersector
  1273                          
  1274  a819 2024a2                     jsr sd_unmap_sectorbuffer
  1275                          
  1276                                  ;; Now display it
  1277  a81c 4c76aa                     jmp setbannerpalette
  1278                          
  1279                          
  1280                          setup_banner_load_pointer:
  1281                          
  1282                                  ;; Prepare 32-bit pointer for loading boot logo @ $0057D00
  1283                                  ;; (palette is $57D00-$57FFF, logo $58000-$5CFFF)
  1284  a81f a900                       lda #$00
  1285  a821 8518                       sta <dos_file_loadaddress+0
  1286  a823 a97d                       lda #$7d
  1287  a825 8519                       sta <dos_file_loadaddress+1
  1288  a827 a905                       lda #$05
  1289  a829 851a                       sta <dos_file_loadaddress+2
  1290  a82b a900                       lda #$00
  1291  a82d 851b                       sta <dos_file_loadaddress+3
  1292  a82f 60                         rts
  1293                          
  1294                          
  1295                          attempt_loadcharrom:
  1296                                  ;; Load CHARROM.M65 into character ROM
  1297                                  ;;
  1298  a830 a2c4                       ldx #<txt_CHARROMM65
  1299  a832 a0b3                       ldy #>txt_CHARROMM65
  1300  a834 20d59b                     jsr dos_setname
  1301                          
  1302                                  ;; Prepare 32-bit pointer for loading whole ROM ($FF7E000)
  1303                                  ;;
  1304  a837 a900                       lda #$00
  1305  a839 8518                       sta <dos_file_loadaddress+0
  1306  a83b a9e0                       lda #$E0
  1307  a83d 8519                       sta <dos_file_loadaddress+1
  1308  a83f a9f7                       lda #$F7
  1309  a841 851a                       sta <dos_file_loadaddress+2
  1310  a843 a90f                       lda #$0F
  1311  a845 851b                       sta <dos_file_loadaddress+3
  1312                          
  1313  a847 4c5099                     jmp dos_readfileintomemory
  1314                          
  1315                          attempt_loadc65rom:
  1316  a84a a2d0                       ldx #<txt_MEGA65ROM
  1317  a84c a0b3                       ldy #>txt_MEGA65ROM
  1318  a84e 20d59b                     jsr dos_setname
  1319                          
  1320                                  ;; Prepare 32-bit pointer for loading whole ROM ($0020000)
  1321                                  ;;
  1322  a851 a900                       lda #$00
  1323  a853 8518                       sta <dos_file_loadaddress+0
  1324  a855 8519                       sta <dos_file_loadaddress+1
  1325  a857 851b                       sta <dos_file_loadaddress+3
  1326  a859 a902                       lda #$02
  1327  a85b 851a                       sta <dos_file_loadaddress+2
  1328                          
  1329  a85d 4c5099                     jmp dos_readfileintomemory
  1330                          
  1331                          attempt_load1541rom:
  1332  a860 a2b8                       ldx #<txt_1541ROM
  1333  a862 a0b3                       ldy #>txt_1541ROM
  1334  a864 20d59b                     jsr dos_setname
  1335                          
  1336                                  ;; Prepare 32-bit pointer for loading whole ROM ($FFDC000)
  1337                                  ;;
  1338  a867 a900                       lda #$00
  1339  a869 8518                       sta <dos_file_loadaddress+0
  1340  a86b a9c0                       lda #$C0
  1341  a86d 8519                       sta <dos_file_loadaddress+1
  1342  a86f a9fd                       lda #$FD
  1343  a871 851a                       sta <dos_file_loadaddress+2
  1344  a873 a90f                       lda #$0F
  1345  a875 851b                       sta <dos_file_loadaddress+3
  1346                          
  1347  a877 4c5099                     jmp dos_readfileintomemory
  1348                          
  1349                          loadrom:
  1350                          
  1351                          !if DEBUG_HYPPO {
  1352                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
  1353                          }
  1354                          
  1355                                  ;; ROMs are not loaded, so try to load them, or prompt
  1356                                  ;; for user to insert SD card
  1357                                  ;;
  1358                          ;;                 ldx #<msg_rombad
  1359                          ;;                 ldy #>msg_rombad
  1360                          ;;                 jsr printmessage
  1361                          
  1362                                  ;; print debug message
  1363                                  ;;
  1364                                  +Checkpoint "  try-loading CHAR-ROM"
  1365                          
  1366  a87a 2030a8                     jsr attempt_loadcharrom
  1367  a87d b003                       bcs loadedcharromok
  1368                          
  1369  a87f 4c89a8                     jmp loadc65rom
  1370                          
  1371                          ;;         ========================
  1372                          
  1373                          loadedcharromok:
  1374                          !if DEBUG_HYPPO {
  1375                                  ;; print debug message
  1376                                  ;;
  1377                                  +Checkpoint "  OK-loading CHARROM"
  1378                          
  1379                                  ;; prepare debug message
  1380                                  ;;
  1381                                  ldx dos_current_file_descriptor_offset
  1382                                  lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0,x
  1383                                  sta file_pagesread
  1384                                  lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1,x
  1385                                  sta file_pagesread+1
  1386                          }
  1387                          
  1388  a882 a2a3                       ldx #<msg_charromloaded
  1389  a884 a0b0                       ldy #>msg_charromloaded
  1390  a886 20bcaa                     jsr printmessage
  1391                          
  1392                          
  1393                          loadc65rom:
  1394                          
  1395                          !if DEBUG_HYPPO {
  1396                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
  1397                          }
  1398                          
  1399                                  ;; print debug message
  1400                                  ;;
  1401                                  +Checkpoint "  try-loading MEGA65-ROM"
  1402                          
  1403  a889 204aa8                     jsr attempt_loadc65rom
  1404  a88c b021                       bcs loadedok
  1405                          
  1406                          ;;         ========================
  1407                          
  1408                                  ;; ROM not found: indicate which ROM we were looking for
  1409                                  ;;
  1410  a88e a20b                       ldx #$0b
  1411  a890 bdd0b3             l17d:   lda txt_MEGA65ROM,x
  1412  a893 9dc7b2                     sta msg_romnotfound+19,x
  1413  a896 ca                         dex
  1414  a897 d0f7                       bne l17d
  1415  a899 a2b4                       ldx #<msg_romnotfound
  1416  a89b a0b2                       ldy #>msg_romnotfound
  1417  a89d 20bcaa                     jsr printmessage
  1418                          
  1419  a8a0 20dba1                     jsr sdwaitawhile
  1420  a8a3 20dba1                     jsr sdwaitawhile
  1421  a8a6 20dba1                     jsr sdwaitawhile
  1422  a8a9 20dba1                     jsr sdwaitawhile
  1423                          
  1424  a8ac 4c5cab                     jmp go64
  1425                          
  1426                          ;;         ========================
  1427                          
  1428                                  ;; ROM was found and loaded
  1429                          loadedok:
  1430  a8af aefabc                     ldx dos_current_file_descriptor_offset
  1431  a8b2 bdc6bc                     lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset +0,x
  1432  a8b5 8d29bf                     sta file_pagesread
  1433  a8b8 bdc7bc                     lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset +1,x
  1434  a8bb 8d2abf                     sta file_pagesread+1
  1435                          
  1436                                  ;; check the size of the loaded file
  1437                                  ;; i.e., that we have loaded $0200 x $100 = $20000 = 128KiB
  1438  a8be ad2abf                     lda file_pagesread+1
  1439  a8c1 c900                       cmp #$00
  1440  a8c3 d003                       bne @romFileNotTooShort
  1441                          @romFileIsTooShort:
  1442  a8c5 4c2ea9                     jmp romfiletooshort
  1443                          @romFileNotTooShort:
  1444  a8c8 c901                       cmp #$01
  1445  a8ca f0f9                       beq @romFileIsTooShort
  1446  a8cc c902                       cmp #$02
  1447  a8ce d005                       bne @romFileIsTooLong
  1448  a8d0 ad29bf                     lda file_pagesread
  1449  a8d3 f003                       beq @romFileNotTooLong
  1450                          @romFileIsTooLong:
  1451  a8d5 4c21a9                     jmp romfiletoolong
  1452                          @romFileNotTooLong:
  1453                          
  1454                                  ;; the loaded ROM was OK in size
  1455                          
  1456  a8d8 200985                     jsr syspart_dmagic_autoset
  1457                          
  1458                                  ;; copy character ROM portion into place
  1459                                  ;; i.e., copy $2Dxxx to $FF7Exxx
  1460                          
  1461  a8db a9ff                       lda #$ff
  1462  a8dd 8d02d7                     sta $d702
  1463  a8e0 8d04d7                     sta $d704
  1464  a8e3 a900                       lda #$00
  1465  a8e5 a9a8                       lda #>charromdmalist
  1466  a8e7 8d01d7                     sta $d701
  1467  a8ea a9f2                       lda #<charromdmalist
  1468  a8ec 8d05d7                     sta $d705
  1469                          
  1470  a8ef 4c01a9                     jmp loadedmegaromok
  1471                          
  1472                          charromdmalist:
  1473                                  ;; M65 DMA options
  1474  a8f2 0a                         !8 $0A    ;; Request format is F018A
  1475  a8f3 81ff                       !8 $81,$FF ;; destination is $FFxxxxx
  1476  a8f5 00                         !8 $00 ;; no more options
  1477                                  ;; F018A DMA list
  1478  a8f6 00                         !8 $00
  1479  a8f7 0010                       !16 $1000
  1480  a8f9 00d0                       !16 $D000
  1481  a8fb 02                         !8 $02
  1482  a8fc 00e0                       !16 $E000
  1483  a8fe 07                         !8 $07
  1484  a8ff 0000                       !16 $0000
  1485                          
  1486                          loadedmegaromok:
  1487                          
  1488                          !if DEBUG_HYPPO {
  1489                                  ;; prepare debug message
  1490                                  ;;
  1491                                  ldx dos_current_file_descriptor_offset
  1492                                  lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+0,x
  1493                                  sta file_pagesread
  1494                                  lda dos_file_descriptors + dos_filedescriptor_offset_fileoffset+1,x
  1495                                  sta file_pagesread+1
  1496                          }
  1497                          
  1498  a901 a2b6                       ldx #<msg_megaromloaded
  1499  a903 a0b0                       ldy #>msg_megaromloaded
  1500  a905 20bcaa                     jsr printmessage
  1501                          
  1502                                  ;; ROM file loaded, transfer control
  1503                                  ;;
  1504  a908 a289                       ldx #<msg_romok
  1505  a90a a0b0                       ldy #>msg_romok
  1506  a90c 20bcaa                     jsr printmessage
  1507                          
  1508                                  ;; print debug message
  1509                                  ;;
  1510                                  +Checkpoint "  OK-loaded MEGA65-ROM"
  1511                          
  1512  a90f 2060a8                     jsr attempt_load1541rom
  1513  a912 b007                       bcs loaded1541rom
  1514                          
  1515                                  +Checkpoint "  FAIL loading 1541 ROM"
  1516                          
  1517  a914 a2d3                       ldx #<msg_no1541rom
  1518  a916 a0b2                       ldy #>msg_no1541rom
  1519  a918 20bcaa                     jsr printmessage
  1520                          
  1521                          loaded1541rom:
  1522                          !if DEBUG_HYPPO {
  1523                                  jsr dumpcurrentfd        ;; debugging to Checkpoint
  1524                          }
  1525                                  ;; check for keyboard input to jump to utility menu
  1526  a91b 20d3ac                     jsr utility_menu_check
  1527                          
  1528                                  ;; start system
  1529  a91e 4c5cab                     jmp go64
  1530                          
  1531                          ;;         ========================
  1532                          
  1533                          romfiletoolong:
  1534  a921 a2bd                       ldx #<msg_romfilelongerror
  1535  a923 a0b1                       ldy #>msg_romfilelongerror
  1536  a925 20bcaa                     jsr printmessage
  1537                          !if DEBUG_HYPPO {
  1538                                  ldz file_pagesread+1
  1539                                  jsr printhex
  1540                                  ldz file_pagesread
  1541                                  jsr printhex
  1542                          }
  1543  a928 20dba1                     jsr sdwaitawhile
  1544  a92b 4c2ba5                     jmp reset_entry
  1545                          
  1546                          romfiletooshort:
  1547  a92e a2dd                       ldx #<msg_romfileshorterror
  1548  a930 a0b1                       ldy #>msg_romfileshorterror
  1549  a932 20bcaa                     jsr printmessage
  1550                          !if DEBUG_HYPPO {
  1551                                  ldz file_pagesread+1
  1552                                  jsr printhex
  1553                                  ldz file_pagesread
  1554                                  jsr printhex
  1555                          }
  1556  a935 20dba1                     jsr sdwaitawhile
  1557  a938 4c2ba5                     jmp reset_entry
  1558                          
  1559                          ;;         ========================
  1560                          
  1561                          fileopenerror:
  1562  a93b a299                       ldx #<msg_fileopenerror
  1563  a93d a0b1                       ldy #>msg_fileopenerror
  1564  a93f 20bcaa                     jsr printmessage
  1565                          
  1566                          sdcarderror:
  1567  a942 a224                       ldx #<msg_sdcarderror
  1568  a944 a0b1                       ldy #>msg_sdcarderror
  1569  a946 20bcaa                     jsr printmessage
  1570                          
  1571  a949 20dba1                     jsr sdwaitawhile
  1572  a94c 4c2ba5                     jmp reset_entry
  1573                          
  1574                          ;;         ========================
  1575                          
  1576                          badfs:
  1577  a94f a25e                       ldx #<msg_badformat
  1578  a951 a0b1                       ldy #>msg_badformat
  1579  a953 20bcaa                     jsr printmessage
  1580                          
  1581  a956 20dba1                     jsr sdwaitawhile
  1582  a959 4c2ba5                     jmp reset_entry
  1583                          
  1584                          ;; /*  -------------------------------------------------------------------
  1585                          ;;     Display and basic IO routines
  1586                          ;;     ---------------------------------------------------------------- */
  1587                          
  1588                          resetdisplay:
  1589                                  ;; reset screen
  1590                                  ;;
  1591  a95c a940                       lda #$40        ;; 0100 0000 = choose charset
  1592  a95e 8d30d0                     sta $d030        ;; VIC-III Control Register A
  1593                          
  1594  a961 ad31d0                     lda $d031        ;; VIC-III Control Register B
  1595  a964 2940                       and #$40        ;; bit-6 is 4mhz
  1596  a966 8d31d0                     sta $d031
  1597                          
  1598  a969 a900                       lda #$00        ;; black
  1599  a96b 8d20d0                     sta $D020       ;; border
  1600  a96e 8d21d0                     sta $D021       ;; background
  1601  a971 8d11d7                     sta $D711         ;; Disable DMA audio
  1602                          
  1603                                  ;; Start in 60Hz mode, since most monitors support it
  1604                                  ;; (Also required to make sure matrix mode pixels aren't ragged on first boot).
  1605                                  ;; The label here is used so that the syspartition settings can be used to
  1606                                  ;; change the default video mode on reset.
  1607                          pal_ntsc_minus_1:
  1608  a974 a980                       lda #$80
  1609  a976 8d6fd0                     sta $d06f
  1610                          
  1611                                  ;; disable test pattern and various other strange video things that might be hanging around
  1612  a979 a980                       lda #$80
  1613  a97b 1c66d0                     trb $d066
  1614  a97e a900                       lda #$00
  1615  a980 8d6ad0                     sta $d06a ;; bank# for screen address
  1616  a983 8d6bd0                     sta $d06b ;; 16-colour sprites
  1617  a986 8d78d0                     sta $d078 ;; sprite Y super MSBs
  1618  a989 8d5fd0                     sta $d05f ;; sprite X super MSBs
  1619  a98c a978                       lda #$78
  1620  a98e 8d5ad0                     sta $d05a ;; correct horizontal scaling
  1621  a991 a9c0                       lda #$C0
  1622  a993 8d5dd0                     sta $D05D ;; enable hot registers, raster delay
  1623  a996 a950                       lda #80
  1624  a998 8d5cd0                     sta $D05C ;; Side border width LSB
  1625                          
  1626                                  ;; point VIC-IV to bottom 16KB of display memory
  1627                                  ;;
  1628  a99b a9ff                       lda #$ff
  1629  a99d 8d01dd                     sta $DD01
  1630  a9a0 8d00dd                     sta $DD00
  1631                          
  1632                                  ;; We use VIC-II style registers as this resets video frame in
  1633                                  ;; least instructions, and 40 columns is fine for us.
  1634                                  ;;
  1635  a9a3 a914                       lda #$14        ;; 0001 0100
  1636  a9a5 8d18d0                     sta $D018        ;; VIC-II Character/Screen location
  1637                          
  1638  a9a8 a91b                       lda #$1B        ;; 0001 1011
  1639  a9aa 8d11d0                     sta $D011        ;; VIC-II Control Register
  1640                          
  1641  a9ad a9c8                       lda #$C8        ;; 1100 1000
  1642  a9af 8d16d0                     sta $D016        ;; VIC-II Control Register
  1643                          
  1644                                  ;; Now switch to 16-bit text mode so that we can use proportional
  1645                                  ;; characters and full-colour characters for chars >$FF for the logo
  1646                                  ;; Also enable CRT emulation by default.
  1647                                  ;;
  1648  a9b2 a9e5                       lda #$e5
  1649  a9b4 8d54d0                     sta $d054        ;; VIC-IV Control Register C
  1650                          
  1651                                  ;; and 80 bytes (40 16-bit characters) per row.
  1652                                  ;;
  1653  a9b7 a950                       lda #<80
  1654  a9b9 8d58d0                     sta $d058
  1655  a9bc a900                       lda #>80
  1656  a9be 8d59d0                     sta $d059
  1657                          
  1658  a9c1 60                         rts
  1659                          
  1660                          ;;         ========================
  1661                          
  1662                          resetpalette:
  1663                                  ;; reset VIC-IV palette to sensible defaults.
  1664                                  ;; load C64 colours into palette bank 3 for use when
  1665                                  ;; PAL bit in $D030 is set.
  1666                                  ;;
  1667  a9c2 a904                       lda #$04
  1668  a9c4 0c30d0                     tsb $D030        ;; enable PAL bit in $D030
  1669                          
  1670  a9c7 2076aa                     jsr setbannerpalette
  1671                          
  1672                                  ;; C64 colours designed to look like C65 colours on an
  1673                                  ;; RGBI screen.
  1674  a9ca a20f                       ldx #$0F
  1675  a9cc bde2a9             -       lda c64_colours_table+$00,x     ; load & store red component
  1676  a9cf 9d00d1                     sta $D100,x
  1677  a9d2 bdf2a9                     lda c64_colours_table+$10,x     ; load & store green component
  1678  a9d5 9d00d2                     sta $D200,x
  1679  a9d8 bd02aa                     lda c64_colours_table+$20,x     ; load & store blue component
  1680  a9db 9d00d3                     sta $D300,x
  1681  a9de ca                         dex
  1682  a9df 10eb                       bpl -
  1683                          
  1684  a9e1 60                         rts
  1685                          
  1686                          c64_colours_table:
  1687                                  ;   0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | A | B | C | D | E | F
  1688  a9e2 00ffba66bb55d1ae...        !8 $00,$ff,$ba,$66,$bb,$55,$d1,$ae,$9b,$87,$dd,$b5,$b8,$0b,$aa,$8b  ; -- red
  1689  a9f2 00ff13adf3ece05f...        !8 $00,$ff,$13,$ad,$f3,$ec,$e0,$5f,$47,$37,$39,$b5,$b8,$4f,$d9,$8b  ; -- green
  1690  aa02 00ff62ff8b8579c7...        !8 $00,$ff,$62,$ff,$8b,$85,$79,$c7,$81,$00,$78,$b5,$b8,$ca,$fe,$8b  ; -- blue
  1691                          
  1692                          ;;         ========================
  1693                          
  1694                          ;; erase standard 40-column screen
  1695                          ;;
  1696                          erasescreen:
  1697                                  ;; bank in 2nd KB of colour RAM
  1698                                  ;;
  1699  aa12 a901                       lda #$01
  1700  aa14 0c30d0                     tsb $D030
  1701                          
  1702                                  ;; use DMA to clear screen and colour RAM
  1703                                  ;; The screen is in 16-bit bit mode, so we actually need to fill
  1704                                  ;; with $20,$00, ...
  1705                                  ;;
  1706                                  ;; We will cheat by setting the first four bytes, and then copying from
  1707                                  ;; there, and it will then read from the freshly written bytes.
  1708                                  ;; (two bytes might not be enough to allow the write from the last DMA
  1709                                  ;;  action to be avaialble for reading because of how the DMAgic is
  1710                                  ;;  pipelined).
  1711                                  ;;
  1712  aa17 a920                       lda #$20
  1713  aa19 8d0004                     sta $0400
  1714  aa1c 8d0204                     sta $0402
  1715  aa1f a900                       lda #$00
  1716  aa21 8d0104                     sta $0401
  1717  aa24 8d0304                     sta $0403
  1718                          
  1719                                  ;; Set bottom 22 bits of DMA list address as for C65
  1720                                  ;; (8MB address range)
  1721                                  ;;
  1722  aa27 a9ff                       lda #$ff
  1723  aa29 8d02d7                     sta $d702
  1724                          
  1725                                  ;; Hyppo ROM is at $FFFE000 - $FFFFFFF, so
  1726                                  ;; we need to tell DMAgic that DMA list is in $FFxxxxx.
  1727                                  ;; this has to be done AFTER writing to $d702, as $d702
  1728                                  ;; clears bits 27 - 22 of the DMA list address to help with
  1729                                  ;; compatibility.
  1730                                  ;;
  1731  aa2c a9ff                       lda #$ff
  1732  aa2e 8d04d7                     sta $d704
  1733                          
  1734  aa31 a9aa                       lda #>erasescreendmalist
  1735  aa33 8d01d7                     sta $d701
  1736                          
  1737                                  ;; set bottom 8 bits of address and trigger DMA.
  1738                                  ;;
  1739  aa36 a9a1                       lda #<erasescreendmalist
  1740  aa38 8d05d7                     sta $d705
  1741                          
  1742                                  ;; bank 2nd KB of colour RAM back out
  1743                                  ;;
  1744  aa3b a901                       lda #$01
  1745  aa3d 1c30d0                     trb $D030
  1746                          
  1747                          ;;         ========================
  1748                          
  1749                                  ;; move cursor back to top of the screen
  1750                                  ;; (but leave 8 rows for logo and banner text)
  1751                                  ;;
  1752  aa40 a908                       lda #$08
  1753  aa42 8d24bf                     sta screenrow
  1754                          
  1755                                  ;; draw 40x8 char block for banner
  1756                                  ;;
  1757  aa45 a000                       ldy #$00
  1758  aa47 a900                       lda #$00
  1759                          logo1:
  1760  aa49 990004                     sta $0400,y
  1761  aa4c 1a                         inc
  1762  aa4d c8                         iny
  1763  aa4e c8                         iny
  1764  aa4f d0f8                       bne logo1
  1765                          logo1a:
  1766  aa51 990005                     sta $0500,y
  1767  aa54 1a                         inc
  1768  aa55 c8                         iny
  1769  aa56 c8                         iny
  1770  aa57 d0f8                       bne logo1a
  1771                          logo1b:
  1772  aa59 990006                     sta $0600,y
  1773  aa5c 1a                         inc
  1774  aa5d c8                         iny
  1775  aa5e c8                         iny
  1776  aa5f c080                       cpy #$80
  1777  aa61 d0f6                       bne logo1b
  1778                          
  1779                                  ;; then write the high bytes for these (all $01, so char range will be
  1780                                  ;; $100-$140. $100 x $40 = $4000-$4FFF
  1781                                  ;;
  1782  aa63 a200                       ldx #$00
  1783  aa65 a916                       lda #$16     ;; $1600 x $40 = $58000 where banner tiles sit
  1784                          logo2:
  1785  aa67 9d0104                     sta $0401,x
  1786  aa6a 1a                         inc
  1787  aa6b 9d8105                     sta $0581,x
  1788  aa6e 3a                         dec
  1789  aa6f 9d0105                     sta $0501,x
  1790  aa72 e8                         inx
  1791  aa73 e8                         inx
  1792  aa74 d0f1                       bne logo2
  1793                          
  1794                                  ;; finally set palette for banner using contents of memory at $57D00-$57FFF
  1795                          setbannerpalette:
  1796  aa76 a9ff                       lda #$ff
  1797  aa78 8d70d0                     sta $D070        ;; select palette bank 3 for display and edit
  1798                          
  1799                                  ;; Set DMA list address
  1800                                  ;;
  1801  aa7b a9aa                       lda #>bannerpalettedmalist
  1802  aa7d 8d01d7                     sta $d701
  1803  aa80 a90f                       lda #$0f
  1804  aa82 8d02d7                     sta $d702 ;; DMA list address is $xxFxxxx
  1805  aa85 a9ff                       lda #$ff
  1806  aa87 8d04d7                     sta $d704 ;; DMA list address is $FFxxxxx
  1807                          
  1808                                  ;; set bottom bits of DMA list address and trigger enhanced DMA
  1809                                  ;;
  1810  aa8a a990                       lda #<bannerpalettedmalist
  1811  aa8c 8d05d7                     sta $d705
  1812                          
  1813  aa8f 60                         rts
  1814                          
  1815                          bannerpalettedmalist:
  1816                                  ;; MEGA65 enhanced DMA options
  1817  aa90 0a                         !8 $0A      ;; Request format is F018A
  1818  aa91 800081ff                   !8 $80,$00,$81,$FF ;; src = $00xxxxx, dst=$FFxxxxx
  1819  aa95 00                         !8 $00 ;; no more options
  1820                                  ;; F018A DMA list
  1821  aa96 00                         !8 $00   ;; COPY + no chained request
  1822  aa97 0003                       !16 $0300
  1823  aa99 007d                       !16 $7D00 ;;
  1824  aa9b 05                         !8 $05   ;; source bank 05
  1825  aa9c 0031                       !16 $3100 ;; ; $xxx3100
  1826  aa9e 0d                         !8 $0D   ;; ; $xxDxxxx
  1827  aa9f 0000                       !16 $0000 ;; modulo (unused)
  1828                          
  1829                          
  1830                          
  1831                          ;;         ========================
  1832                          
  1833                          erasescreendmalist:
  1834                                  ;; Clear screen RAM
  1835                                  ;;
  1836                                  ;; MEGA65 enhanced DMA options
  1837  aaa1 0a                         !8 $0A      ;; Request format is F018A
  1838  aaa2 00                         !8 $00 ;; no more options
  1839                                  ;; F018A DMA list
  1840  aaa3 04                         !8 $04   ;; COPY + chained request
  1841  aaa4 cc07                       !16 1996  ;; 40x25x2-4 = 1996
  1842  aaa6 0004                       !16 $0400 ;; copy from start of screen at $0400
  1843  aaa8 00                         !8 $00   ;; source bank 00
  1844  aaa9 0404                       !16 $0404 ;; ... to screen at $0402
  1845  aaab 00                         !8 $00   ;; screen is in bank $00
  1846  aaac 0000                       !16 $0000 ;; modulo (unused)
  1847                          
  1848                                  ;; Clear colour RAM
  1849                                  ;;
  1850                                  ;; MEGA65 DMA options
  1851  aaae 81ff                       !8 $81,$FF ;; Destination is $FFxxxxx
  1852  aab0 00                         !8 $00     ;; no more options
  1853                                  ;; F018A dma list
  1854  aab1 03                         !8 $03     ;; FILL + no more chained requests
  1855  aab2 d007                       !16 2000    ;; 40x25x2 = 2000
  1856  aab4 01                         !8 $01     ;; fill with white = $01
  1857  aab5 0000                       !8 $00,$00 ;; rest of source address is ignored in fill
  1858  aab7 0000                       !16 $0000   ;; destination address
  1859  aab9 08                         !8 $08     ;; destination bank
  1860  aaba 0000                       !16 $0000   ;; modulo (unused)
  1861                          
  1862                          
  1863                          ;;         ========================
  1864                          
  1865                          printmessage:        ;; HELPER routine
  1866                                  ;;
  1867                                  ;; This subroutine takes inputs from the X and Y registers,
  1868                                  ;; so set these registers before calling this subroutine,
  1869                                  ;; The X and Y registers need to point to a message as shown below:
  1870                                  ;;
  1871                                  ;;         ldx #<msg_foundsdcard
  1872                                  ;;         ldy #>msg_foundsdcard
  1873                                  ;;         jsr printmessage
  1874                                  ;;
  1875                                  ;; Ie: the X is the high-byte of the 16-bit address, and
  1876                                  ;;     the Y is the low-byte  of the 16-bit address.
  1877                          
  1878  aabc 860c                       stx <zptempp        ;; zptempp is 16-bit pointer to message
  1879  aabe 840d                       sty <zptempp+1
  1880                          
  1881  aac0 a900                       lda #$00
  1882  aac2 850e                       sta <zptempp2        ;; zptempp2 is 16-bit pointer to screen
  1883  aac4 a904                       lda #$04
  1884  aac6 850f                       sta <zptempp2+1
  1885                          
  1886  aac8 ae24bf                     ldx screenrow
  1887                          
  1888                                  ;; Makesure we can't accidentally write on row zero
  1889  aacb d002                       bne pm22
  1890  aacd a208                       ldx #$08
  1891                          pm22:
  1892                                  ;; if we have reached the bottom of the screen, start writing again
  1893                                  ;; from the top of the screen (but don't touch the top 8 rows for
  1894                                  ;; logo and banner)
  1895  aacf e019                       cpx #25
  1896  aad1 d008                       bne pm2
  1897                          
  1898  aad3 20e0ae                     jsr scroll_screen
  1899  aad6 a218                       ldx #24
  1900  aad8 8e24bf                     stx screenrow
  1901                          
  1902                                  ;; work out the screen address
  1903                                  ;;
  1904                          pm2:
  1905  aadb e000                       cpx #$00
  1906  aadd f010                       beq pm1
  1907                          
  1908  aadf 18                         clc
  1909  aae0 a50e                       lda <zptempp2
  1910  aae2 6950                       adc #$50          ;; 40 columns x 16 bit
  1911  aae4 850e                       sta <zptempp2
  1912  aae6 a50f                       lda <zptempp2+1
  1913  aae8 6900                       adc #$00
  1914  aaea 850f                       sta <zptempp2+1
  1915                          
  1916  aaec ca                 pm5:    dex
  1917  aaed d0ec                       bne pm2
  1918                          pm1:
  1919                          
  1920                                  ;; Clear line (16-bit chars, so write #$0020 to each word
  1921                                  ;;
  1922  aaef a000                       ldy #$00
  1923  aaf1 a920               pm1b:   lda #$20
  1924  aaf3 910e                       sta (<zptempp2),y
  1925  aaf5 c8                         iny
  1926  aaf6 a900                       lda #$00
  1927  aaf8 910e                       sta (<zptempp2),y
  1928  aafa c8                         iny
  1929  aafb c050                       cpy #$50
  1930  aafd d0f2                       bne pm1b
  1931                          
  1932                          writestring:
  1933  aaff db                         phz
  1934  ab00 a000                       ldy #$00
  1935  ab02 a300                       ldz #$00
  1936  ab04 b10c               pm3:    lda (<zptempp),y
  1937  ab06 f013                       beq endofmessage
  1938                          
  1939                                  ;; convert ASCII/PETSCII to screen codes
  1940                                  ;;
  1941  ab08 c940                       cmp #$40
  1942  ab0a 9002                       bcc pm4
  1943  ab0c 291f                       and #$1f
  1944                          
  1945                          pm4:                ;; write 16-bit character code
  1946                                  ;;
  1947  ab0e 920e                       sta (<zptempp2),z
  1948  ab10 1b                         inz
  1949  ab11 48                         pha
  1950  ab12 a900                       lda #$00
  1951  ab14 920e                       sta (<zptempp2),z
  1952  ab16 68                         pla
  1953  ab17 c8                         iny
  1954  ab18 1b                         inz
  1955  ab19 d0e9                       bne pm3
  1956                          endofmessage:
  1957  ab1b ee24bf                     inc screenrow
  1958                          
  1959                          !if DEBUG_HYPPO {
  1960                                  ;; XXX DEBUG
  1961                                  ;; Require key press after each line displayed.
  1962                          ;;        jsr debug_wait_on_key
  1963                          }
  1964                          
  1965  ab1e fb                         plz
  1966  ab1f 60                         rts
  1967                          
  1968                          printbanner:
  1969  ab20 860c                       stx <zptempp
  1970  ab22 840d                       sty <zptempp+1
  1971  ab24 a904                       lda #<$0504
  1972  ab26 8d0ebf                     sta zptempp2
  1973  ab29 a905                       lda #>$0504
  1974  ab2b 8d0fbf                     sta zptempp2+1
  1975  ab2e 20ffaa                     jsr writestring
  1976  ab31 ce24bf                     dec screenrow
  1977  ab34 60                         rts
  1978                          
  1979                          ;;         ========================
  1980                          
  1981                          printhex:
  1982                                  ;; helper function
  1983                                  ;;
  1984                                  ;; seems to want to print the value if the z-reg onto the previous line written to the screen,
  1985                                  ;; so currently the screen consists of say "mounted $$ images"
  1986                                  ;; and this routine will go and change the "$$" to the value in the z-reg
  1987                                  ;;
  1988                                  ;; BG: surely this can be replaced with updating the "$$" before printing the string
  1989                                  ;;
  1990                                  ;; INPUT: .Y, BG seems to be an offset, should be set to zero?
  1991                                  ;; INPUT: .Z, value in Z-reg to be displayed omn the screen
  1992                                  ;;
  1993  ab35 6b                         tza
  1994  ab36 4a                         lsr
  1995  ab37 4a                         lsr
  1996  ab38 4a                         lsr
  1997  ab39 4a                         lsr
  1998  ab3a 2040ab                     jsr printhexdigit
  1999  ab3d 6b                         tza
  2000  ab3e 290f                       and #$0f
  2001                          printhexdigit:
  2002                                  ;; find next $ sign to replace with hex digit
  2003                                  ;;
  2004  ab40 aa                         tax
  2005  ab41 b10e               phd3:   lda (<zptempp2),y
  2006  ab43 c924                       cmp #$24
  2007  ab45 f007                       beq phd2
  2008  ab47 c8                         iny
  2009  ab48 c8                         iny
  2010  ab49 c050                       cpy #$50
  2011  ab4b 90f4                       bcc phd3
  2012  ab4d 60                         rts
  2013                          
  2014  ab4e 8a                 phd2:   txa
  2015  ab4f 0930                       ora #$30
  2016  ab51 c93a                       cmp #$3a
  2017  ab53 9002                       bcc phd1
  2018  ab55 e939                       sbc #$39
  2019  ab57 910e               phd1:   sta (<zptempp2),y
  2020  ab59 c8                         iny
  2021  ab5a c8                         iny
  2022  ab5b 60                         rts
  2023                          
  2024                          ;;         ========================
  2025                          
  2026                          go64:
  2027                          
  2028                          ;; Transfer control to C64 kernel.
  2029                          ;; (This also allows entry to C65 mode, because the
  2030                          ;;  C64-mode kernel on the C65 checks if C65 mode
  2031                          ;;  should be entered.)
  2032                          
  2033                                  ;; Prevent utility menu from being launched
  2034  ab5c a94c                       lda #$4c
  2035  ab5e 8d70ad                     sta utility_menu
  2036                          
  2037                                  ;; Prevent flash menu from being launched
  2038  ab61 a94c                       lda #$4c
  2039  ab63 8d78a5                     sta first_boot_flag_instruction
  2040                          
  2041                                  ;; Warn user if dipswitch 3 is on
  2042  ab66 ad9dd6                     lda $d69d
  2043  ab69 2904                       and #$04
  2044  ab6b f018                       beq l41
  2045  ab6d a28d                       ldx #<msg_dipswitch3on
  2046  ab6f a0b2                       ldy #>msg_dipswitch3on
  2047  ab71 20bcaa                     jsr printmessage
  2048                          l40a:
  2049                                  ;; Wait for user to press RUN/STOP to continue booting
  2050  ab74 ad10d6                     lda ascii_key_in
  2051  ab77 f007                       beq l40b
  2052  ab79 c903                       cmp #$03
  2053  ab7b f008                       beq l41
  2054  ab7d 8d10d6                     sta ascii_key_in
  2055                          l40b:
  2056  ab80 ee20d0                     inc $d020
  2057  ab83 80ef                       bra l40a
  2058                          l41:
  2059                                  ;; remove RUN/STOP from key queue
  2060  ab85 8d10d6                     sta ascii_key_in
  2061                          
  2062                                  ;; Check if hold boot switch is set (control-key)
  2063                                  ;;
  2064  ab88 ad11d6                     lda buckykey_status
  2065  ab8b 2904                       and #$04
  2066  ab8d f00e                       beq l42      ;; no, so continue
  2067                          
  2068                                  ;; yes, display message
  2069                                  ;;
  2070  ab8f a268                       ldx #<msg_releasectrl
  2071  ab91 a0b2                       ldy #>msg_releasectrl
  2072  ab93 20bcaa                     jsr printmessage
  2073                          
  2074                                  ;; wait until CTRL is released
  2075                          @holdControl:
  2076  ab96 ad11d6                     lda buckykey_status
  2077  ab99 2904                       and #$04
  2078  ab9b d0f9                       bne @holdControl
  2079                          
  2080                          l42:
  2081                                  ;; unmap sector buffer so C64 can see CIAs
  2082                                  ;;
  2083  ab9d a982                       lda #$82
  2084  ab9f 8d80d6                     sta sd_ctrl
  2085                          
  2086                                  ;; copy routine to stack to switch to
  2087                                  ;; C64 memory map and enter via reset
  2088                                  ;; vector.
  2089                          
  2090                                  ;; erase hyppo ROM copy from RAM
  2091                                  ;; (well, at least enough so that BASIC doesn't get upset)
  2092                                  ;; XXX - use DMA
  2093                                  ;;
  2094  aba2 a200                       ldx #$00
  2095  aba4 8a                         txa
  2096  aba5 9d0008             g61:    sta $0800,x
  2097  aba8 e8                         inx
  2098  aba9 d0fa                       bne g61
  2099                          
  2100  abab a928                       lda #<40
  2101  abad 8d58d0                     sta $d058
  2102  abb0 a900                       lda #>40
  2103  abb2 8d59d0                     sta $d059
  2104                          
  2105                                  ;; write protect ROM RAM
  2106  abb5 a904                       lda #$04
  2107  abb7 0c7dd6                     tsb hypervisor_feature_enables
  2108                          
  2109  abba 204d9f                     jsr task_set_c64_memorymap
  2110  abbd 20c29f                     jsr task_set_pc_to_reset_vector
  2111  abc0 20e69f                     jsr task_dummy_nmi_vector
  2112                          
  2113                                  ;; Enable cartridge again
  2114  abc3 a902                       lda #$02
  2115  abc5 0cfbd7                     tsb $d7fb
  2116                          
  2117                                  ;; This must happen last, so that the ultimax cartridge
  2118                                  ;; reset vector is used, instead of the one in the loaded ROM
  2119  abc8 20f7ab                     jsr setup_for_ultimax_cartridge
  2120                          
  2121                                  ;; Apply RESET to cartridge for a little while so that cartridges
  2122                                  ;; with capacitors tied to EXROM or GAME are visible.
  2123                                  ;; Do this last, because some cartridges remain visible for as little
  2124                                  ;; as 512 usec.
  2125  abcb 20d1ab                     jsr reset_cartridge
  2126                          
  2127                          go64_exit_hypervisor:
  2128                                  ;; exit from hypervisor to start machine
  2129  abce 8d7fd6                     sta hypervisor_enterexit_trigger
  2130                          

; ******** Source: ultimax.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          reset_cartridge:
     6  abd1 a300                       ldz #$00
     7  abd3 a900                       lda #<$0000
     8  abd5 8d10bf                     sta zptempv32+0
     9  abd8 8d11bf                     sta zptempv32+1
    10  abdb a901                       lda #<$0701
    11  abdd 8d12bf                     sta zptempv32+2
    12  abe0 a907                       lda #>$0701
    13  abe2 8d13bf                     sta zptempv32+3
    14  abe5 a920                       lda #$20
    15  abe7 ea9210                     sta [<zptempv32],z
    16  abea a000                       ldy #$00
    17                          charge_delay:
    18  abec 1b                         inz
    19  abed d0fd                       bne charge_delay
    20  abef c8                         iny
    21  abf0 d0fa                       bne charge_delay
    22  abf2 6b                         tza
    23  abf3 ea9210                     sta [<zptempv32],z
    24  abf6 60                         rts
    25                          
    26                          setup_for_ultimax_cartridge:
    27  abf7 ad7ed6                     lda hypervisor_cartridge_flags
    28  abfa 2960                       and #$60
    29  abfc c940                       cmp #$40
    30  abfe f001                       beq is_ultimax_cartridge
    31  ac00 60                         rts
    32                          
    33                          is_ultimax_cartridge:
    34                                  ;; It's an ultimax cartridge, so we have a couple of things to
    35                                  ;; handle differently.
    36                                  ;;
    37                                  ;; 1. Read reset vector directly from $FFFx, where it will be
    38                                  ;;    currently visible.
    39                                  ;; 2. Copy $F000-$FFFF to $3xxx, $7xxx, $Bxxx and $Fxxx in 1st
    40                                  ;;    64KB of RAM to simulate the way that a C64 makes the top
    41                                  ;;    4KB of Ultimax mode ROMs visible to the VIC-II at these
    42                                  ;;    locations.
    43                                  ;;
    44                                  ;; This means copying from $701Fxxx to $000{3,7,B,F}xxx, as DMA
    45                                  ;; doesn't see mapped ROMs.
    46                                  ;;
    47                                  ;; (We  use one list 4x with different destination, as it uses
    48                                  ;; less bytes than a chained DMA list with all four.)
    49  ac01 adfcff                     lda reset_vector
    50  ac04 8d48d6                     sta hypervisor_pcl
    51  ac07 adfdff                     lda reset_vector+1
    52  ac0a 8d49d6                     sta hypervisor_pch
    53                          
    54                                  ;; Use DMA to quickly do the copy
    55  ac0d a9ac                       lda #>ultimaxsetup_dmalist
    56  ac0f 8d01d7                     sta $d701
    57  ac12 a90f                       lda #$0f
    58  ac14 8d02d7                     sta $d702 ;; DMA list is $xxFxxxx
    59  ac17 a9ff                       lda #$ff
    60  ac19 8d04d7                     sta $d704 ;; DMA list address is $FFxxxxx
    61                          
    62                                  ;; Run list 4 times with different destination addresses
    63  ac1c a930                       lda #$30
    64  ac1e a22e                       ldx #<ultimaxsetup_dmalist
    65                          ultimax_setup_loop:
    66  ac20 8d3aac                     sta ultimaxsetup_destination+1
    67                          
    68                                  ;; Trigger MEGA65 enhanced DMA
    69  ac23 8e05d7                     stx $d705
    70  ac26 18                         clc
    71  ac27 6940                       adc #$40
    72  ac29 c930                       cmp #$30
    73  ac2b d0f3                       bne ultimax_setup_loop
    74                          
    75  ac2d 60                         rts
    76                          
    77                          ultimaxsetup_dmalist:
    78                                  ;; MEGA65 Enhanced DMA options
    79  ac2e 8070                       !8 $80,$70   ;; copy from $70xxxxx
    80  ac30 8100                       !8 $81,$00   ;; copy to $01xxxxx
    81  ac32 00                         !8 $00       ;; end of options
    82                          
    83                                  ;; F018A dma list
    84  ac33 00                         !8 $00       ;; COPY, no chain
    85  ac34 0010                       !16 $1000     ;; 4KB
    86                          
    87                                  ;; source address
    88  ac36 00f0                       !16 $F000     ;; source is $xxxF000
    89  ac38 01                         !8 $01       ;; source is $xx1xxxx
    90                          
    91                          ultimaxsetup_destination:
    92  ac39 0030                       !16 $3000     ;; destination is $xxx3000 (gets changed by routine above)
    93  ac3b 00                         !8 $00       ;; destination is $xx03000
    94  ac3c 0000                       !8 $00,00    ;; Modulo

; ******** Source: src/hyppo/main.asm
  2132                          
  2133                          ;;         ========================
  2134                          
  2135                          ;; BG: the longpeek subroutine does not get called from hyppo,
  2136                          ;;     it gets called only from the hyppo_task file,
  2137                          ;;     so i suggest moving this subroutine to that file.
  2138                          
  2139                          longpeek:
  2140                                  ;; Use DMAgic to read any byte of RAM in 28bit address space.
  2141                                  ;; Value gets read into $BC00 (hyppo_scratchbyte0)
  2142                                  ;; ($FFFBC00 - $FFFBDFF)
  2143                          
  2144                                  ;; Patch DMA list
  2145                                  ;;
  2146  ac3e 8e68ac                     stx longpeekdmalist_src_lsb
  2147  ac41 8c69ac                     sty longpeekdmalist_src_2sb
  2148  ac44 9c6aac                     stz longpeekdmalist_src_msb
  2149  ac47 8d61ac                     sta longpeekdmalist_src_mb
  2150                          
  2151                                  ;; Set DMA list address
  2152                                  ;;
  2153  ac4a a9ac                       lda #>longpeekdmalist
  2154  ac4c 8d01d7                     sta $d701
  2155  ac4f a90f                       lda #$0f
  2156  ac51 8d02d7                     sta $d702 ;; DMA list address is $xxFxxxx
  2157  ac54 a9ff                       lda #$ff
  2158  ac56 8d04d7                     sta $d704 ;; DMA list address is $FFxxxxx
  2159                          
  2160                                  ;; set bottom bits of DMA list address and trigger enhanced DMA
  2161                                  ;;
  2162  ac59 a95f                       lda #<longpeekdmalist
  2163  ac5b 8d05d7                     sta $d705
  2164  ac5e 60                         rts
  2165                          
  2166                          longpeekdmalist:
  2167                                  ;; MEGA65 Enhanced DMA options
  2168  ac5f 0a                         !8 $0A      ;; Request format is F018A
  2169  ac60 80                         !8 $80
  2170                          longpeekdmalist_src_mb:
  2171  ac61 ff                         !8 $FF
  2172  ac62 81ff                       !8 $81,$FF ;; destination is always $FFxxxxx
  2173  ac64 00                         !8 $00 ;; end of options marker
  2174                                  ;; F018A format request follows
  2175  ac65 00                         !8 $00 ;; COPY, no chain
  2176                                  ;; 1 byte
  2177  ac66 0100                       !16 $0001
  2178                                  ;; source address
  2179                          longpeekdmalist_src_lsb:
  2180  ac68 00                         !8 $00
  2181                          longpeekdmalist_src_2sb:
  2182  ac69 00                         !8 $00
  2183                          longpeekdmalist_src_msb:
  2184  ac6a 00                         !8 $00
  2185                                  ;; destination address ($xxFBC00)
  2186  ac6b 00bc                       !16 hyppo_scratchbyte0
  2187  ac6d 0f                         !8 $0F
  2188  ac6e 0000                       !8 $00,00 ;; Modulo
  2189                          
  2190                          longpoke:
  2191                                  ;; Use DMAgic to write any byte of RAM in C65 1MB address space.
  2192                                  ;; A = value
  2193                                  ;; X = Address LSB
  2194                                  ;; Y = Address MidB
  2195                                  ;; Z = Address Bank
  2196                          
  2197                                  ;; Patch DMA list
  2198                                  ;;
  2199  ac70 8da5ac                     sta longpokevalue
  2200  ac73 8ea8ac                     stx longpokeaddress+0
  2201  ac76 8ca9ac                     sty longpokeaddress+1
  2202  ac79 9caaac                     stz longpokeaddress+2
  2203  ac7c 6b                         tza
  2204  ac7d 4a                         lsr
  2205  ac7e 4a                         lsr
  2206  ac7f 4a                         lsr
  2207  ac80 4a                         lsr
  2208  ac81 8da0ac                     sta longpokedmalist_dest_mb ;; DMAgic destination MB
  2209                                  ;; and enable F108B enhanced mode by default
  2210  ac84 a901                       lda #$01
  2211  ac86 8d03d7                     sta $d703
  2212                          
  2213                                  ;; Set DMA list address
  2214                                  ;;
  2215  ac89 a9ac                       lda #>longpokedmalist
  2216  ac8b 8d01d7                     sta $d701
  2217  ac8e a90f                       lda #$0f
  2218  ac90 8d02d7                     sta $d702 ;; DMA list address is $xxFxxxx
  2219  ac93 a9ff                       lda #$ff
  2220  ac95 8d04d7                     sta $d704 ;; DMA list address is $FFxxxxx
  2221                          
  2222                                  ;; set bottom bits of DMA list address and trigger enhhanced DMA
  2223                                  ;;
  2224                          
  2225  ac98 a99e                       lda #<longpokedmalist
  2226  ac9a 8d05d7                     sta $d705
  2227  ac9d 60                         rts
  2228                          
  2229                          longpokedmalist:
  2230                                  ;; MEGA65 Enhanced DMA option list
  2231  ac9e 0a                         !8 $0A      ;; Request format is F018A
  2232  ac9f 81                         !8 $81
  2233                          longpokedmalist_dest_mb:
  2234  aca0 00                         !8 $00
  2235  aca1 00                         !8 $00 ;; no more enhanced DMA options
  2236                                  ;; F018A dma list
  2237  aca2 03                         !8 $03 ;; FILL, no chain
  2238                                  ;; 1 byte
  2239  aca3 0100                       !16 $0001
  2240                                  ;; source address (LSB = fill value)
  2241                          longpokevalue:
  2242  aca5 00                         !8 $00
  2243  aca6 0000                       !16 $0000
  2244                                  ;; destination address
  2245                          longpokeaddress:
  2246  aca8 0000                       !16 $0000
  2247  acaa 0f                         !8 $0F
  2248  acab 0000                       !8 $00,00 ;; Modulo
  2249                          
  2250                          
  2251                          ;;         ========================
  2252                          
  2253                          ;; reset memory map to default
  2254                          resetmemmap:
  2255                                  ;; clear memory MAP MB offset register
  2256                                  ;;
  2257  acad a900                       lda #$00
  2258  acaf a20f                       ldx #$0f
  2259  acb1 a000                       ldy #$00   ;; keep hyppo mapped at $8000-$BFFF
  2260  acb3 a33f                       ldz #$3f
  2261                          
  2262  acb5 5c                         map
  2263                          
  2264                                  ;; and clear all mapping
  2265                                  ;;
  2266  acb6 aa                         tax
  2267  acb7 a000                       ldy #$00   ;; keep hyppo mapped at $8000-$BFFF
  2268  acb9 a33f                       ldz #$3f
  2269                          
  2270  acbb 5c                         map
  2271  acbc ea                         eom
  2272                          
  2273  acbd 60                         rts
  2274                          
  2275                          ;;         ========================

; ******** Source: keyboard.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                          ;; peek first key in accelerated key buffer, without removing it
     7                          ;; carry set if not key found (A is 0 in that case)
     8                          ;; keycode is in accumulator
     9                          peekkeyboard:
    10                                  ;; We now use hardware-accelerated keyboard reading
    11  acbe ad10d6                     lda ascii_key_in
    12  acc1 c900                       cmp #$00
    13  acc3 f002                       beq nokey
    14  acc5 18                         clc
    15  acc6 60                         rts
    16                          nokey:  ;; no key currently down, so set carry and return
    17  acc7 38                         sec
    18  acc8 60                         rts
    19                          
    20                          ;; get first key from accelerated key buffer, removing it from queue
    21                          ;; accumulater holds key
    22                          ;; carry set if no key was in buffer (A is 0 in that case)
    23                          scankeyboard:
    24  acc9 20beac                     jsr peekkeyboard
    25  accc b0f9                       bcs nokey
    26                                  ;; clear key from buffer
    27  acce 8d10d6                     sta ascii_key_in
    28  acd1 18                         clc
    29  acd2 60                         rts

; ******** Source: src/hyppo/main.asm
  2277                          
  2278                          utility_menu_check:
  2279  acd3 ad11d6                     lda buckykey_status
  2280  acd6 c920                       cmp #$20 ;; NO-SCROLL
  2281  acd8 f00c                       beq @startFlashMenu
  2282  acda c903                       cmp #$03 ;; both SHIFT
  2283  acdc f005                       beq @startUtilMenu
  2284  acde 2910                       and #$10 ;; ALT
  2285  ace0 d001                       bne @startUtilMenu
  2286                          @menuCheckDone:
  2287  ace2 60                         rts
  2288                          @startUtilMenu:
  2289  ace3 4c70ad                     jmp utility_menu
  2290                          @startFlashMenu:
  2291                                  ;; ... but only if available
  2292  ace6 ad78a5                     lda first_boot_flag_instruction
  2293  ace9 c94c                       cmp #$4c
  2294  aceb f003                       beq @flashMenuNoAvail
  2295  aced 4c7ba5                     jmp launch_flash_menu
  2296                          @flashMenuNoAvail:
  2297  acf0 4cd5a5                     jmp noflash_menu
  2298                          
  2299                          keyboardread:
  2300                          
  2301                          ;; Check for keyboard activity, and change which ROM we intend to read
  2302                          ;; based on that, i.e., holding any key down during boot will load MEGA65<that character>.ROM instead of MEGA65.ROM
  2303                          
  2304  acf3 20d3ac                     jsr utility_menu_check
  2305                          
  2306  acf6 a201                       ldx #$01
  2307  acf8 ad29d6                     lda $d629
  2308  acfb 2940                       and #$40
  2309  acfd f002                       beq @startscan
  2310  acff a2ff                       ldx #$ff    ;; for nexys-range of boards, repeat check for keyboard input in a short loop
  2311                          
  2312                          @startscan:
  2313  ad01 20c9ac                     jsr scankeyboard
  2314  ad04 9006                       bcc @checkkey
  2315                                  ;; no key pressed yet
  2316  ad06 ca                         dex
  2317  ad07 d0f8                       bne @startscan
  2318  ad09 4c14ad                     jmp kr2  ;; no key was pressed, despite looping for a while to wait for it
  2319                          
  2320                          @checkkey:
  2321  ad0c c930                       cmp #$30
  2322  ad0e 9004                       bcc kr2
  2323  ad10 c93a                       cmp #$3a
  2324  ad12 9002                       bcc kr1
  2325  ad14 a920               kr2:    lda #$20 ;; default to space
  2326                          kr1:
  2327                                  ;; put character into 6th byte position of ROM file name.
  2328                                  ;; so no key looks for MEGA65.ROM, where as 0-9 will look
  2329                                  ;; for MEGA65x.ROM, where x is the number.
  2330  ad16 a206                       ldx #6
  2331  ad18 c920                       cmp #$20
  2332  ad1a f004                       beq default_rom
  2333  ad1c 9dd0b3                     sta txt_MEGA65ROM,x
  2334  ad1f e8                         inx
  2335                          default_rom:
  2336  ad20 a92e                       lda #'.'
  2337  ad22 9dd0b3                     sta txt_MEGA65ROM,x
  2338  ad25 e8                         inx
  2339  ad26 a952                       lda #'R'
  2340  ad28 9dd0b3                     sta txt_MEGA65ROM,x
  2341  ad2b e8                         inx
  2342  ad2c a94f                       lda #'O'
  2343  ad2e 9dd0b3                     sta txt_MEGA65ROM,x
  2344  ad31 e8                         inx
  2345  ad32 a94d                       lda #'M'
  2346  ad34 9dd0b3                     sta txt_MEGA65ROM,x
  2347  ad37 e8                         inx
  2348  ad38 a900                       lda #0
  2349  ad3a 9dd0b3                     sta txt_MEGA65ROM,x
  2350                          
  2351  ad3d 60                         rts
  2352                          
  2353                          ;;         ========================
  2354                          
  2355                          hypervisor_nmi:
  2356                          hypervisor_irq:
  2357                                  ;; Default interrupt handlers for hypervisor: for now just mask the
  2358                                  ;; interrupt source.  Later we can have raster splits in the boot
  2359                                  ;; display if we so choose.
  2360  ad3e 78                         sei
  2361  ad3f 40                         rti
  2362                          
  2363                          hypervisor_setup_copy_region:
  2364                                  ;; Hypervisor copy region sit entirely within the first 32KB of
  2365                                  ;; mapped address space. Since we allow a 256 byte copy region,
  2366                                  ;; we limit the start address to the range $0000-$7EFF
  2367                                  ;; XXX - We should also return an error if there is an IO
  2368                                  ;; region mapped there, so that the hypervisor can't be tricked
  2369                                  ;; into doing privileged IO operations as part of the copy-back
  2370                          
  2371  ad40 ad42d6                     lda hypervisor_y
  2372  ad43 300e                       bmi hscr1
  2373  ad45 c97f                       cmp #$7f
  2374  ad47 f00a                       beq hscr1
  2375  ad49 8d07bf                     sta hypervisor_userspace_copy_vector +1
  2376  ad4c a900                       lda #$00
  2377  ad4e 8d06bf                     sta hypervisor_userspace_copy_vector +0
  2378                          
  2379                                  +Checkpoint "hypervisor_setup_copy_region <success>"
  2380                          
  2381  ad51 38                         sec
  2382  ad52 60                         rts
  2383                          
  2384                          hscr1:
  2385                                  +Checkpoint "hypervisor_setup_copy_region <failure>"
  2386                          
  2387  ad53 a910                       lda #dos_errorcode_invalid_address
  2388  ad55 4c1d93                     jmp dos_return_error
  2389                          
  2390                          ;;         ========================
  2391                          
  2392                          !if DEBUG_HYPPO {
  2393                          
  2394                          checkpoint:
  2395                          
  2396                                  ;; Routine to record the progress of code through the hypervisor for
  2397                                  ;; debugging problems in the hypervisor.
  2398                                  ;; If the JSR checkpoint is followed by $00, then a text string describing the
  2399                                  ;; checkpoint is inserted into the checkpoint log.
  2400                                  ;; Checkpoint data is recorded in the 2nd 16KB of colour RAM.
  2401                          
  2402                                  ;; Save all registers and CPU flags
  2403                                  sta checkpoint_a
  2404                                  stx checkpoint_x
  2405                                  sty checkpoint_y
  2406                                  stz checkpoint_z
  2407                                  php
  2408                                  pla
  2409                                  sta checkpoint_p
  2410                          
  2411                                  ;; pull PC return address from stack
  2412                                  ;; (JSR pushes return_address-1, so add one)
  2413                                  pla
  2414                                  clc
  2415                                  adc #$01
  2416                                  sta checkpoint_pcl
  2417                                  pla
  2418                                  adc #$00
  2419                                  sta checkpoint_pch
  2420                          
  2421                                  ;; Only do checkpoints visibly if shift held during boot
  2422                                  lda buckykey_status
  2423                                  and #$03
  2424                                  beq cp9
  2425                          
  2426                                  ;; Write checkpoint byte values out as hex into message template
  2427                                  ldx checkpoint_a
  2428                                  jsr checkpoint_bytetohex
  2429                                  sty msg_checkpoint_a+0
  2430                                  stx msg_checkpoint_a+1
  2431                          
  2432                                  ldx checkpoint_x
  2433                                  jsr checkpoint_bytetohex
  2434                                  sty msg_checkpoint_x+0
  2435                                  stx msg_checkpoint_x+1
  2436                          
  2437                                  ldx checkpoint_y
  2438                                  jsr checkpoint_bytetohex
  2439                                  sty msg_checkpoint_y+0
  2440                                  stx msg_checkpoint_y+1
  2441                          
  2442                                  ldx checkpoint_z
  2443                                  jsr checkpoint_bytetohex
  2444                                  sty msg_checkpoint_z+0
  2445                                  stx msg_checkpoint_z+1
  2446                          
  2447                                  ldx checkpoint_p
  2448                                  jsr checkpoint_bytetohex
  2449                                  sty msg_checkpoint_p+0
  2450                                  stx msg_checkpoint_p+1
  2451                          
  2452                                  ldx checkpoint_pch
  2453                                  jsr checkpoint_bytetohex
  2454                                  sty msg_checkpoint_pc+0
  2455                                  stx msg_checkpoint_pc+1
  2456                          
  2457                                  ldx checkpoint_pcl
  2458                                  jsr checkpoint_bytetohex
  2459                                  sty msg_checkpoint_pc+2
  2460                                  stx msg_checkpoint_pc+3
  2461                          
  2462                                  ;; Clear out checkpoint message
  2463                                  ldx #59
  2464                                  lda #$20
  2465                          cp4:    sta msg_checkpointmsg,x
  2466                                  dex
  2467                                  bpl cp4
  2468                          cp9:
  2469                                  ;; Read next byte following the return address to see if it is $00,
  2470                                  ;; if so, then also store the $00-terminated text message that follows.
  2471                                  ;; e.g.:
  2472                                  ;;
  2473                                  ;; jsr checkpoint
  2474                                  ;; !8 0,"OPEN DIRECTORY",0
  2475                                  ;;
  2476                                  ;; to record a checkpoint with the string "OPEN DIRECTORY"
  2477                          
  2478                                  ldy #$00
  2479                                  lda (<checkpoint_pcl),y
  2480                          
  2481                                  bne nocheckpointmessage
  2482                          
  2483                                  ;; Copy null-terminated checkpoint string
  2484                                  ldx #$00
  2485                                  iny
  2486                          cp3:    lda (<checkpoint_pcl),y
  2487                                  beq endofcheckpointmessage
  2488                                  sta msg_checkpointmsg,x
  2489                                  inx
  2490                                  iny
  2491                                  cpy #60
  2492                                  bne cp3
  2493                          
  2494                                  ;; flush out any excess bytes at end of message
  2495                          cp44:   lda (<checkpoint_pcl),y
  2496                                  beq endofcheckpointmessage
  2497                                  iny
  2498                                  bra cp44
  2499                          
  2500                          endofcheckpointmessage:
  2501                                  ;; Skip $00 at end of message
  2502                                  iny
  2503                          
  2504                          nocheckpointmessage:
  2505                          
  2506                                  ;; Advance return address following any checkpoint message
  2507                                  tya
  2508                                  clc
  2509                                  adc checkpoint_pcl
  2510                                  sta checkpoint_pcl
  2511                                  lda checkpoint_pch
  2512                                  adc #$00
  2513                                  sta checkpoint_pch
  2514                          
  2515                                  ;; Only do checkpoints visibly if shift key held
  2516                                  lda buckykey_status
  2517                                  and #$03
  2518                                  beq checkpoint_return
  2519                          
  2520                                  ;; output checkpoint message to serial monitor
  2521                                  ldx #0
  2522                                  ;; do not adjust x-reg until label "checkpoint_return"
  2523                          cp5:
  2524                                  ;; wait for uart to be not busy
  2525                                  lda hypervisor_write_char_to_serial_monitor        ;; LSB is busy status
  2526                                  bne cp5                ;; branch if busy (LSB=1)
  2527                          
  2528                                  ;; uart is not busy, so write the char
  2529                                  lda msg_checkpoint,x
  2530                                  sta hypervisor_write_char_to_serial_monitor
  2531                                  inx
  2532                          
  2533                                  cmp #10                ;; compare A-reg with "LineFeed"
  2534                                  bne cp5
  2535                          
  2536                          checkpoint_return:
  2537                                  ;; restore registers
  2538                                  lda checkpoint_p
  2539                                  php
  2540                                  lda checkpoint_a
  2541                                  ldx checkpoint_x
  2542                                  ldy checkpoint_y
  2543                                  ldz checkpoint_z
  2544                                  plp
  2545                          
  2546                                  ;; return by jumping to the
  2547                                  jmp (checkpoint_pcl)
  2548                          
  2549                          ;;         ========================
  2550                          
  2551                          checkpoint_bytetohex:
  2552                          
  2553                                  ;; BG: this is a helper function to convert a HEX-byte to
  2554                                  ;;     its equivalent two-byte char representation
  2555                                  ;;
  2556                                  ;;     input ".X", containing a HEX-byte to convert
  2557                                  ;;   outputs ".X" & ".Y", Y is MSB, X is LSB, print YX
  2558                                  txa
  2559                                  and #$f0
  2560                                  lsr
  2561                                  lsr
  2562                                  lsr
  2563                                  lsr
  2564                                  jsr checkpoint_nybltohex
  2565                                  tay
  2566                                  txa
  2567                                  and #$0f
  2568                                  jsr checkpoint_nybltohex
  2569                                  tax
  2570                                  rts
  2571                          
  2572                          ;;         ========================
  2573                          
  2574                          checkpoint_nybltohex:
  2575                          
  2576                                  and #$0f
  2577                                  ora #$30
  2578                                  cmp #$3a
  2579                                  bcs cpnth1
  2580                                  rts
  2581                          
  2582                          cpnth1: adc #$06
  2583                                  rts
  2584                          
  2585                          } ;; !if DEBUG_HYPPO
  2586                          
  2587                          
  2588                          ;;         ========================
  2589                          ;;       Scan the 32KB colour RAM looking for pre-loaded utilities.
  2590                          ;;       Offer for the user to be able to launch one of them
  2591                          
  2592                                  ;; Tell user what to do if they can't access the utility menu
  2593                          noutility_menu:
  2594  ad58 a2ba                       ldx #<msg_noutilitymenu
  2595  ad5a a0af                       ldy #>msg_noutilitymenu
  2596  ad5c 20bcaa                     jsr printmessage
  2597  ad5f ee20d0                     inc $d020
  2598                          num1:
  2599  ad62 4c62ad                     jmp num1
  2600                          
  2601                          safe_video_mode:
  2602                                  ;; No digital audio, just pure DVI
  2603  ad65 a902                       lda #$02
  2604  ad67 8d1ad6                     sta $d61a
  2605                                  ;; NTSC
  2606  ad6a a980                       lda #$80
  2607  ad6c 8d6fd0                     sta $d06f
  2608  ad6f 60                         rts
  2609                          
  2610                          utility_menu:
  2611                                  ;; Gets self-modified to prevent entering utility menu except on first boot
  2612  ad70 2c58ad                     bit noutility_menu
  2613                          
  2614                                  ;; Disable digital audio when utility menu
  2615  ad73 2065ad                     jsr safe_video_mode
  2616                          
  2617                                  ;; Display GIT commit again, so that it's easy to check commit of a build
  2618  ad76 a298                       ldx #<msg_gitcommit
  2619  ad78 a0b3                       ldy #>msg_gitcommit
  2620  ad7a 20bcaa                     jsr printmessage
  2621                          
  2622                                  ;; Display utility menu message
  2623  ad7d a2a1                       ldx #<msg_utilitymenu
  2624  ad7f a0af                       ldy #>msg_utilitymenu
  2625  ad81 20bcaa                     jsr printmessage
  2626                          
  2627                                  ;; First utility will be number 1
  2628  ad84 a930                       lda #$30
  2629  ad86 8d08bf                     sta zptempv
  2630                          
  2631  ad89 2085af                     jsr utillist_rewind
  2632                          
  2633                          um1:
  2634  ad8c 204daf                     jsr utillist_validity_check
  2635  ad8f 9030                       bcc utility_end_of_list
  2636                          
  2637                                  ;; Display utility and assign number
  2638  ad91 a027                       ldy #39
  2639  ad93 a920                       lda #$20
  2640  ad95 9914af             um2:    sta msg_utility_item,y
  2641  ad98 88                         dey
  2642  ad99 c002                       cpy #2
  2643  ad9b d0f8                       bne um2
  2644  ad9d c8                         iny
  2645  ad9e ee08bf                     inc zptempv
  2646  ada1 ad08bf                     lda zptempv
  2647  ada4 8d14af                     sta msg_utility_item
  2648  ada7 a304                       ldz #4
  2649  ada9 eab210             um4:    lda [<zptempv32],z
  2650  adac 9914af                     sta msg_utility_item,y
  2651  adaf f004                       beq um3
  2652  adb1 c8                         iny
  2653  adb2 1b                         inz
  2654  adb3 80f4                       bra um4
  2655  adb5 a214               um3:    ldx #<msg_utility_item
  2656  adb7 a0af                       ldy #>msg_utility_item
  2657  adb9 20bcaa                     jsr printmessage
  2658                          
  2659  adbc 203caf                     jsr utillist_next
  2660                          
  2661  adbf 80cb                       bra um1
  2662                          
  2663                          
  2664                          utility_end_of_list:
  2665                                  ;; XXX Get input from user (accept only numbers 1 - 9)
  2666  adc1 20c9ac                     jsr scankeyboard
  2667  adc4 c9ff                       cmp #$ff
  2668  adc6 f0f9                       beq utility_end_of_list
  2669  adc8 c931                       cmp #$31
  2670  adca 90f5                       bcc utility_end_of_list
  2671  adcc c939                       cmp #$39
  2672  adce b0f1                       bcs utility_end_of_list
  2673                          
  2674                                  ;; XXX Based on input, find that utility
  2675  add0 290f                       and #$f
  2676  add2 aa                         tax
  2677  add3 ca                         dex ;; input is 1-9, so subtract one for list beginning at 0
  2678  add4 2085af                     jsr utillist_rewind
  2679  add7 204daf             ueol2:  jsr utillist_validity_check
  2680                                  ;; Select again if first choice invalid
  2681  adda 90e5                       bcc utility_end_of_list
  2682  addc ca                         dex
  2683  addd 3005                       bmi ueol1
  2684  addf 203caf                     jsr utillist_next
  2685  ade2 80f3                       bra ueol2
  2686                          ueol1:
  2687                          
  2688  ade4 ee21d0                     inc $d021
  2689                          
  2690                                  ;; XXX - Set hardware protection bits based on utility definition
  2691                                  ;;       (and check that utility memory has not been modified. If modified.
  2692                                  ;;        give an error instead of giving privileges, so that there is no
  2693                                  ;;        privilege escalation vulnerability here.)
  2694                                  ;; XXX - In fact, if the utility memory has been modified, we shouldn't even
  2695                                  ;;       offer the menu at all perhaps?
  2696                          
  2697                                  ;; Load selected utility into memory
  2698                                  ;; length @ offset 36
  2699  ade7 a324                       ldz #36
  2700  ade9 eab210                     lda [<zptempv32],z
  2701  adec 8d0aaf                     sta utility_dmalist_length+0
  2702  adef 1b                         inz
  2703  adf0 eab210                     lda [<zptempv32],z
  2704  adf3 8d0baf                     sta utility_dmalist_length+1
  2705  adf6 a510                       lda <zptempv32+0
  2706  adf8 18                         clc
  2707  adf9 692c                       adc #44 ;; length of header structure
  2708  adfb 8d0caf                     sta utility_dmalist_srcaddr+0
  2709  adfe a511                       lda <zptempv32+1
  2710  ae00 6900                       adc #0
  2711  ae02 8d0daf                     sta utility_dmalist_srcaddr+1
  2712                          
  2713                                  ;; We have to call this before initialising OpenROM
  2714  ae05 206eae                     jsr setup_for_openrom
  2715                          
  2716                                  ;; load address is always $07FF (to skip $0801 header)
  2717                                  ;; start @ zptempv32 + 44
  2718                                  ;; DMA list is from Hypervisor ROM, so DMA list address MB also = $FF
  2719  ae08 a9ff                       lda #$ff
  2720  ae0a 8d02d7                     sta $d702
  2721  ae0d 8d04d7                     sta $d704
  2722  ae10 a9af                       lda #>utility_dmalist
  2723  ae12 8d01d7                     sta $d701
  2724  ae15 a903                       lda #<utility_dmalist
  2725  ae17 8d05d7                     sta $d705       ;; Trigger enhanced DMA
  2726                          
  2727                                  ;; clear 16-bit char mode
  2728  ae1a a905                       lda #$05        ;; 0000 0101
  2729  ae1c 1c54d0                     trb $d054       ;; VIC-IV Control Register C
  2730                          
  2731                                  ;; and 40 bytes (40 8-bit characters) per row.
  2732  ae1f a928                       lda #<40
  2733  ae21 8d58d0                     sta $d058
  2734  ae24 a900                       lda #>40
  2735  ae26 8d59d0                     sta $d059
  2736                          
  2737                                  ;; screen at $0800 for debug
  2738  ae29 a925                       lda #$25
  2739  ae2b 8d18d0                     sta $d018
  2740                          
  2741                                  ;; Exit hypervisor, with PC set to entry point of utility
  2742  ae2e a326                       ldz #38
  2743  ae30 eab210                     lda [<zptempv32],z
  2744  ae33 8d48d6                     sta hypervisor_pcl
  2745  ae36 1b                         inz
  2746  ae37 eab210                     lda [<zptempv32],z
  2747  ae3a 8d49d6                     sta hypervisor_pch
  2748                          
  2749  ae3d 204d9f                     jsr task_set_c64_memorymap
  2750  ae40 a93f                       lda #$3f
  2751  ae42 8d50d6                     sta hypervisor_cpuport00
  2752  ae45 a936                       lda #$36 ;; IO + Kernel ROM @ $E000 (will be OpenROM KERNAL)
  2753  ae47 8d51d6                     sta hypervisor_cpuport01
  2754                          
  2755                                  ;; Next instruction exits hypervisor to user mode
  2756  ae4a 8d7fd6                     sta hypervisor_enterexit_trigger
  2757                          
  2758                          flash_menu:
  2759                          
  2760                                  ;; Run the flash menu which is pre-loaded into memory on first boot
  2761                                  ;; (in the FPGA BRAM).
  2762                                  ;; Also DMA copy our current screen safely somewhere for later restoration
  2763                          
  2764  ae4d a9ff                       lda #$ff
  2765  ae4f 8d02d7                     sta $d702
  2766                                  ;; lda #$ff
  2767  ae52 8d04d7                     sta $d704  ;; dma list is in top MB of address space
  2768  ae55 a9ae                       lda #>flashmenu_dmalist
  2769  ae57 8d01d7                     sta $d701
  2770                                  ;; Trigger enhanced DMA
  2771  ae5a a9b3                       lda #<flashmenu_dmalist
  2772  ae5c 8d05d7                     sta $d705
  2773                          
  2774                                  ;; FALL THROUGH
  2775                          run_util_in_hypervisor_context:
  2776                                  ;; XXX Move Stack and ZP to normal places, before letting C64 KERNAL loose on
  2777                                  ;; Hypervisor memory map!
  2778  ae5f a900                       lda #$00
  2779  ae61 5b                         tab
  2780  ae62 a001                       ldy #$01
  2781  ae64 2b                         tys
  2782                          
  2783  ae65 206eae                     jsr setup_for_openrom
  2784                                  ;; XXX Work around bug in OpenROMs that erases our banner palette when we do this
  2785                                  ;; by putting the palette back immediately.
  2786  ae68 2076aa                     jsr setbannerpalette
  2787                          
  2788                                  ;; Actually launch the utility in the hypervisor context
  2789                                  ;; (so must not use RAM > $7FFF, is immune to freezing etc)
  2790  ae6b 4c0d08                     jmp $080d
  2791                          
  2792                          setup_for_openrom:
  2793                          
  2794                                  ;; Bank in KERNAL ROM space so megaflash can run
  2795                                  ;; Writing to $01 when ZP is relocated is a bit tricky, as
  2796                                  ;; we have to mess about with the Base Register, or force
  2797                                  ;; the assembler to do an absolute write.
  2798  ae6e a937                       lda #$37
  2799  ae70 8d0100                     !8 $8d,$01,$00 ;; ABS STA $0001
  2800                          
  2801                                  ;; We should also reset video mode to normal
  2802  ae73 a997                       lda #$97
  2803  ae75 1c54d0                     trb $d054
  2804                          
  2805                                  ;; Clear memory map at $4000-5FFF
  2806                                  ;; (Why on earth do we even map some of the HyperRAM there, anyway???)
  2807  ae78 a900                       lda #0
  2808  ae7a aa                         tax
  2809  ae7b a8                         tay
  2810  ae7c a33f                       ldz #$3f
  2811  ae7e 5c                         map
  2812  ae7f ea                         eom
  2813                                  ;; And set MB low to $00, so that OpenROM doesn't jump into lala land
  2814  ae80 a900                       lda #0
  2815  ae82 a20f                       ldx #$0f
  2816  ae84 5c                         map
  2817  ae85 ea                         eom
  2818                          
  2819                                  ;; Tell KERNAL screen is at $0400
  2820  ae86 a904                       lda #>$0400
  2821  ae88 8d8802                     sta $0288
  2822                          
  2823  ae8b adf9ff                     lda $fff9
  2824  ae8e c9ff                       cmp #$ff
  2825  ae90 f003                       beq @notOpenROM
  2826                                  ;; OpenROMs setup (XXX Won't work with Commodore C65 ROMs!)
  2827  ae92 22f8ff                     jsr ($fff8)
  2828                          @notOpenROM:
  2829                                  ;; make sure not in quote mode etc
  2830  ae95 a900                       lda #$00
  2831  ae97 85d8                       sta $d8 ;; number of insertions outstanding = 0
  2832  ae99 850f                       sta $0f ;; clear quote mode
  2833                          
  2834                                  ;; Clear common interrupt sources
  2835                          
  2836                                  ;; CIAs
  2837                          ;;        lda #$ff
  2838                          ;;        sta $dc0d
  2839                          ;;        sta $dd0d
  2840                          ;;        lda $dc0d
  2841                          ;;        lda $dd0d
  2842                          
  2843                                  ;; VIC-IV
  2844                          ;;        dec $d019
  2845                          ;;        lda #$00
  2846                          ;;        sta $d01a
  2847                          
  2848                                  ;; Ethernet
  2849                          ;;        lda #$00
  2850                          ;;        sta $d6e1
  2851                          
  2852                                  ;; C65 UART
  2853                                  ;; XXX Actually it can't generate interrupts yet, so nothing to do :)
  2854                          
  2855                                  ;; Finally, clear any pending interrupts by using MAP instruction
  2856                          ;;        tax
  2857                          ;;        tay
  2858                          ;;        taz
  2859                          ;;        map
  2860                          ;;        lda #0    ;; to give time to effect clearing irq_pending in CPU
  2861                          ;;        eom
  2862                          
  2863                                  ;; And ignore any queued NMI (these don't get cleared by the MAP trick)
  2864                          
  2865                                  ;;  Clear pending NMI flag
  2866  ae9b ad7dd6                     lda hypervisor_feature_enables
  2867  ae9e 297f                       and #$7f
  2868  aea0 8d7dd6                     sta hypervisor_feature_enables
  2869                          
  2870                                  ;; Set safety-net NMI handler
  2871  aea3 a940                       lda #$40
  2872  aea5 8d2004                     sta $0420
  2873  aea8 a920                       lda #<$0420
  2874  aeaa 8d1803                     sta $0318
  2875  aead a904                       lda #>$0420
  2876  aeaf 8d1903                     sta $0319
  2877  aeb2 60                         rts
  2878                          
  2879                          flashmenu_dmalist:
  2880                                  ;; copy $50000-$577FF to $00007FF-$0007FFFF
  2881                          
  2882                                  ;; MEGA65 Enhanced DMA options
  2883  aeb3 0a                         !8 $0A      ;; Request format is F018A
  2884  aeb4 8000                       !8 $80,$00  ;; Copy from $00xxxxx
  2885  aeb6 8100                       !8 $81,$00  ;; Copy to $00xxxxx
  2886                          
  2887                                  ;; Copy screen from $0400-$0BFF to $00009000
  2888  aeb8 00                         !8 $00 ;; no more options
  2889                                  ;; F018A DMA list
  2890  aeb9 04                         !8 $04 ;; copy + chained
  2891  aeba 0008                       !16 $0800 ;; size of copy
  2892  aebc 0004                       !16 $0400 ;; starting addr
  2893  aebe 00                         !8 $00   ;; of bank $0
  2894  aebf 0090                       !16 $9000 ;; destination address is $8000
  2895  aec1 00                         !8 $00   ;; of bank $5
  2896  aec2 0000                       !16 $0000 ;; modulo (unused)
  2897                          
  2898                                  ;; Copy program down
  2899  aec4 00                         !8 $00 ;; no more options
  2900                                  ;; F018A DMA list
  2901  aec5 00                         !8 $00 ;; copy + not chained request
  2902  aec6 ff77                       !16 $77FF ;; size of copy
  2903  aec8 0000                       !16 $0000 ;; starting addr
  2904  aeca 05                         !8 $05   ;; of bank $5
  2905  aecb ff07                       !16 $07FF ;; destination address is $0801 - 2
  2906  aecd 00                         !8 $00   ;; of bank $0
  2907  aece 0000                       !16 $0000 ;; modulo (unused)
  2908                          
  2909                          screenrestore_dmalist:
  2910  aed0 8000                       !8 $80,$00  ;; Copy from $00xxxxx
  2911  aed2 8100                       !8 $81,$00  ;; Copy to $00xxxxx
  2912  aed4 00                         !8 $00 ;; no more options
  2913                                  ;; F018A DMA list
  2914  aed5 00                         !8 $00 ;; copy + last in chain
  2915  aed6 0008                       !16 $0800 ;; size of copy
  2916  aed8 0090                       !16 $9000 ;; destination address is $0000
  2917  aeda 00                         !8 $00   ;; of bank $0
  2918  aedb 0004                       !16 $0400 ;; starting addr
  2919  aedd 00                         !8 $00   ;; of bank $5
  2920  aede 0000                       !16 $0000 ;; modulo (unused)
  2921                          
  2922                          scroll_screen:
  2923                          
  2924  aee0 a9ff                       lda #$ff
  2925  aee2 8d02d7                     sta $d702
  2926  aee5 8d04d7                     sta $d704  ;; dma list is in top MB of address space
  2927                          
  2928                                  ;; Don't forget to reset colour RAM also
  2929  aee8 a9ae                       lda #>scrollscreen_dmalist
  2930  aeea 8d01d7                     sta $d701
  2931                                  ;; set bottom 8 bits of address and trigger DMA.
  2932                                  ;;
  2933  aeed a9f3                       lda #<scrollscreen_dmalist
  2934  aeef 8d05d7                     sta $d705
  2935                          
  2936  aef2 60                         rts
  2937                          
  2938                          scrollscreen_dmalist:
  2939  aef3 8000                       !8 $80,$00  ;; Copy from $00xxxxx
  2940  aef5 8100                       !8 $81,$00  ;; Copy to $00xxxxx
  2941  aef7 00                         !8 $00 ;; no more options
  2942                                  ;; F018A DMA list
  2943  aef8 00                         !8 $00 ;; copy + last in chain
  2944  aef9 0005                       !16 1280 ;; size of copy  ( (17-1) * 40 * 2 )
  2945  aefb d006                       !16 1744 ;; src address is line 9 of screen
  2946  aefd 00                         !8 $00   ;; of bank $0
  2947  aefe 8006                       !16 1664 ;; starting addr is line 8 of screen
  2948  af00 00                         !8 $00   ;; of bank $0
  2949  af01 0000                       !16 $0000 ;; modulo (unused)
  2950                          
  2951                          
  2952                          utility_dmalist:
  2953                                  ;; copy $FF8xxxx-$FF8yyyy to $00007FF-$000xxxx
  2954                          
  2955                                  ;; MEGA65 Enhanced DMA options
  2956  af03 0a                         !8 $0A      ;; Request format is F018A
  2957  af04 80ff                       !8 $80,$FF  ;; Copy from $FFxxxxx
  2958  af06 8100                       !8 $81,$00  ;; Copy to $00xxxxx
  2959  af08 00                         !8 $00 ;; no more options
  2960                                  ;; F018A DMA list
  2961  af09 00                         !8 $00 ;; copy + last request in chain
  2962                          utility_dmalist_length:
  2963  af0a ffff                       !16 $FFFF ;; size of copy  (gets overwritten)
  2964                          utility_dmalist_srcaddr:
  2965  af0c ffff                       !16 $FFFF ;; starting addr (gets overwritten)
  2966  af0e 08                         !8 $08   ;; of bank $8
  2967  af0f ff07                       !16 $07FF ;; destination address is $0801 - 2
  2968  af11 00                         !8 $00   ;; of bank $0
  2969  af12 0000                       !16 $0000 ;; modulo (unused)
  2970                          
  2971                          
  2972                          msg_utility_item:
  2973  af14 312e203332204348...        !text "1. 32 CHARACTERS OF UTILITY NAME...    "
  2974  af3b 00                         !8 0
  2975                          
  2976                          utillist_next:
  2977                          
  2978                                  ;; Advance pointer to the next pointer
  2979  af3c a32a                       ldz #42
  2980  af3e eab210                     lda [<zptempv32],z
  2981  af41 da                         phx
  2982  af42 aa                         tax
  2983  af43 1b                         inz
  2984  af44 eab210                     lda [<zptempv32],z
  2985                                  ;; XXX - Make sure it can't point earlier into the colour RAM here
  2986                          
  2987  af47 8511                       sta <zptempv32+1
  2988  af49 8610                       stx <zptempv32
  2989  af4b fa                         plx
  2990  af4c 60                         rts
  2991                          
  2992                          utillist_validity_check:
  2993                                  ;; See if this is a valid utility entry
  2994  af4d a300                       ldz #0
  2995                          
  2996                                  ;; Check for magic value
  2997  af4f eab210                     lda [<zptempv32],z
  2998  af52 c94d                       cmp #'M'
  2999  af54 d02d                       bne ulvc_fail
  3000  af56 1b                         inz
  3001  af57 eab210                     lda [<zptempv32],z
  3002  af5a c936                       cmp #'6'
  3003  af5c d025                       bne ulvc_fail
  3004  af5e 1b                         inz
  3005  af5f eab210                     lda [<zptempv32],z
  3006  af62 c935                       cmp #'5'
  3007  af64 d01d                       bne ulvc_fail
  3008  af66 1b                         inz
  3009  af67 eab210                     lda [<zptempv32],z
  3010  af6a c955                       cmp #'U'
  3011  af6c d015                       bne ulvc_fail
  3012                          
  3013                                  ;; Check self address
  3014  af6e a328                       ldz #40
  3015  af70 eab210                     lda [<zptempv32],z
  3016  af73 cd10bf                     cmp zptempv32
  3017  af76 d00b                       bne ulvc_fail
  3018  af78 1b                         inz
  3019  af79 eab210                     lda [<zptempv32],z
  3020  af7c cd11bf                     cmp zptempv32+1
  3021  af7f d002                       bne ulvc_fail
  3022                          
  3023                                  ;; success
  3024  af81 38                         sec
  3025  af82 60                         rts
  3026                          
  3027                          ulvc_fail:
  3028  af83 18                         clc
  3029  af84 60                         rts
  3030                          
  3031                          utillist_rewind:
  3032                          
  3033                                  ;; Set pointer to first entry in colour RAM ($0850)
  3034  af85 a950                       lda #<$0850
  3035  af87 8510                       sta <zptempv32
  3036  af89 a908                       lda #>$0850
  3037  af8b 8511                       sta <(zptempv32+1)
  3038  af8d a9f8                       lda #<$0FF8
  3039  af8f 8512                       sta <(zptempv32+2)
  3040  af91 a90f                       lda #>$0FF8
  3041  af93 8513                       sta <(zptempv32+3)
  3042                          
  3043  af95 60                         rts
  3044                          
  3045                          serialwrite:
  3046                                  ;; write character to serial port
  3047                          
  3048                                  ;; First wait for it to go ready
  3049  af96 ae7cd6                     ldx hypervisor_write_char_to_serial_monitor
  3050  af99 d0fb                       bne serialwrite
  3051                          
  3052                                  ;; XXX - Have some kind of permission control on this
  3053                                  ;; XXX - $D67C should not work when matrix mode is enabled at all?
  3054  af9b 8d7cd6                     sta hypervisor_write_char_to_serial_monitor
  3055  af9e 8d7fd6                     sta hypervisor_enterexit_trigger
  3056                          
  3057                          ;;         ========================
  3058                          
  3059                          !if DEBUG_HYPPO {
  3060                          
  3061                          ;; checkpoint message
  3062                          
  3063                          msg_checkpoint:         !text "$"
  3064                          msg_checkpoint_pc:      !text "%%%% A:"
  3065                          msg_checkpoint_a:       !text "%%, X:"
  3066                          msg_checkpoint_x:       !text "%%, Y:"
  3067                          msg_checkpoint_y:       !text "%%, Z:"
  3068                          msg_checkpoint_z:       !text "%%, P:"
  3069                          msg_checkpoint_p:       !text "%% :"
  3070                          msg_checkpointmsg:      !text "                                                             " ;; END_OF_STRING
  3071                                                  !8 13,10  ;; CR/LF
  3072                          
  3073                          }
  3074                          
  3075                          ;;         ========================
  3076                          
  3077                          msg_checkpoint_eom:
  3078                          
  3079                          ;; messages all have to be <=40 bytes long
  3080                          
  3081                          msg_utilitymenu:
  3082  afa1 53454c4543542055...        !text "SELECT UTILITY TO LAUNCH"
  3083  afb9 00                         !8 0
  3084                          
  3085                          msg_noutilitymenu:
  3086  afba 484f4c4420414c54...                        !text "HOLD ALT + POWER CYCLE FOR UTILITY MENU"
  3087  afe1 00                                         !8 0
  3088                          
  3089                          msg_noflashmenu:
  3090  afe2 484f4c44204e4f20...                        !text "HOLD NO SCROLL + POWER CYCLE FOR FLASH"
  3091  b008 00                                         !8 0
  3092                          
  3093  b009 52452d545259494e...msg_retryreadmbr:       !text "RE-TRYING TO READ MBR"
  3094  b01e 00                                         !8 0
  3095  b01f 4d4547413635204d...msg_hyppo:              !text "MEGA65 MEGAOS HYPERVISOR V00.17"
  3096  b03e 00                                         !8 0
  3097  b03f 4e4f205343524f4c...msg_hyppohelpfirst:     !text "NO SCROLL=FLASH, ALT=UTILS, CTRL=HOLD"
  3098  b064 00                                         !8 0
  3099  b065 504f574552204f46...msg_hyppohelpnotfirst:  !text "POWER OFF/ON FOR FLASH OR UTIL MENU"
  3100  b088 00                                         !8 0
  3101  b089 524f4d2043484543...msg_romok:              !text "ROM CHECKSUM OK - BOOTING"
  3102  b0a2 00                                         !8 0
  3103                          ;; msg_rombad:          !text "ROM CHECKSUM FAIL - LOADING ROMS"
  3104                          ;;                      !8 0
  3105                          ;; msg_charrombad:      !text "COULD NOT LOAD CHARROM.M65"
  3106                          ;;                      !8 0
  3107  b0a3 4c4f414445442043...msg_charromloaded:      !text "LOADED CHARROM.M65"
  3108  b0b5 00                                         !8 0
  3109  b0b6 4c4f41444544204d...msg_megaromloaded:      !text "LOADED MEGA65.ROM"
  3110  b0c7 00                                         !8 0
  3111  b0c8 4c4f4f4b494e4720...msg_tryingsdcard:       !text "LOOKING FOR SDHC CARD >=4GB..."
  3112  b0e6 00                                         !8 0
  3113  b0e7 5344204341524420...msg_foundsdcard:        !text "SD CARD IS NOT SDHC. MUST BE SDHC."
  3114  b109 00                                         !8 0
  3115  b10a 464f554e4420414e...msg_foundsdhccard:      !text "FOUND AND RESET SDHC CARD"
  3116  b123 00                                         !8 0
  3117  b124 4552524f52205245...msg_sdcarderror:        !text "ERROR READING FROM SD CARD"
  3118  b13e 00                                         !8 0
  3119                          ;; msg_sdredoread:      !text "RE-READING SDCARD"
  3120                          ;;                      !8 0
  3121  b13f 4e4f205344434152...msg_nosdcard:           !text "NO SDCARD, TRYING BUILT-IN ROM"
  3122  b15d 00                                         !8 0
  3123  b15e 424144204d425220...msg_badformat:          !text "BAD MBR OR DOS BOOT SECTOR."
  3124  b179 00                                         !8 0
  3125                          ;; msg_sdcardfound:     !text "READ PARTITION TABLE FROM SDCARD"
  3126                          ;;                      !8 0
  3127                          ;; msg_foundromfile:    !text "FOUND ROM FILE. START CLUSTER = $$$$$$$$"
  3128                          ;;                      !8 0
  3129  b17a 4449534b2d434f55...msg_diskcount:          !text "DISK-COUNT=$$, DEFAULT-DISK=$$"
  3130  b198 00                                         !8 0
  3131                          ;; msg_diskdata0:       !text "DISK-TABLE:"
  3132                          ;;                      !8 0
  3133                          ;; msg_diskdata:        !text "BB$$:$$.$$.$$.$$.$$.$$.$$.$$"
  3134                          ;;                      !8 0
  3135                          ;; msg_filelengths:     !text "LOOKING FOR $$ BYTES, I SEE $$ BYTES"
  3136                          ;;                      !8 0
  3137  b199 434f554c44204e4f...msg_fileopenerror:      !text "COULD NOT OPEN ROM FILE FOR READING"
  3138  b1bc 00                                         !8 0
  3139                          ;; msg_readingfile:     !text "READING ROM FILE..."
  3140                          ;;                      !8 0
  3141  b1bd 524f4d20544f4f20...msg_romfilelongerror:   !text "ROM TOO LONG: (READ $$$$ PAGES)"
  3142  b1dc 00                                         !8 0
  3143  b1dd 524f4d20544f4f20...msg_romfileshorterror:  !text "ROM TOO SHORT: (READ $$$$ PAGES)"
  3144  b1fd 00                                         !8 0
  3145  b1fe 43555252454e5420...msg_clusternumber:      !text "CURRENT CLUSTER=$$$$$$$$"
  3146  b216 00                                         !8 0
  3147  b217 43555252454e5420...msg_sectoraddress:      !text "CURRENT SECTOR= $$$$$$$$"
  3148  b22f 00                                         !8 0
  3149  b230 43414e4e4f54204d...msg_nod81:              !text "CANNOT MOUNT D81 - (ERRNO: $$)"
  3150  b24e 00                                         !8 0
  3151  b24f 4438312053554343...msg_d81mounted:         !text "D81 SUCCESSFULLY MOUNTED"
  3152  b267 00                                         !8 0
  3153  b268 52454c4541534520...msg_releasectrl:        !text "RELEASE CONTROL TO CONTINUE BOOTING."
  3154  b28c 00                                         !8 0
  3155  b28d 535733204f464620...msg_dipswitch3on:       !text "SW3 OFF OR PRESS RUN/STOP TO CONTINUE."
  3156  b2b3 00                                         !8 0
  3157  b2b4 434f554c44204e4f...msg_romnotfound:        !text "COULD NOT FIND ROM MEGA65XXROM"
  3158  b2d2 00                                         !8 0
  3159                          ;;msg_foundhickup:      !text "LOADING HICKUP.M65 INTO HYPERVISOR"
  3160                          ;;                      !8 0
  3161  b2d3 434f554c44204e4f...msg_no1541rom:          !text "COULD NOT LOAD 1541ROM.M65"
  3162  b2ed 00                                         !8 0
  3163                          ;; msg_nohickup:        !text "NO HICKUP.M65 TO LOAD (OR BROKEN)"
  3164                          ;;                      !8 0
  3165                          ;; msg_hickuploaded:    !text "HICKUP LOADED TO 00004000 - $$$$$$$$"
  3166                          ;;                      !8 0
  3167  b2ee 52554e4e494e4720...msg_alreadyhicked:      !text "RUNNING HICKED HYPERVISOR"
  3168  b307 00                                         !8 0
  3169                          ;;msg_lookingfornextsector:
  3170                          ;;                      !text "LOOKING FOR NEXT SECTOR OF FILE"
  3171                          ;;                      !8 0
  3172  b308 434f554c44204e4f...msg_nologo:             !text "COULD NOT LOAD BANNER.M65 (ERRNO:$$)"
  3173  b32c 00                                         !8 0
  3174  b32d 434f554c44204e4f...msg_cdrootfailed:       !text "COULD NOT CHDIR TO / (ERRNO:$$)"
  3175  b34c 00                                         !8 0
  3176  b34d 545259494e472053...msg_tryingcard0:        !text "TRYING SDCARD BUS 0"
  3177  b360 00                                         !8 0
  3178  b361 5553494e47205344...msg_usingcard1:         !text "USING SDCARD BUS 1"
  3179  b373 00                                         !8 0
  3180  b374 444d414749432052...msg_dmagica:            !text "DMAGIC REV A MODE"
  3181  b385 00                                         !8 0
  3182  b386 444d414749432052...msg_dmagicb:            !text "DMAGIC REV B MODE"
  3183  b397 00                                         !8 0
  3184                          
  3185                          ;; Include the GIT Message as a string

; ******** Source: ../version.asm
     1                          msg_gitcommit:
     2  b398 4749543a20484541...	!text "GIT: HEAD,20250618.10,aaf4542~"
     3  b3b6 00                 	!8 0

; ******** Source: src/hyppo/main.asm
  3187                          
  3188  b3b7 00                 msg_blankline:          !8 0
  3189                          
  3190                          ;;         ========================
  3191                                      ;; filename of 1541 ROM
  3192  b3b8 31353431524f4d2e...txt_1541ROM:            !text "1541ROM.M65"
  3193  b3c3 00                                         !8 0
  3194                          
  3195                                      ;; filename of character ROM
  3196  b3c4 43484152524f4d2e...txt_CHARROMM65:         !text "CHARROM.M65"
  3197  b3cf 00                                         !8 0
  3198                          
  3199                                      ;; filename of ROM we want to load in FAT directory format
  3200                                      ;; (the two zero bytes are so that we can insert an extra digit after
  3201                                      ;; the 5, when a user presses a key, so that they can choose a
  3202                                      ;; different ROM to load).
  3203                                      ;;
  3204  b3d0 4d45474136352e52...txt_MEGA65ROM:          !text "MEGA65.ROM"
  3205  b3da 0000                                       !8 0,0
  3206                          
  3207                                      ;; filename of 1581 disk image we mount by default
  3208                                      ;;
  3209  b3dc 4d45474136352e44...txt_MEGA65D81:          !text "MEGA65.D81"
  3210  b3e6 00000000000000                             !8 0,0,0,0,0,0,0
  3211                          
  3212                                      ;; filename of hyppo update file
  3213                                      ;;
  3214  b3ed 4849434b55502e4d...txt_HICKUPM65:          !text "HICKUP.M65"
  3215  b3f7 00                                         !8 0
  3216                          
  3217                                      ;; filename containing boot logo
  3218                                      ;;
  3219  b3f8 42414e4e45522e4d...txt_BOOTLOGOM65:        !text "BANNER.M65"
  3220  b402 00                                         !8 0
  3221                          
  3222                                      ;; filename containing freeze menu
  3223  b403 465245455a45522e...txt_FREEZER:            !text "FREEZER.M65"
  3224  b40e 00                                         !8 0
  3225                          
  3226  b40f 4554484c4f41442e...txt_ETHLOAD:            !text "ETHLOAD.M65"
  3227  b41a 00                                         !8 0
  3228                          
  3229                                      ;; If this file is present, then machine starts up with video
  3230                                      ;; mode set to NTSC (60Hz), else as PAL (50Hz).
  3231                                      ;; This is to allow us to boot in PAL by default, except for
  3232                                      ;; those who have a monitor that cannot do 50Hz.
  3233                          ;; txt_NTSC:            !text "NTSC"
  3234                          ;;                      !8 0
  3235                          
  3236                          ;;         ========================
  3237                          
  3238                          !if DEBUG_HYPPO {
  3239                                  !src "debug.asm"
  3240                          }
  3241                          
  3242                          ;;         ========================
  3243                          
  3244                                  ;; Table of available disks.
  3245                                  ;; Include native FAT32 disks, as well as (in the future at least)
  3246                                  ;; mounted .D41, .D71, .D81 and .DHD files using Commodore DOS filesystems.
  3247                                  ;; But for now, we are supporting only FAT32 as the filesystem.
  3248                                  ;; See hyppo_dos.asm for information on how the table is used.
  3249                                  ;; Entries are 32 bytes long, so we can have 6 of them.
  3250                                  ;;
  3251                                  dos_max_disks = 6
  3252                          
  3253                                  ;; .segment DOSDiskTable
  3254                                  * = DOSDiskTable_Start
  3255                          dos_disk_table:
  3256                          
  3257                                  ;; .segment SysPartStructure
  3258                                  * = SysPartStructure_Start
  3259                          
  3260                          syspart_structure:
  3261                          
  3262                          syspart_start_sector:
  3263  bbc0 00000000                   !8 0,0,0,0
  3264                          syspart_size_in_sectors:
  3265  bbc4 00000000                   !8 0,0,0,0
  3266                          syspart_reserved:
  3267  bbc8 0000000000000000           !8 0,0,0,0,0,0,0,0
  3268                          
  3269                          ;; For fast freezing/unfreezing, we have a number of contiguous
  3270                          ;; freeze slots that can each store the state of the machine
  3271                          ;; We note where the area begins, how big it is, how many slots
  3272                          ;; it has, and how many sectors are used at the start of the area
  3273                          ;; to hold a directory with 128 bytes per slot, the contains info
  3274                          ;; about the frozen program.
  3275                          syspart_freeze_area_start:
  3276  bbd0 00000000                   !8 0,0,0,0
  3277                          syspart_freeze_area_size_in_sectors:
  3278  bbd4 00000000                   !8 0,0,0,0
  3279                          syspart_freeze_slot_size_in_sectors:
  3280  bbd8 00000000                   !8 0,0,0,0
  3281                          syspart_freeze_slot_count:
  3282  bbdc 0000                       !8 0,0
  3283                          syspart_freeze_directory_sector_count:
  3284  bbde 0000                       !8 0,0
  3285                          
  3286                                  ;; The first 64 freeze slots are reserved for various purposes
  3287                                 syspart_freeze_slots_reserved  = 64
  3288                                  ;; Freeze slot 0 is used when the hypervisor needs to
  3289                                  ;; temporarily shove all or part of the active process out
  3290                                  ;; the way to do something
  3291                                 freeze_slot_temporary = 0
  3292                          
  3293                                  ;; Freeze slots 1 - 63 are currently reserved
  3294                                  ;; They will likely get used for a service call-stack
  3295                                  ;; among other purposes.
  3296                          
  3297                                  ;; We then have a similar area for system services, which are stored
  3298                                  ;; using much the same representation, but are used as helper
  3299                                  ;; programs.
  3300                          syspart_service_area_start:
  3301  bbe0 00000000                   !8 0,0,0,0
  3302                          syspart_service_area_size_in_bytes:
  3303  bbe4 00000000                   !8 0,0,0,0
  3304                          syspart_service_slot_size_in_bytes:
  3305  bbe8 00000000                   !8 0,0,0,0
  3306                          syspart_service_slot_count:
  3307  bbec 0000                       !8 0,0
  3308                          syspart_service_directory_sector_count:
  3309  bbee 0000                       !8 0,0
  3310                          
  3311                          ;; /*  -------------------------------------------------------------------
  3312                          ;;     Hypervisor DOS work area and scratch pad at $BC00-$BCFF
  3313                          ;;     ---------------------------------------------------------------- */
  3314                          
  3315                                  ;; .segment DOSWorkArea
  3316                                  * = DOSWorkArea_Start
  3317                          
  3318                          hyppo_scratchbyte0:
  3319  bc00 00                         !8 $00
  3320                          
  3321                                  ;; The number of disks we have
  3322                                  ;;
  3323                          dos_disk_count:
  3324  bc01 00                         !8 $00
  3325                          
  3326                                  ;; The default disk
  3327                                  ;;
  3328                          dos_default_disk:
  3329  bc02 00                         !8 $00
  3330                          
  3331                                  ;; The current disk
  3332                                  ;;
  3333                          dos_disk_current_disk:
  3334  bc03 00                         !8 $00
  3335                          
  3336                                  ;; Offset of current disk entry in disk table
  3337                                  ;;
  3338                          dos_disk_table_offset:
  3339  bc04 00                         !8 $00
  3340                          
  3341                                  ;; cluster of current directory of current disk
  3342                                  ;;
  3343                          dos_disk_cwd_cluster:
  3344  bc05 00000000                   !8 0,0,0,0
  3345                          
  3346                          ;;         ========================
  3347                          
  3348                                  ;; start of directory entry. Used to 'rewind' to start of directory entry after readdir/findfile.
  3349                                  ;; These fields must be contiguous, as dos_readdir_storecurrententry and dos_readdir_retreivelastentry rely on it.
  3350                          
  3351                          dos_direntstart_cluster:
  3352  bc09 00000000                   !8 0,0,0,0
  3353                          dos_direntstart_sectorincluster:
  3354  bc0d 00                         !8 0
  3355                          dos_direntstart_offsetinsector:
  3356  bc0e 0000                       !8 0,0
  3357                          
  3358                          ;;         ========================
  3359                          
  3360                                  ;; WARNING: dos_readdir_read_next_entry uses carnal knowledge about the following
  3361                                  ;;          structure, particularly the length as calculated here:
  3362                                  ;;
  3363                                  dos_dirent_structure_length = dos_dirent_struct_end - dos_dirent_struct_start
  3364                          
  3365                                  ;; Current long filename (max 64 bytes)
  3366                                  ;;
  3367                          dos_dirent_struct_start:
  3368                          dos_dirent_longfilename:
  3369  bc10 56656e657a75616c...        !text "Venezualen casaba melon productio" ;; 33-chars
  3370  bc31 6e20737461746973...        !text "n statistics (2012-2015).txt  "    ;; 30-chars
  3371  bc4f 00                         !8 0
  3372                          
  3373                          dos_dirent_longfilename_length:
  3374  bc50 00                         !8 0
  3375                          
  3376                          dos_dirent_shortfilename:
  3377  bc51 46494c454e414d45...        !text "FILENAME.EXT"
  3378  bc5d 00                         !8 0
  3379                          
  3380                          dos_dirent_cluster:
  3381  bc5e 00000000                   !8 0,0,0,0
  3382                          
  3383                          dos_dirent_length:
  3384  bc62 00000000                   !8 0,0,0,0
  3385                          
  3386                          dos_dirent_type_and_attribs:
  3387  bc66 00                         !8 0
  3388                          dos_dirent_struct_end:
  3389                          
  3390                          ;;         ========================
  3391                          
  3392                                  ;; Requested file name and length
  3393                                  ;;
  3394                          dos_requested_filename_len:
  3395  bc67 00                         !8 0
  3396                          
  3397                          dos_requested_filename:
  3398  bc68 56656e657a75616c...        !text "Venezualen casaba melon productio"
  3399  bc89 6e20737461746973...        !text "n statistics (2007-2011).txt     "
  3400                          
  3401                          ;;         ========================
  3402                          
  3403                                  ;; Details about current DOS request
  3404                                  ;;
  3405  bcaa 0000               dos_sectorsread:                !16 0
  3406  bcac 00000000           dos_bytes_remaining:            !16 0,0
  3407  bcb0 00000000           dos_current_sector:             !16 0,0
  3408  bcb4 00000000           dos_current_cluster:            !16 0,0
  3409  bcb8 00                 dos_current_sector_in_cluster:  !8 0
  3410                          
  3411                          ;; Current file descriptors
  3412                          ;; Each descriptor has:
  3413                          ;;   disk id : 1 byte ($00-$07 = file open, $FF = file closed)
  3414                          ;;   access mode : 1 byte ($00 = read only)
  3415                          ;;   start cluster : 4 bytes
  3416                          ;;   current cluster : 4 bytes
  3417                          ;;   current sector in cluster : 1 byte
  3418                          ;;   offset in sector: 2 bytes
  3419                          ;;   file offset / $100 : 3 bytes
  3420                          ;;
  3421                                  dos_filedescriptor_max = 4
  3422                                  dos_filedescriptor_offset_diskid = 0
  3423                                  dos_filedescriptor_offset_mode = 1
  3424                                  dos_filedescriptor_offset_startcluster = 2
  3425                          ;;
  3426                          ;; These last four fields must be contiguous,
  3427                          ;; as dos_rmfile and dos_open_current_file rely on it.
  3428                          ;;
  3429                                  dos_filedescriptor_offset_currentcluster = 6
  3430                                  dos_filedescriptor_offset_sectorincluster = 10
  3431                                  dos_filedescriptor_offset_offsetinsector = 11
  3432                                  dos_filedescriptor_offset_fileoffset = 13
  3433                          
  3434                          dos_file_descriptors:
  3435  bcb9 ff00000000000000...        !8 $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0        ;; each is 16 bytes
  3436  bcc9 ff00000000000000...        !8 $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  3437  bcd9 ff00000000000000...        !8 $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  3438  bce9 ff00000000000000...        !8 $FF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  3439                          
  3440                              ;; The current file descriptor
  3441                              ;;
  3442                          dos_current_file_descriptor:
  3443  bcf9 00                         !8 0
  3444                          
  3445                              ;; Offset of current file descriptor
  3446                              ;;
  3447                          dos_current_file_descriptor_offset:
  3448  bcfa 00                         !8 0
  3449                          
  3450                          dos_first_vfat_chunk_in_list_flag:
  3451  bcfb 00                         !8 0
  3452                          
  3453                          ;;         ========================
  3454                          
  3455                              ;; For providing feedback on why DOS calls have failed
  3456                              ;; There is a set of error codes defined in hyppo_dos.asm
  3457                          dos_error_code:
  3458  bcfc 00                         !8 $00
  3459                          
  3460                              ;; Similarly for system partition related errors
  3461                          syspart_error_code:
  3462  bcfd 00                         !8 $00
  3463                          
  3464                              ;; Non-zero if there is a valid system partition
  3465                          syspart_present:
  3466  bcfe 00                         !8 $00
  3467                          
  3468                          ;; /*  -------------------------------------------------------------------
  3469                          ;;     Reserved space for Hypervisor Process work area $BD00-$BDFF
  3470                          ;;     ---------------------------------------------------------------- */
  3471                                  ;; .segment ProcessDescriptors
  3472                                  * = ProcessDescriptors_Start
  3473                          

; ******** Source: process_descriptor.asm
     1                          ;; /*  -------------------------------------------------------------------
     2                          ;;     MEGA65 "HYPPOBOOT" Combined boot and hypervisor ROM.
     3                          ;;     Paul Gardner-Stephen, 2014-2024.
     4                          ;;     ---------------------------------------------------------------- */
     5                          
     6                                  ;; Process descriptor block (fixed 256 bytes)
     7                                  ;;
     8                                  ;; This needs to have information about the current running task,
     9                                  ;; and also hold information about the current open files, if any.
    10                          
    11                                  ;; Process description (first 128 bytes)
    12                          
    13                                  start = *
    14                          currenttask_block:
    15                          
    16                                  ;; Tasks are idenfied by what amounts to an 8-bit process id.
    17                                  ;; Process ID #$FF is special, and indicates that it is the operating system/hypervisor
    18                                  ;; that is active.  This affects how results are return from system calls, so that they
    19                          
    20                          currenttask_id:
    21  bd00 ff                         !8 $FF
    22                          
    23                                  ;; Name of task (16 characters, unused characters should be null)
    24                          
    25                          currenttask_name:
    26  bd01 4f5045524154494e...        !text "OPERATING SYSTEM"
    27                          
    28                                  ;; the following fields are for all types of images, not only D81
    29                          
    30                                  ;; known flags:
    31                                  ;; .0 FLAG_MOUNTED  - enable drive virtualisation
    32                                  ;; .1 FLAG_NODISK   - don't mount a disk image
    33                                  ;; .2 FLAG_WRITE_EN - mount the image with write enabled
    34                          currenttask_d81_image0_flags:
    35  bd11 00                         !8 0
    36                          currenttask_d81_image1_flags:
    37  bd12 00                         !8 0
    38                          
    39                                  ;; File names of currently mounted disk images (32 character max length)
    40                          currenttask_d81_image0_namelen:
    41  bd13 00                         !8 0
    42                          currenttask_d81_image1_namelen:
    43  bd14 00                         !8 0
    44                          currenttask_d81_image0_name:
    45  bd15 2020202020202020...        !text "                                "
    46                          currenttask_d81_image1_name:
    47  bd35 2020202020202020...        !text "                                "
    48                          
    49                                  ;; DOS work area is full, so some things over-flow here:
    50                          
    51                                  ;; Used to temporarily stash the currently read SD card sector.
    52                                  ;; (mostly to hide when we have to read a FAT sector during file
    53                                  ;; access)
    54                          dos_stashed_sd_sector_number:
    55  bd55 00000000                   !8 0,0,0,0
    56                          
    57                          
    58                                  ;; Make sure we don't over-flow the available space
    59                                  * = start + $80
    60                          
    61                                  ;; Now we have file control blocks for the open files/directories.
    62                                  ;; We have only 128 bytes for these, so not many files can be open at a time!
    63                                  ;; This also means that we don't keep much information about a file in here.
    64                                  ;; For example, name, permissions/attributes and so on must be requested seprately
    65                                  ;; using trap_dos_fstat.  As a result, we can fit a few more open files in here, to
    66                                  ;; make life easy for programmers.  128 bytes / 32 bytes = 4 open files, which seems
    67                                  ;; a fairly minimal number.
    68                          
    69                          currenttask_filedescriptor0:
    70                                  ;; Which logical drive the file resides on
    71                                  ;; (or $FF for a free descriptor block = closed file.
    72                                  ;;  we put this in the first byte for convience for checking
    73                                  ;;  if a file descriptor is free).
    74                          currenttask_filedescriptor0_drivenumber:
    75  bd80 00                         !8 $00
    76                          
    77                                  ;; Starting cluster in file system
    78                                  ;; (used so that we can seek around in the file)
    79                          currenttask_filedescriptor0_startcluster:
    80  bd81 00000000                   !8 $00,$00,$00,$00
    81                          
    82                                  ;; Current cluster in file system
    83                          currenttask_filedescriptor0_currentcluster:
    84  bd85 00000000                   !8 $00,$00,$00,$00
    85                          
    86                                  ;; Current sector within current cluster
    87                          currenttask_filedescriptor0_sectorincluster:
    88  bd89 00                         !8 $00
    89                          
    90                                  ;; Length of file
    91                          currenttask_filedescriptor0_filelength:
    92  bd8a 00000000                   !8 $00,$00,$00,$00
    93                          
    94                                  ;; Position in file indicated by the buffer
    95                          currenttask_filedescriptor0_bufferposition:
    96  bd8e 00000000                   !8 $00,$00,$00,$00
    97                          
    98                                  ;; Cluster of the directory in which this file resides
    99                          currenttask_filedescriptor0_directorycluster:
   100  bd92 00000000                   !8 $00,$00,$00,$00
   101                          
   102                                  ;; Which entry this file is within the containing directory
   103                          currenttask_filedescriptor0_entryindirectory:
   104  bd96 0000                       !16 $0000
   105                          
   106                                  ;; Buffer address in target task used for this file
   107                                  ;; (32-bit virtual address, so that the buffer can be paged out)
   108                          currenttask_filedescriptor0_bufferaddress:
   109  bd98 00000000                   !8 $00,$00,$00,$00
   110                          
   111                                  ;; bytes loaded into buffer
   112                          currenttask_filedescriptor0_bytesinbuffer:
   113  bd9c 0000                       !16 $0000
   114                          
   115                                  ;; current offset within buffer
   116                          currenttask_filedescriptor0_offsetinbuffer:
   117  bd9e 0000                       !16 $0000
   118                          
   119                                  ;; The other three file descriptors follow the same format as the first
   120                          
   121                                  * = start + $a0
   122                          currenttask_filedescriptor1:
   123                          
   124                                  * = start + $c0
   125                          currenttask_filedescriptor2:
   126                          
   127                                  * = start + $e0
   128                          currenttask_filedescriptor3:
   129                          
   130                                  * = start + $100
   131                          

; ******** Source: src/hyppo/main.asm
  3475                          
  3476                          
  3477                          
  3478                          ;; /*  -------------------------------------------------------------------
  3479                          ;;     Reserved space for Hyppo ZP at $BF00-$BFFF
  3480                          ;;     ---------------------------------------------------------------- */
  3481                                  ;; .segment HyppoZP
  3482                                  * = HyppoZP_Start
  3483                          
  3484                                  ;; Temporary vector storage for DOS
  3485                                  ;;
  3486                          dos_scratch_vector:
  3487  bf00 00000000                   !16 0,0
  3488                          dos_scratch_byte_1:
  3489  bf04 00                         !8 0
  3490                          dos_scratch_byte_2:
  3491  bf05 00                         !8 0
  3492                          
  3493                                  ;; Vectors for copying data between hypervisor and user-space
  3494                                  ;;
  3495                          hypervisor_userspace_copy_vector:
  3496  bf06 0000                       !16 0
  3497                          
  3498                                  ;; general hyppo temporary variables
  3499                                  ;;
  3500                          zptempv:
  3501  bf08 0000                       !16 0
  3502                          zptempv2:
  3503  bf0a 0000                       !16 0
  3504                          zptempp:
  3505  bf0c 0000                       !16 0
  3506                          zptempp2:
  3507  bf0e 0000                       !16 0
  3508                          zptempv32:
  3509  bf10 00000000                   !16 0,0
  3510                          zptempv32b:
  3511  bf14 00000000                   !16 0,0
  3512                          dos_file_loadaddress:
  3513  bf18 00000000                   !16 0,0
  3514                          
  3515                          Qone:
  3516  bf1c 01000000                   !8 1,0,0,0
  3517                          
  3518                          !if DEBUG_HYPPO {
  3519                                  ;; Used for checkpoint debug system of hypervisor
  3520                                  ;;
  3521                          checkpoint_a:
  3522                                  !8 0
  3523                          checkpoint_x:
  3524                                  !8 0
  3525                          checkpoint_y:
  3526                                  !8 0
  3527                          checkpoint_z:
  3528                                  !8 0
  3529                          checkpoint_p:
  3530                                  !8 0
  3531                          checkpoint_pcl:
  3532                                  !8 0
  3533                          checkpoint_pch:
  3534                                  !8 0
  3535                          }
  3536                          
  3537                                  ;; SD card timeout handling
  3538                                  ;;
  3539                          sdcounter:
  3540  bf20 000000                     !8 0,0,0
  3541                          
  3542                          ;; /*  -------------------------------------------------------------------
  3543                          ;;     Scratch space in ZP space usually used by kernel
  3544                          ;;     we try to use address space not normally used by C64 kernel, so
  3545                          ;;     that it is possible to make calls to hyppo after boot. Eventually
  3546                          ;;     the desire is to have an SYS call that brings up a menu that lets
  3547                          ;;     you choose a disk image from a list.
  3548                          ;;     ---------------------------------------------------------------- */
  3549                          
  3550                          romslab:
  3551  bf23 00                         !8 0
  3552                          screenrow:
  3553  bf24 00                         !8 0
  3554                          checksum:
  3555  bf25 00000000                   !32 0
  3556                          file_pagesread:
  3557  bf29 0000                       !16 0
  3558                          
  3559                                  ;; Variables for testing of D81 boot image
  3560                          disk_lasttype:
  3561  bf2b 00                         !8 0
  3562                          d81_clusternumber:
  3563  bf2c 00000000                   !32 0
  3564                          d81_clustersneeded:
  3565  bf30 0000                       !16 0
  3566                          d64_clustersneeded:
  3567  bf32 0000                       !16 0
  3568                          d71_clustersneeded:
  3569  bf34 0000                       !16 0
  3570                          d81_clustercount:
  3571  bf36 0000                       !16 0
  3572                          dos_attach_offset:
  3573  bf38 00                         !8 0
  3574                          
  3575                                  ;; Make sure we pad to full size
  3576                                  * = Hyppo_End
  3577  bfff 00                         !8 0
